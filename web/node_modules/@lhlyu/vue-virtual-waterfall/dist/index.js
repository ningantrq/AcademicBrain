var U = Object.defineProperty;
var W = Object.getOwnPropertySymbols;
var L = Object.prototype.hasOwnProperty, k = Object.prototype.propertyIsEnumerable;
var I = (e, t, o) => t in e ? U(e, t, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[t] = o, T = (e, t) => {
  for (var o in t || (t = {}))
    L.call(t, o) && I(e, o, t[o]);
  if (W)
    for (var o of W(t))
      k.call(t, o) && I(e, o, t[o]);
  return e;
};
var H = (e, t) => {
  var o = {};
  for (var u in e)
    L.call(e, u) && t.indexOf(u) < 0 && (o[u] = e[u]);
  if (e != null && W)
    for (var u of W(e))
      t.indexOf(u) < 0 && k.call(e, u) && (o[u] = e[u]);
  return o;
};
import { onMounted as O, nextTick as q, getCurrentScope as J, onScopeDispose as Q, unref as X, getCurrentInstance as G, ref as h, watch as A, computed as C, defineComponent as Y, useSlots as Z, watchEffect as ee, openBlock as _, createElementBlock as B, normalizeStyle as V, Fragment as te, renderList as ne, renderSlot as oe } from "vue";
function N(e) {
  return J() ? (Q(e), !0) : !1;
}
function P(e) {
  return typeof e == "function" ? e() : X(e);
}
const ue = typeof window != "undefined" && typeof document != "undefined";
typeof WorkerGlobalScope != "undefined" && globalThis instanceof WorkerGlobalScope;
const ie = Object.prototype.toString, le = (e) => ie.call(e) === "[object Object]", re = () => {
};
function se(e) {
  return e || G();
}
function D(e, t = !0, o) {
  const u = se(o);
  u ? O(e, u) : t ? e() : q(e);
}
function w(e) {
  var t;
  const o = P(e);
  return (t = o == null ? void 0 : o.$el) != null ? t : o;
}
const $ = ue ? window : void 0;
function j(...e) {
  let t, o, u, m;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([o, u, m] = e, t = $) : [t, o, u, m] = e, !t)
    return re;
  Array.isArray(o) || (o = [o]), Array.isArray(u) || (u = [u]);
  const c = [], r = () => {
    c.forEach((d) => d()), c.length = 0;
  }, f = (d, n, l, i) => (d.addEventListener(n, l, i), () => d.removeEventListener(n, l, i)), a = A(
    () => [w(t), P(m)],
    ([d, n]) => {
      if (r(), !d)
        return;
      const l = le(n) ? T({}, n) : n;
      c.push(
        ...o.flatMap((i) => u.map((s) => f(d, i, s, l)))
      );
    },
    { immediate: !0, flush: "post" }
  ), g = () => {
    a(), r();
  };
  return N(g), g;
}
function ae() {
  const e = h(!1);
  return G() && O(() => {
    e.value = !0;
  }), e;
}
function ce(e) {
  const t = ae();
  return C(() => (t.value, !!e()));
}
function K(e, t, o = {}) {
  const n = o, { window: u = $ } = n, m = H(n, ["window"]);
  let c;
  const r = ce(() => u && "ResizeObserver" in u), f = () => {
    c && (c.disconnect(), c = void 0);
  }, a = C(() => Array.isArray(e) ? e.map((l) => w(l)) : [w(e)]), g = A(
    a,
    (l) => {
      if (f(), r.value && u) {
        c = new ResizeObserver(t);
        for (const i of l)
          i && c.observe(i, m);
      }
    },
    { immediate: !0, flush: "post", deep: !0 }
  ), d = () => {
    f(), g();
  };
  return N(d), {
    isSupported: r,
    stop: d
  };
}
function fe(e, t = {}) {
  const {
    reset: o = !0,
    windowResize: u = !0,
    windowScroll: m = !0,
    immediate: c = !0
  } = t, r = h(0), f = h(0), a = h(0), g = h(0), d = h(0), n = h(0), l = h(0), i = h(0);
  function s() {
    const p = w(e);
    if (!p) {
      o && (r.value = 0, f.value = 0, a.value = 0, g.value = 0, d.value = 0, n.value = 0, l.value = 0, i.value = 0);
      return;
    }
    const v = p.getBoundingClientRect();
    r.value = v.height, f.value = v.bottom, a.value = v.left, g.value = v.right, d.value = v.top, n.value = v.width, l.value = v.x, i.value = v.y;
  }
  return K(e, s), A(() => w(e), (p) => !p && s()), m && j("scroll", s, { capture: !0, passive: !0 }), u && j("resize", s, { passive: !0 }), D(() => {
    c && s();
  }), {
    height: r,
    bottom: f,
    left: a,
    right: g,
    top: d,
    width: n,
    x: l,
    y: i,
    update: s
  };
}
function pe(e, t = { width: 0, height: 0 }, o = {}) {
  const { window: u = $, box: m = "content-box" } = o, c = C(() => {
    var n, l;
    return (l = (n = w(e)) == null ? void 0 : n.namespaceURI) == null ? void 0 : l.includes("svg");
  }), r = h(t.width), f = h(t.height), { stop: a } = K(
    e,
    ([n]) => {
      const l = m === "border-box" ? n.borderBoxSize : m === "content-box" ? n.contentBoxSize : n.devicePixelContentBoxSize;
      if (u && c.value) {
        const i = w(e);
        if (i) {
          const s = u.getComputedStyle(i);
          r.value = Number.parseFloat(s.width), f.value = Number.parseFloat(s.height);
        }
      } else if (l) {
        const i = Array.isArray(l) ? l : [l];
        r.value = i.reduce((s, { inlineSize: p }) => s + p, 0), f.value = i.reduce((s, { blockSize: p }) => s + p, 0);
      } else
        r.value = n.contentRect.width, f.value = n.contentRect.height;
    },
    o
  );
  D(() => {
    const n = w(e);
    n && (r.value = "offsetWidth" in n ? n.offsetWidth : t.width, f.value = "offsetHeight" in n ? n.offsetHeight : t.height);
  });
  const g = A(
    () => w(e),
    (n) => {
      r.value = n ? t.width : 0, f.value = n ? t.height : 0;
    }
  );
  function d() {
    a(), g();
  }
  return {
    width: r,
    height: f,
    stop: d
  };
}
const de = ["data-index"], F = /* @__PURE__ */ Y({
  name: "VirtualWaterfall",
  __name: "virtual-waterfall",
  props: {
    virtual: { type: Boolean, default: !0 },
    rowKey: { default: "id" },
    gap: { default: 15 },
    preloadScreenCount: { default: () => [0, 0] },
    itemMinWidth: { default: 220 },
    maxColumnCount: { default: 10 },
    minColumnCount: { default: 2 },
    items: { default: () => [] },
    calcItemHeight: { type: Function, default: (e, t) => 250 }
  },
  setup(e) {
    const t = e;
    Z();
    const o = h(), { width: u } = pe(o), { top: m } = fe(o);
    O(() => {
      u.value === 0 && (u.value = Number.parseInt(window.getComputedStyle(o.value).width));
    });
    const c = C(() => {
      if (!u.value)
        return 0;
      const n = u.value - t.gap * 2;
      if (n >= t.itemMinWidth * 2) {
        const l = Math.floor(n / t.itemMinWidth);
        return t.maxColumnCount && l > t.maxColumnCount ? t.maxColumnCount : l;
      }
      return t.minColumnCount;
    }), r = h(new Array(c.value).fill(t.gap)), f = C(() => {
      if (!u.value || c.value <= 0)
        return 0;
      const n = (c.value - 1) * t.gap + t.gap * 2;
      return Math.floor((u.value - n) / c.value);
    }), a = h([]);
    ee(() => {
      if (!c.value) {
        a.value = [];
        return;
      }
      const n = t.items.length, l = new Array(n);
      let i = 0;
      const s = a.value.length && n > a.value.length;
      s ? i = a.value.length : r.value = new Array(c.value).fill(t.gap);
      for (let p = 0; p < n; p++) {
        if (s && p < i) {
          l[p] = a.value[p];
          continue;
        }
        const v = d(), x = t.calcItemHeight(t.items[p], f.value), y = r.value[v], S = {
          index: p,
          item: t.items[p],
          column: v,
          top: y,
          left: (f.value + t.gap) * v + t.gap,
          bottom: y + x,
          height: x
        };
        r.value[v] += x + t.gap, l[p] = S;
      }
      a.value = l;
    });
    const g = C(() => {
      const n = a.value.length;
      if (!n)
        return [];
      if (!t.virtual)
        return a.value;
      const l = o.value.parentElement.offsetTop, i = -m.value + l, [s, p] = t.preloadScreenCount, v = o.value.parentElement.clientHeight, x = i - s * v, y = i + (p + 1) * v;
      let S = 0, R = 0, z = !0;
      for (let b = 0; b < n; b++) {
        const M = a.value[b].top, E = a.value[b].bottom;
        (M >= x && M <= y || E >= x && E <= y || M < x && E > y) && (z && (S = b, z = !1), R = b);
      }
      return a.value.slice(S, R + 1);
    }), d = () => r.value.indexOf(Math.min(...r.value));
    return (n, l) => (_(), B("div", {
      ref_key: "content",
      ref: o,
      style: V({
        position: "relative",
        willChange: "height",
        height: `${Math.max(...r.value)}px`
      })
    }, [
      (_(!0), B(te, null, ne(g.value, (i) => {
        var s;
        return _(), B("div", {
          key: (s = i.item[n.rowKey]) != null ? s : i.index,
          style: V({
            position: "absolute",
            contentVisibility: "auto",
            width: `${f.value}px`,
            height: `${i.height}px`,
            transform: `translate(${i.left}px, ${i.top}px)`,
            containIntrinsicSize: `${f.value}px ${i.height}px`
          }),
          "data-index": i.index
        }, [
          oe(n.$slots, "default", {
            item: i.item,
            index: i.index
          })
        ], 12, de);
      }), 128))
    ], 4));
  }
}), me = {
  install(e) {
    e.component(F.name, F);
  }
};
export {
  F as VirtualWaterfall,
  me as default
};
