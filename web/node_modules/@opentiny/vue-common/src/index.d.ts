import hooks from './adapter';
import { appProperties, getElementStatusClass } from './adapter';
import { defineAsyncComponent, directive, emitter, h, Teleport } from './adapter';
import { parseVnode, isEmptyVnode, useRouter } from './adapter';
import { defineComponent, isVue2, isVue3 } from './adapter';
export { version } from '../package.json';
export { defineComponent, isVue2, isVue3, appProperties };
export declare const $prefix = "Tiny";
export declare const $props: {
    tiny_mode: StringConstructor;
    tiny_mode_root: BooleanConstructor;
    tiny_template: (ObjectConstructor | FunctionConstructor)[];
    tiny_renderless: FunctionConstructor;
    tiny_theme: StringConstructor;
    tiny_chart_theme: ObjectConstructor;
};
export declare const props: Array<'tiny_mode' | 'tiny_mode_root' | 'tiny_template' | 'tiny_renderless' | '_constants' | 'tiny_theme' | 'tiny_chart_theme'>;
export declare const resolveMode: (props: any, context: any) => any;
export declare const $setup: ({ props, context, template, extend }: {
    props: any;
    context: any;
    template: any;
    extend?: {} | undefined;
}) => () => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
    [key: string]: any;
}>;
export declare const mergeClass: (...cssClasses: any[]) => string;
export declare const design: {
    configKey: symbol;
    configInstance: null;
};
export declare const provideDesignConfig: (designConfig: any) => void;
declare const createComponent: ({ component, propsData, el }: {
    component: any;
    propsData: any;
    el: any;
}) => any;
export declare const setup: ({ props, context, renderless, api, extendOptions, mono, classes }: {
    props: any;
    context: any;
    renderless: any;
    api: any;
    extendOptions?: {} | undefined;
    mono?: boolean | undefined;
    classes?: {} | undefined;
}) => {
    t: (this: any, path: any, options?: any) => any;
    vm: any;
    f: (props: any, attrs?: {}) => {};
    a: (attrs: any, filters: any, include: any) => {};
    d: (props: any) => void;
    dp: (props: any) => void;
    gcls: (key: any) => any;
};
export declare const svg: ({ name, component }: {
    name?: string | undefined;
    component: any;
}) => (propData?: any) => hooks.Raw<hooks.DefineComponent<{}, () => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, hooks.ComponentOptionsMixin, hooks.ComponentOptionsMixin, {}, string, hooks.VNodeProps & hooks.AllowedComponentProps & hooks.ComponentCustomProps, Readonly<hooks.ExtractPropTypes<{}>>, {}, {}>>;
export declare const filterAttrs: (attrs: any, filters: any, include: any) => {};
export declare let setupComponent: {};
export declare const initComponent: () => void;
export declare const $install: (component: any) => void;
export type { PropType, ExtractPropTypes, DefineComponent, ComponentPublicInstance, SetupContext, ComputedRef } from './adapter';
export { h, hooks, directive, parseVnode, isEmptyVnode, useRouter, emitter, createComponent, defineAsyncComponent, getElementStatusClass, Teleport };
declare const _default: {
    h: (component: any, propsData?: any, childData?: any) => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
        [key: string]: any;
    }>;
    directive: (directives: any) => any;
    parseVnode: (vnode: any) => any;
    isEmptyVnode: (vnode: any) => boolean;
    useRouter: (instance?: hooks.ComponentInternalInstance | null) => {
        route: any;
        router: any;
    };
    emitter: () => {
        emit(eventName: any): void;
        on: (event: any, callback: any, once?: boolean) => void;
        once(event: any, callback: any): void;
        off(event: any, callback: any): void;
    };
    createComponent: ({ component, propsData, el }: {
        component: any;
        propsData: any;
        el: any;
    }) => any;
    defineAsyncComponent: typeof hooks.defineAsyncComponent;
    filterAttrs: (attrs: any, filters: any, include: any) => {};
    initComponent: () => void;
    setupComponent: {};
    svg: ({ name, component }: {
        name?: string | undefined;
        component: any;
    }) => (propData?: any) => hooks.Raw<hooks.DefineComponent<{}, () => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
        [key: string]: any;
    }>, {}, {}, {}, hooks.ComponentOptionsMixin, hooks.ComponentOptionsMixin, {}, string, hooks.VNodeProps & hooks.AllowedComponentProps & hooks.ComponentCustomProps, Readonly<hooks.ExtractPropTypes<{}>>, {}, {}>>;
    $prefix: string;
    $props: {
        tiny_mode: StringConstructor;
        tiny_mode_root: BooleanConstructor;
        tiny_template: (ObjectConstructor | FunctionConstructor)[];
        tiny_renderless: FunctionConstructor;
        tiny_theme: StringConstructor;
        tiny_chart_theme: ObjectConstructor;
    };
    props: ("tiny_mode" | "tiny_mode_root" | "tiny_template" | "tiny_renderless" | "_constants" | "tiny_theme" | "tiny_chart_theme")[];
    $setup: ({ props, context, template, extend }: {
        props: any;
        context: any;
        template: any;
        extend?: {} | undefined;
    }) => () => hooks.VNode<hooks.RendererNode, hooks.RendererElement, {
        [key: string]: any;
    }>;
    setup: ({ props, context, renderless, api, extendOptions, mono, classes }: {
        props: any;
        context: any;
        renderless: any;
        api: any;
        extendOptions?: {} | undefined;
        mono?: boolean | undefined;
        classes?: {} | undefined;
    }) => {
        t: (this: any, path: any, options?: any) => any;
        vm: any;
        f: (props: any, attrs?: {}) => {};
        a: (attrs: any, filters: any, include: any) => {};
        d: (props: any) => void;
        dp: (props: any) => void;
        gcls: (key: any) => any;
    };
    hooks: typeof hooks;
    getElementStatusClass: (className: any, status: any) => string | undefined;
    $install: (component: any) => void;
};
export default _default;
