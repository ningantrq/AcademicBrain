import { renderless, api } from "@opentiny/vue-renderless/flowchart/vue";
import { defineComponent, props, setup as _setup, emitter, h, isVue3 } from "@opentiny/vue-common";
import Popover from "@opentiny/vue-popover";
var getRenderLabel = function getRenderLabel2(_ref) {
  var omitText = _ref.omitText, font = _ref.font, width = _ref.width, padding = _ref.padding, popoverProps = _ref.popoverProps;
  return function(label, type) {
    if (!label)
      return null;
    var t = omitText(label, font, width - padding[1]);
    var fontClass = type === "main" ? "font-semibold text-color-text-primary" : "text-color-text-secondary";
    var labelClass = "w-full text-center whitespace-nowrap overflow-hidden text-ellipsis " + padding[0] + " " + fontClass;
    var lableVnode = h("div", {
      slot: "reference",
      class: labelClass
    }, label);
    if (!t.o)
      return lableVnode;
    var def = h("span", label);
    var childNodes = isVue3 ? {
      default: function _default() {
        return def;
      },
      reference: function reference() {
        return lableVnode;
      }
    } : [def, lableVnode];
    return h(Popover, popoverProps, childNodes);
  };
};
var renderShapeChildren = function renderShapeChildren2(_ref2) {
  var renderInner = _ref2.renderInner, raw = _ref2.raw, renderLabel = _ref2.renderLabel, main = _ref2.main, auxi = _ref2.auxi;
  var shapeVnodeChildren = null;
  if (typeof renderInner === "function") {
    shapeVnodeChildren = [renderInner(h, raw)];
  } else {
    var mainVnode = renderLabel(main, "main");
    var auxiVnode = renderLabel(auxi, "auxi");
    shapeVnodeChildren = [mainVnode, auxiVnode];
  }
  return shapeVnodeChildren;
};
var renderShapeVnode = function renderShapeVnode2(args) {
  var renderOuter = args.renderOuter, raw = args.raw, colors = args.colors, status = args.status, statusOngoing = args.statusOngoing, ongoingBackgroundColor = args.ongoingBackgroundColor;
  var shape = args.shape, statusFail = args.statusFail, error = args.error, shapeVnodeChildren = args.shapeVnodeChildren, popoverProps = args.popoverProps;
  var shapeVnode = null;
  if (typeof renderOuter === "function") {
    shapeVnode = renderOuter(h, raw);
  } else {
    var borderColor = "border-color:" + colors[status] + ";";
    var backgroundColor = status === statusOngoing ? "background-color:" + ongoingBackgroundColor + ";" : "";
    var cls = ["w-full h-full border-0.5 sm:border border-solid flex flex-col items-center cursor-pointer", shape === "circle" ? "rounded-full justify-center" : "", shape === "rectangle" ? "rounded justify-evenly" : ""];
    var styl = borderColor + backgroundColor;
    if (status === statusFail && error) {
      var def = h("span", error);
      var ref = h("div", {
        class: cls,
        style: styl,
        slot: "reference"
      }, shapeVnodeChildren);
      var childNodes = isVue3 ? {
        default: function _default() {
          return def;
        },
        reference: function reference() {
          return ref;
        }
      } : [def, ref];
      popoverProps.class = "w-full h-full block";
      shapeVnode = h(Popover, popoverProps, childNodes);
    } else {
      shapeVnode = h("div", {
        class: cls,
        style: styl,
        slot: "reference"
      }, shapeVnodeChildren);
    }
  }
  return shapeVnode;
};
var renderCondVnodes = function renderCondVnodes2(_ref3) {
  var isDot = _ref3.isDot, afterLinks = _ref3.afterLinks, afterConfig = _ref3.afterConfig, config = _ref3.config;
  if (!isDot)
    return [];
  var cfg = afterConfig || config || {};
  var condClass = cfg.condClass, renderCond = cfg.renderCond;
  return afterLinks.filter(function(_ref4) {
    var cond = _ref4.cond;
    return cond;
  }).map(function(afterLink) {
    var rect = afterLink.rect, raw = afterLink.raw;
    var clazz = "absolute flex justify-center items-center";
    var style = "left:" + rect.x + "px;top:" + rect.y + "px;width:" + rect.w + "px;height:" + rect.h + "px;";
    return h("div", {
      class: clazz,
      style
    }, [renderCond ? renderCond(h, afterLink, cfg) : h("div", {
      attrs: {
        title: raw.info.other.title
      },
      class: condClass || ""
    }, raw.info.other.title)]);
  });
};
var renderGroupVnodes = function renderGroupVnodes2(_ref5) {
  var afterGroups = _ref5.afterGroups, clickGroup = _ref5.clickGroup;
  if (!afterGroups)
    return [];
  return afterGroups.map(function(afterGroup) {
    var _afterGroup$raw = afterGroup.raw, title = _afterGroup$raw.title, titleClass = _afterGroup$raw.titleClass;
    var vnode = null;
    if (title) {
      var titlePosition = afterGroup.raw.titlePosition;
      var width = afterGroup.width, height = afterGroup.height;
      var p0 = afterGroup.coords[0];
      var p3 = afterGroup.coords[3];
      var pos = {
        x: 0,
        y: p3.y + 8
      };
      var centerClass = "";
      if (!titlePosition || titlePosition === "top-left") {
        pos.x = p0.x + 8;
      } else {
        pos.x = p3.x - width / 2;
        centerClass = "flex justify-center items-center";
      }
      vnode = h("div", {
        class: "absolute " + centerClass,
        style: {
          left: pos.x + "px",
          top: pos.y + "px",
          width: width + "px",
          height: height + "px"
        },
        on: {
          click: function click(e) {
            return clickGroup(afterGroup, e);
          }
        }
      }, [h("div", {
        class: "truncate",
        attrs: {
          title
        }
      }, [h("span", {
        class: titleClass
      }, title)])]);
    }
    return vnode;
  });
};
var _sfc_main = defineComponent({
  emits: ["click-node", "click-link", "click-blank", "click-group"],
  props: [].concat(props, ["data", "config"]),
  setup: function setup(props2, context) {
    return _setup({
      props: props2,
      context,
      renderless,
      api,
      extendOptions: {
        emitter
      }
    });
  },
  render: function render() {
    var state = this.state, omitText = this.omitText, config = this.config, clickNode = this.clickNode, clickGroup = this.clickGroup;
    var afterData = state.afterData, wrapperStyle = state.wrapperStyle, refreshKey = state.refreshKey;
    var graph = afterData.graph, afterNodes = afterData.afterNodes, afterLinks = afterData.afterLinks, afterGroups = afterData.afterGroups, afterConfig = afterData.afterConfig;
    var font = config.font, popoverPlacement = config.popoverPlacement, colors = config.colors, statusOngoing = config.statusOngoing, statusFail = config.statusFail, ongoingBackgroundColor = config.ongoingBackgroundColor;
    var ratio = graph.thin ? graph.thinValue : 1;
    var padding = ["px-1.5", 12];
    var isDot = config.type === "dot";
    var condVnodes = renderCondVnodes({
      isDot,
      afterLinks,
      afterConfig,
      config
    });
    var groupVnodes = renderGroupVnodes({
      afterGroups,
      clickGroup
    });
    return h("div", {
      attrs: {
        "data-tag": "tiny-flow-chart"
      },
      class: "relative",
      style: wrapperStyle,
      key: refreshKey
    }, [h("canvas", {
      attrs: {
        "data-tag": "tiny-flow-chart__canvas",
        width: graph.width * ratio,
        height: graph.height * ratio
      },
      class: graph.thin ? "scale-50 -translate-x-1/4 -translate-y-1/4" : "absolute top-0 left-0",
      ref: "canvas"
    })].concat(afterNodes.map(function(afterNode) {
      var x = afterNode.x, y = afterNode.y, width = afterNode.width, height = afterNode.height, raw = afterNode.raw;
      var info = raw.info, renderInner = raw.renderInner;
      var renderOuter = raw.renderOuter || config.renderOuter;
      var other = info.other, shape = info.shape, status = info.status;
      var main = other.main, auxi = other.auxi, error = other.error;
      var popoverProps = {
        props: {
          trigger: "hover",
          placement: popoverPlacement
        },
        class: "w-full block"
      };
      var renderLabel = getRenderLabel({
        omitText,
        font,
        width,
        padding,
        popoverProps
      });
      var shapeVnodeChildren = renderShapeChildren({
        renderInner,
        raw,
        renderLabel,
        main,
        auxi
      });
      var args = {
        renderOuter,
        raw,
        colors,
        status,
        statusOngoing,
        ongoingBackgroundColor
      };
      Object.assign(args, {
        shape,
        statusFail,
        error,
        shapeVnodeChildren,
        popoverProps
      });
      var shapeVnode = renderShapeVnode(args);
      var wrapperProps = {
        attrs: {
          "data-tag": "tiny-flow-chart__node"
        },
        style: "left:" + x + "px;top:" + y + "px;width:" + width + "px;height:" + height + "px;",
        class: ["absolute", {
          "flex justify-center items-center": isDot
        }],
        on: {
          click: function click(e) {
            return clickNode({
              afterNode
            }, e);
          }
        }
      };
      var outerClass = ["absolute w-6 h-6", {
        "sm:w-4 sm:h-4": config.nodeSize === "mini",
        "sm:w-8 sm:h-8": config.nodeSize === "medium"
      }];
      return h("div", wrapperProps, [isDot ? h("div", {
        class: outerClass
      }, [shapeVnode]) : shapeVnode]);
    }), condVnodes, groupVnodes));
  }
});
export {
  _sfc_main as default
};
