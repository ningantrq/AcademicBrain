import { renderless, api } from "@opentiny/vue-renderless/flowchart/vue";
import Clickoutside from "@opentiny/vue-renderless/common/deps/clickoutside";
import { defineComponent, props, directive, setup as _setup, emitter, h } from "@opentiny/vue-common";
import { IconYes, IconClose } from "@opentiny/vue-icon";
var _sfc_main = defineComponent({
  emits: ["click-node", "click-link", "click-blank"],
  props: [].concat(props, ["data", "config"]),
  directives: directive({
    Clickoutside
  }),
  setup: function setup(props2, context) {
    return _setup({
      props: props2,
      context,
      renderless,
      api,
      extendOptions: {
        emitter
      }
    });
  },
  render: function render() {
    var slots = this.slots, state = this.state, clearHoverAfterLink = this.clearHoverAfterLink, clickNode = this.clickNode, config = this.config, getVars = this.getVars, omitText = this.omitText;
    var afterData = state.afterData, dropdowns = state.dropdowns, refreshKey = state.refreshKey, wrapperStyle = state.wrapperStyle;
    var afterNodes = afterData.afterNodes, allItem = afterData.allItem;
    var nodes = afterNodes.map(function(afterNode) {
      var ret = getVars(afterNode, config);
      var background = ret.background, borderColor = ret.borderColor, half = ret.half, isCompleteFn = ret.isCompleteFn, isFailFn = ret.isFailFn, isOngoingFn = ret.isOngoingFn, statusName = ret.statusName, white = ret.white;
      var halfIconWrapperSize = half(config.iconWrapperSize);
      var wrapperStyle2 = "left:" + afterNode.x + "px;top:" + afterNode.y + "px;width:" + config.iconWrapperSize + "px;height:" + config.iconWrapperSize + "px;transform:translate(-" + halfIconWrapperSize + "px,-" + halfIconWrapperSize + "px);background:" + config.background + ";";
      var halfIconSize = half(config.iconSize);
      var iconWrapperPadding = halfIconWrapperSize - halfIconSize;
      var iconStyle = "width:" + config.iconSize + "px;height:" + config.iconSize + "px;border-radius:" + halfIconSize + "px;border-color:" + borderColor + ";transform:translate(" + iconWrapperPadding + "px," + iconWrapperPadding + "px);background:" + background + ";";
      var svgFill = isCompleteFn() ? borderColor : isFailFn() ? white : "";
      var svgStyle = "font-size:" + config.iconSvgSize + "px;fill:" + svgFill + ";";
      var iconComp = isCompleteFn() ? IconYes() : isFailFn() ? IconClose() : null;
      var labelWidth = config.labelWidth || afterData.widths[1] - config.labelSpacing;
      var labelHeight = config.labelHeight || afterData.heights[1] - config.labelSpacing;
      var halfLabelWidth = half(labelWidth);
      var labelTransform = config.anchor === "center" ? "translateX(" + (halfIconWrapperSize - halfLabelWidth) + "px)" : "";
      var labelStyle = "width:" + labelWidth + "px;height:" + labelHeight + "px;transform:" + labelTransform + ";";
      var baseStyle = "text-align:" + (config.anchor === "center" ? "center" : "left") + ";";
      var titleStyle = baseStyle + ("color:" + (isOngoingFn() ? config.colors[config.statusOngoing] : "") + ";");
      var dateStyle = baseStyle + ("color:" + config.labelDateColor + ";");
      var valid = function valid2(arr) {
        return Array.isArray(arr) && arr.length > config.listThreshold;
      };
      var showItem = slots.content && valid(afterNode.raw.info.items);
      var itemStyle = "width:" + config.listWidth + "px;height:" + config.iconWrapperSize + "px;background:" + config.background + ";";
      var params = {
        afterNode,
        node: afterNode.raw,
        config,
        allItem,
        dropdowns,
        showPop: dropdowns[afterNode.raw.name]
      };
      var iconVnode, lableVnodes;
      if (slots.icon) {
        iconVnode = slots.icon(params);
      } else {
        iconVnode = h("div", {
          class: "tiny-flow-chart__node-icon " + statusName,
          style: iconStyle
        }, [iconComp ? h(iconComp, {
          class: "tiny-flow-chart__node-svg",
          style: svgStyle
        }) : null]);
      }
      if (slots.label) {
        lableVnodes = [slots.label(params)];
      } else {
        var property = {
          class: "label-item label-title",
          style: titleStyle
        };
        var t = omitText(afterNode.raw.info.label, config.font, labelWidth);
        if (t.o) {
          property.attrs = {
            title: afterNode.raw.info.label
          };
        }
        lableVnodes = [h("div", property, t.t), h("div", {
          class: "label-item label-date",
          style: dateStyle
        }, afterNode.raw.info.date)];
      }
      return h("div", {
        class: "tiny-flow-chart__node-icon-wrapper",
        style: wrapperStyle2,
        on: {
          mousemove: clearHoverAfterLink,
          click: function click(e) {
            return clickNode(params, e);
          }
        }
      }, [iconVnode, h("div", {
        class: "tiny-flow-chart__node-label",
        style: labelStyle
      }, lableVnodes), showItem ? h("div", {
        class: "tiny-flow-chart__node-item",
        style: itemStyle
      }, [slots.content(params)]) : null]);
    });
    return h("div", {
      class: "tiny-flow-chart",
      style: wrapperStyle,
      key: refreshKey,
      directives: [{
        name: "clickoutside",
        expression: "clearDropdown"
      }]
    }, [h("canvas", {
      class: "tiny-flow-chart__canvas",
      attrs: {
        width: config.width,
        height: config.height
      },
      ref: "canvas"
    })].concat(nodes));
  }
});
export {
  _sfc_main as default
};
