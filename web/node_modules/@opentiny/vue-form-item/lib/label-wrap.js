function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
import { defineComponent, $props, h, setup as _setup } from "@opentiny/vue-common";
var labelWrap = defineComponent({
  props: _extends({}, $props, {
    isAutoWidth: Boolean,
    updateAll: Boolean,
    isMobile: Boolean,
    isMobileFirst: Boolean
  }),
  inject: ["form", "formItem"],
  render: function render() {
    var slotsDefault = this.slots.default && this.slots.default();
    var classPrefix = this.isMobile ? "tiny-mobile-" : "tiny-";
    if (!slotsDefault)
      return null;
    if (this.isAutoWidth) {
      var autoLabelWidth = this.form.autoLabelWidth;
      var style = {};
      if (autoLabelWidth && autoLabelWidth !== "auto") {
        var marginLeft = parseInt(autoLabelWidth, 10) - this.computedWidth;
        if (marginLeft) {
          style.marginLeft = marginLeft + "px";
        }
      }
      return h("div", {
        class: this.isMobileFirst ? "float-left" : classPrefix + "form-item_label-wrap",
        style
      }, slotsDefault);
    } else {
      return slotsDefault[0];
    }
  },
  methods: {
    getLabelWidth: function getLabelWidth() {
      var computedStylWidth = function computedStylWidth2(elem) {
        return window.getComputedStyle(elem).width;
      };
      var ceilFloat = function ceilFloat2(f) {
        return Math.ceil(parseFloat(f));
      };
      return !this.$el || !this.$el.firstElementChild ? 0 : ceilFloat(computedStylWidth(this.$el.firstElementChild));
    },
    updateLabelWidth: function updateLabelWidth(action) {
      var _this = this;
      if (action === void 0) {
        action = "update";
      }
      if (!this.$slots.default || !this.isAutoWidth || !this.$el.firstElementChild) {
        return;
      }
      var setComputedWidth = function setComputedWidth2() {
        return _this.computedWidth = _this.getLabelWidth();
      };
      var deregisterFormLabelWidth = function deregisterFormLabelWidth2() {
        return _this.form.deregisterLabelWidth(_this.computedWidth);
      };
      if (action === "update") {
        setComputedWidth();
      } else if (action === "remove") {
        deregisterFormLabelWidth();
      }
    }
  },
  watch: {
    computedWidth: function computedWidth(val, oldVal) {
      if (this.updateAll) {
        this.form.registerLabelWidth(val, oldVal);
        this.formItem.updateComputedLabelWidth(val);
      }
    }
  },
  setup: function setup(props, context) {
    var renderless = function renderless2(props2, _ref, _ref2) {
      var onMounted = _ref.onMounted, onUpdated = _ref.onUpdated, onBeforeUnmount = _ref.onBeforeUnmount;
      var vm = _ref2.vm;
      onMounted(function() {
        return vm.updateLabelWidth("update");
      });
      onUpdated(function() {
        return vm.updateLabelWidth("update");
      });
      onBeforeUnmount(function() {
        return vm.updateLabelWidth("remove");
      });
      return {
        computedWidth: 0
      };
    };
    var api = ["computedWidth"];
    return _setup({
      props,
      context,
      renderless,
      api
    });
  }
});
export {
  labelWrap as default
};
