function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
import { createVNode } from "vue";
import { defineComponent, $prefix, $props, setup as _setup, isVue2, parseVnode, h, hooks } from "@opentiny/vue-common";
import { renderless, api } from "@opentiny/vue-renderless/form-item/vue";
import LabelWrap from "./label-wrap";
import Tooltip from "@opentiny/vue-tooltip";
var $constants = {
  FORM_NAME: "Form",
  FORM_ITEM_NAME: "FormItem"
};
var _sfc_main = /* @__PURE__ */ defineComponent({
  name: $prefix + "FormItem",
  componentName: "FormItem",
  components: {
    LabelWrap,
    Tooltip
  },
  props: _extends({}, $props, {
    _constants: {
      type: Object,
      default: function _default() {
        return $constants;
      }
    },
    appendToBody: {
      type: Boolean,
      default: void 0
    },
    error: String,
    for: String,
    inlineMessage: {
      type: Boolean,
      default: void 0
    },
    messageType: String,
    label: String,
    labelWidth: String,
    manual: Boolean,
    popperOptions: {
      type: Object,
      default: function _default2() {
        return {};
      }
    },
    prop: String,
    required: {
      type: Boolean,
      default: void 0
    },
    rules: [Object, Array],
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String,
    validateDisabled: Boolean,
    validateDebounce: Boolean,
    validatePosition: String,
    validateStatus: String,
    validateType: String,
    validateIcon: {
      type: Object,
      default: null
    },
    ellipsis: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    }
  }),
  setup: function setup(props, context) {
    return _setup({
      props,
      context,
      renderless,
      api
    });
  },
  render: function render() {
    var _this = this, _class, _class2, _class3, _class4;
    var state = this.state, required = this.required, slots = this.slots, label = this.label, scopedSlots = this.scopedSlots, showMessage = this.showMessage, inlineMessage = this.inlineMessage, ellipsis = this.ellipsis, vertical = this.vertical, handleLabelMouseenter = this.handleLabelMouseenter, handleMouseleave = this.handleMouseleave;
    var validateIcon = state.validateIcon, isErrorInline = state.isErrorInline, isErrorBlock = state.isErrorBlock;
    var isMobile = state.mode === "mobile";
    var classPrefix = isMobile ? "tiny-mobile-" : "tiny-";
    var labelSlot = slots.label ? slots.label() : null;
    var defaultSlots = slots.default ? slots.default() : null;
    var errorSlot = scopedSlots.error && scopedSlots.error(state.validateMessage);
    var formItemClass = classPrefix + "form-item--" + (state.sizeClass ? state.sizeClass : "default");
    var isShowError = state.validateState === "error" && showMessage && state.form.showMessage;
    var validateTag = state.formInstance && state.formInstance.validateTag;
    var validateMessage;
    var ItemContent = defaultSlots ? defaultSlots.map(function(vnode) {
      if (isVue2 && !vnode.componentOptions && !validateTag)
        return vnode;
      var item = parseVnode(vnode);
      item.props = item.props || {};
      var type = item.type;
      Object.assign(item.props, {
        size: state.formItemSize,
        mini: state.formItemSize === "mini"
      });
      if (type && type.name && type.name.toLowerCase().endsWith("button")) {
        return item;
      }
      var propsData = item.props;
      if (propsData) {
        if (!state.isRequired) {
          state.validationRequired = propsData.validation && !!propsData.validation.required;
        }
        if (propsData.validation) {
          return item;
        }
      }
      if (isMobile) {
        return h("div", {
          class: classPrefix + "form-item__value",
          style: state.valueStyle
        }, [item]);
      }
      return item;
    }) : null;
    var getFormItemContnet = function getFormItemContnet2() {
      if (isMobile) {
        var _validatePosition = _this.validatePosition || state.formInstance.validatePosition || "right";
        validateMessage = state.validateMessage ? _validatePosition === "right" ? createVNode("div", {
          "class": "tiny-mobile-input-form__error align-right"
        }, [state.validateMessage]) : createVNode("div", {
          "class": "tiny-mobile-input-form__error align-left"
        }, [state.validateMessage]) : null;
        return ItemContent;
      }
      var tooltipTriggerContent = ItemContent.length > 1 ? h("div", {
        class: "tiny-mobile-form-item__content-muti-children"
      }, ItemContent) : ItemContent[0];
      if (!_this.showMessage) {
        return tooltipTriggerContent;
      }
      var formAppendToBody = state.formInstance && state.formInstance.appendToBody;
      var appendToBody = typeof _this.appendToBody === "boolean" ? _this.appendToBody : typeof formAppendToBody === "boolean" ? formAppendToBody : true;
      var validatePosition = _this.validatePosition || state.formInstance && state.formInstance.validatePosition || "top-end";
      var popperOptions = _extends({}, state.formInstance.popperOptions, _this.popperOptions, {
        forceAbsolute: !appendToBody,
        onUpdate: function onUpdate(options) {
          var popper = options.instance._popper;
          var translate3d = popper.style.transform;
          var matchTranslate = translate3d.match(/translate3d\((\w+)px, (\w+)px, (\w+)px\)/);
          if (!Array.isArray(matchTranslate)) {
            return;
          }
          var _matchTranslate$slice = matchTranslate.slice(1), x = _matchTranslate$slice[0], y = _matchTranslate$slice[1], z = _matchTranslate$slice[2];
          popper.style.transform = "translate3d(" + x + "px, " + parseInt(y, 10) + "px, " + z + "px)";
        }
      });
      var validateIconNode = validateIcon ? h(validateIcon, {
        class: "tooltip-validate-icon"
      }) : null;
      return h("tooltip", {
        props: {
          popperClass: classPrefix + "form__valid",
          arrowOffset: 0,
          adjustArrow: true,
          type: "normal",
          disabled: state.getValidateType !== "tip",
          placement: validatePosition,
          manual: true,
          appendToBody,
          popperOptions,
          modelValue: isShowError ? state.canShowTip : false,
          zIndex: "relative",
          renderContent: function renderContent() {
            return [validateIconNode, createVNode("span", {
              "class": classPrefix + "form-item__validate-message"
            }, [state.validateMessage])];
          }
        },
        on: {
          "update:modelValue": function updateModelValue(value) {
            state.canShowTip = value;
          }
        },
        ref: "tooltip"
      }, [!isVue2 && tooltipTriggerContent.type === hooks.Text ? createVNode("span", null, [tooltipTriggerContent]) : tooltipTriggerContent]);
    };
    var FormItemContnet = ItemContent ? getFormItemContnet() : null;
    var ErrorContent = isShowError && state.getValidateType === "text" ? errorSlot || h("div", {
      class: (_class = {}, _class[classPrefix + "form-item__error"] = true, _class[classPrefix + "form-item__error--inline"] = isErrorInline, _class[classPrefix + "form-item__error--block"] = isErrorBlock, _class),
      attrs: {
        title: [state.validateMessage]
      }
    }, [validateIcon ? h(validateIcon, {
      class: "validate-icon"
    }) : null, createVNode("span", {
      "class": classPrefix + "form-item__validate-message"
    }, [state.validateMessage])]) : null;
    var LabelContent = h("label-wrap", {
      props: {
        isAutoWidth: state.labelStyle && state.labelStyle.width === "auto",
        updateAll: state.form.labelWidth === "auto",
        isMobile: state.mode === "mobile"
      }
    }, [labelSlot || label ? h("label", {
      class: (_class2 = {}, _class2[classPrefix + "form-item__label"] = true, _class2["is-ellipsis"] = isMobile && ellipsis, _class2),
      style: state.labelStyle,
      attrs: {
        for: state.labelFor
      },
      on: {
        mouseenter: handleLabelMouseenter,
        mouseleave: handleMouseleave
      }
    }, labelSlot || label + state.form.labelSuffix) : null]);
    return h("div", {
      class: (_class3 = {}, _class3[classPrefix + "form-item"] = true, _class3[classPrefix + "form-item--feedback"] = state.formInstance && state.formInstance.statusIcon, _class3["is-error"] = state.validateState === "error", _class3["is-text"] = state.getValidateType === "text", _class3["is-validating"] = state.validateState === "validating", _class3["is-success"] = state.validateState === "success", _class3["is-required"] = state.isRequired || required, _class3["is-no-asterisk"] = state.hideRequiredAsterisk, _class3[formItemClass] = true, _class3)
    }, [!isMobile ? LabelContent : null, h("div", {
      class: (_class4 = {}, _class4[classPrefix + "form-item__content"] = true, _class4["is-vertical"] = isMobile && vertical, _class4),
      style: !isMobile && state.contentStyle
    }, [isMobile ? LabelContent : null, FormItemContnet, isMobile ? validateMessage : null, h("transition", {
      attrs: {
        name: classPrefix + "zoom-in-top"
      }
    }, [ErrorContent])])]);
  }
});
export {
  _sfc_main as default
};
