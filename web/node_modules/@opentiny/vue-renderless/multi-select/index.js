import "../chunk-G2ADBYYC.js";
import { cloneDeep } from "../chart-core/deps/utils";
const created = ({ props, state, refs, nextTick }) => () => {
  nextTick(() => {
    state.dataSource = cloneDeep(props.dataSource);
    state.defaultSelectedArray = cloneDeep(props.defaultSelectedArray);
    state.labelLevelsInfo = getLabelLevelsInfo(refs);
    state.labelsStyle = getLabelsStyle(state);
    state.headerInfo = state.dataSource.map((item) => {
      return { isSelected: false, title: item.title, isUP: false };
    });
  });
};
const handleClick = ({ api, props, state }) => (value) => {
  var _a, _b, _c;
  state.wheelData = (_a = props.dataSource[value]) == null ? void 0 : _a.children;
  if (state.headerIndex === -1) {
    state.showWheel = true;
    state.headerIndex = value;
    state.headerInfo[value] = getNewHeaderInfo(state.headerInfo, value, true);
    state.defaultSelectedIndexs = (_b = state.defaultSelectedArray[value]) != null ? _b : api.loadDefault(value);
  } else if (state.headerIndex !== value) {
    state.showWheel = true;
    state.headerInfo[state.headerIndex] = getNewHeaderInfo(state.headerInfo, state.headerIndex, false);
    state.headerIndex = value;
    state.headerInfo[value] = getNewHeaderInfo(state.headerInfo, value, true);
    state.defaultSelectedIndexs = (_c = state.defaultSelectedArray[value]) != null ? _c : api.loadDefault(value);
  } else {
    state.showWheel = !state.showWheel;
    const { isUP } = state.headerInfo[value];
    state.headerInfo[value] = getNewHeaderInfo(state.headerInfo, value, !isUP);
  }
};
const confirm = ({ state, emit }) => () => {
  const wheelLevelItems = getWheelLevelItems(state.wheelData, state.defaultSelectedIndexs);
  const { selectedLabels, selectedItems } = getSelected(wheelLevelItems, state.defaultSelectedIndexs);
  state.headerInfo[state.headerIndex] = { isSelected: true, title: selectedLabels, isUP: false };
  state.defaultSelectedArray[state.headerIndex] = state.defaultSelectedIndexs;
  emit("confirm", selectedItems, state.headerIndex, state.defaultSelectedIndexs);
  state.showWheel = false;
};
const reset = ({ api, props, state, emit }) => () => {
  var _a;
  state.headerInfo[state.headerIndex] = { isSelected: false, title: "", isUP: false };
  state.defaultSelectedIndexs = (_a = props.defaultSelectedArray[state.headerIndex]) != null ? _a : api.loadDefault(state.headerIndex);
  state.defaultSelectedArray[state.headerIndex] = state.defaultSelectedIndexs;
  emit("reset", [], state.headerIndex, state.defaultSelectedIndexs);
  state.showWheel = false;
};
const wheelChange = (state) => (indexs) => {
  state.defaultSelectedIndexs = indexs;
};
const clickWheelItem = ({ state, emit }) => (indexs, text, item) => {
  if (indexs.length === 0) {
    state.defaultSelectedIndexs = [-1];
    state.headerInfo[state.headerIndex] = { isSelected: false, title: "", isUP: false };
  } else {
    state.defaultSelectedIndexs = indexs;
    state.headerInfo[state.headerIndex] = { isSelected: true, title: text, isUP: false };
  }
  state.defaultSelectedArray[state.headerIndex] = state.defaultSelectedIndexs;
  emit("confirm", item, state.headerIndex, indexs);
  state.showWheel = false;
};
const getWheelLevelItems = (wheelData, newIndexs) => {
  const level_1 = wheelData;
  const level_n = getNextLevel([], wheelData, newIndexs, 0);
  let wheelLevelItems = [];
  if (level_n.length === 0) {
    wheelLevelItems = [level_1];
  } else {
    wheelLevelItems = [level_1, ...level_n];
  }
  return wheelLevelItems;
};
const getNextLevel = (levelItems, children, nextIndexs, start) => {
  var _a, _b;
  let levelItem = (_b = (_a = children[nextIndexs[start]]) == null ? void 0 : _a.children) != null ? _b : [];
  if (start !== nextIndexs.length - 1) {
    levelItems.push(levelItem);
    return getNextLevel(levelItems, levelItem, nextIndexs, ++start);
  } else {
    return levelItems;
  }
};
const getSelected = (wheelLevelItems, selectedIndexs) => {
  const selectedItems = [];
  wheelLevelItems.forEach((levelItem, i) => {
    const index = selectedIndexs[i];
    if (levelItem[index]) {
      selectedItems.push(levelItem[index]);
    }
  });
  const selectedLabels = selectedItems.map((item) => item == null ? void 0 : item.label).join(" ");
  return { selectedLabels, selectedItems };
};
const loadDefault = ({ props, state }) => (value) => {
  var _a, _b;
  const current = (_a = props.defaultSelectedArray[value]) != null ? _a : [];
  let defaultSelectedIndexs = [];
  if ((_b = state.dataSource[state.headerIndex]) == null ? void 0 : _b.hasFooter) {
    const defaultL = current.length;
    const dataSL = getMaxFloor(state.wheelData);
    if (defaultL <= dataSL) {
      defaultSelectedIndexs = current.concat(new Array(dataSL - defaultL).fill(0));
    } else {
      defaultSelectedIndexs = current.slice(0, dataSL);
    }
  } else {
    defaultSelectedIndexs = current.length > 0 ? current : [-1];
  }
  return defaultSelectedIndexs;
};
const getMaxFloor = (treeData) => {
  let maxFloor = 0;
  const loop = (data, level) => {
    data.forEach((item) => {
      var _a;
      item.level = level;
      if (level > maxFloor) {
        maxFloor = level;
      }
      if (((_a = item == null ? void 0 : item.children) == null ? void 0 : _a.length) > 0) {
        loop(item.children, level + 1);
      }
    });
  };
  loop(treeData, 1);
  return maxFloor;
};
const getNewHeaderInfo = (headerInfo, index, isUP) => {
  var _a, _b;
  return { isSelected: (_a = headerInfo[index]) == null ? void 0 : _a.isSelected, title: (_b = headerInfo[index]) == null ? void 0 : _b.title, isUP };
};
const getLabelLevelsInfo = (refs) => {
  const { headerBox, label } = refs;
  if (!headerBox || !label)
    return [];
  const totalWidth = getRect(getEl(headerBox)).width;
  const labelWidth = label.map((node) => getRect(getEl(node))).map((rect) => rect.width);
  return labelWidth.map((labelWidth2, idx) => {
    const isOver25 = totalWidth * 0.25 < labelWidth2;
    return {
      idx,
      labelWidth: labelWidth2,
      totalWidth,
      isOver25
    };
  });
};
const getRect = (el) => {
  return {
    top: el.offsetTop,
    left: el.offsetLeft,
    width: el.offsetWidth,
    height: el.offsetHeight
  };
};
const getEl = (node) => {
  return node.$el || node;
};
const getLabelsStyle = (state) => {
  const over25Labels = state.labelLevelsInfo.filter((i) => i && !i.isOver25);
  let widthInfo = over25Labels;
  const len = state.dataSource.length;
  if (len >= 4) {
    return getStyleConfig(state.labelLevelsInfo, { width: `${(1 / len * 100).toFixed(2)}%` });
  }
  if (!widthInfo.length || widthInfo.length === state.labelLevelsInfo.length) {
    return getStyleConfig(state.labelLevelsInfo, { maxWidth: `${(1 / len * 100).toFixed(2)}%` });
  }
  let fillArr;
  if (widthInfo.length === 1) {
    fillArr = getFillArray(state, widthInfo, "37.5%");
  } else if (widthInfo.length === 2) {
    fillArr = getFillArray(state, widthInfo, "50%");
  }
  widthInfo = widthInfo.concat(fillArr);
  return widthInfo.reduce((styles, item) => {
    styles[item.idx] = item.maxWidth ? { maxWidth: item.maxWidth } : { maxWidth: "25%" };
    return styles;
  }, {});
};
const getStyleConfig = (data, style) => {
  return data.reduce((styleConfig, _, idx) => {
    styleConfig[idx] = style;
    return styleConfig;
  }, {});
};
const getFillArray = (state, widthInfo, maxWidth) => {
  const labelIndexArr = state.labelLevelsInfo.map((_, idx) => idx);
  const mapWidthInfoArr = widthInfo.map((i) => i.idx);
  return labelIndexArr.filter((i) => !mapWidthInfoArr.includes(i)).map((i) => {
    return {
      idx: i,
      maxWidth
    };
  });
};
export {
  clickWheelItem,
  confirm,
  created,
  getEl,
  getFillArray,
  getLabelLevelsInfo,
  getLabelsStyle,
  getMaxFloor,
  getNewHeaderInfo,
  getNextLevel,
  getRect,
  getSelected,
  getStyleConfig,
  getWheelLevelItems,
  handleClick,
  loadDefault,
  reset,
  wheelChange
};
