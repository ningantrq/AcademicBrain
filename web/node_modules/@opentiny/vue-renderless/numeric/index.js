import {
  __spreadProps,
  __spreadValues
} from "../chunk-G2ADBYYC.js";
import { formatNumber, roundFixed } from "../common/decimal";
import { getMiniDecimal, lessEquals, equalsDecimal } from "../common/bigInt";
import { isNumber, isNull } from "../common/type";
import { MOUSEDELTA } from "../common";
import { on, off } from "../common/deps/dom";
const initService = (service) => {
  const { utils = {} } = service || {};
  const noopFn = () => null;
  return {
    getUnitPrecision: utils.getUnitPrecision || noopFn,
    getNumberFormat: utils.getNumberFormat || noopFn
  };
};
const getDecimal = (props) => (value) => getMiniDecimal(value, props.plugin);
const watchValue = ({ api, state, nextTick }) => (value) => {
  if (value === state.currentValue) {
    return;
  }
  api.setCurrentValue(value);
  nextTick(() => {
    api.dispatchDisplayedValue();
  });
};
const toPrecision = (state) => ({ num, precision }) => {
  if (precision === void 0) {
    precision = state.numPrecision;
  }
  return parseFloat(Math.round(num * 10 ** precision) / 10 ** precision);
};
const getPrecision = () => (value) => {
  if (value === void 0) {
    return 0;
  }
  const valueString = value.toString();
  const dotPosition = valueString.indexOf(".");
  let precision = 0;
  if (dotPosition !== -1) {
    precision = valueString.length - dotPosition - 1;
  }
  return precision;
};
const internalIncrease = ({ api, state }) => ({ val, step }) => {
  const decimal = api.getDecimal(val);
  if (decimal.isNaN() && val !== void 0) {
    return state.currentValue;
  }
  return decimal.add(step).toString();
};
const internalDecrease = ({ api, state }) => ({ val, step }) => {
  const decimal = api.getDecimal(val);
  if (decimal.isNaN() && val !== void 0) {
    return state.currentValue;
  }
  return decimal.add(`-${step}`).toString();
};
const increase = ({ api, props, state }) => () => {
  if (state.inputDisabled || state.maxDisabled) {
    return;
  }
  const value = (props.mouseWheel ? state.displayValue : props.modelValue) || 0;
  if (value.toString().includes("e")) {
    return;
  }
  let newVal = api.internalIncrease({ val: value, step: props.step });
  if (!props.circulate || !isFinite(props.max) || !isFinite(props.min)) {
    api.setCurrentValue(newVal);
    return;
  }
  if (!lessEquals(newVal, props.max) || lessEquals(newVal, props.min)) {
    newVal = props.min;
  }
  api.setCurrentValue(newVal);
};
const decrease = ({ api, props, state }) => () => {
  if (state.inputDisabled || state.minDisabled) {
    return;
  }
  const value = (props.mouseWheel ? state.displayValue : props.modelValue) || 0;
  if (value.toString().includes("e")) {
    return;
  }
  let newVal = api.internalDecrease({ val: value, step: props.step });
  if (!props.circulate || !isFinite(props.max) || !isFinite(props.min)) {
    api.setCurrentValue(newVal);
    return;
  }
  if (!lessEquals(props.min, newVal) || lessEquals(props.max, newVal)) {
    newVal = props.max;
  }
  api.setCurrentValue(newVal);
};
const handleBlur = ({
  constants,
  dispatch,
  emit,
  props,
  state,
  api
}) => (event) => {
  state.inputStatus = false;
  api.setCurrentValue(event.target.value);
  emit("blur", event);
  if (props.validateEvent) {
    dispatch(constants.COMPONENT_NAME, constants.EVENT_NAME.blur, [state.displayValue]);
  }
};
const handleFocus = ({ emit, state, props, api, refs }) => (event) => {
  if (props.disabled) {
    refs.input.blur();
  }
  state.inputStatus = true;
  const currentValue = api.getDecimal(state.currentValue);
  if (!currentValue.isNaN() && !isNull(state.currentValue)) {
    const fractionLen = (currentValue.toString().split(".")[1] || "").length;
    if (fractionLen < state.format.fraction && props.holdZero) {
      state.currentValue = formatNumber(state.currentValue, {
        fraction: state.format.fraction
      });
      state.userInput = state.currentValue;
      state.lastInput = state.currentValue;
    }
  }
  emit("focus", event);
};
const focus = (refs) => () => {
  refs.input.focus();
};
const getEmitValue = (args) => {
  let { newVal, emitValue, allowEmpty, defaultVal, bigNew, oldVal } = args;
  let { max, min, api, props, format, plugin, stringMode } = args;
  if (!newVal && newVal !== 0) {
    emitValue = allowEmpty ? void 0 : defaultVal;
  } else if (bigNew.isNaN()) {
    emitValue = oldVal;
  } else {
    if (isFinite(max) && lessEquals(max, newVal)) {
      newVal = max;
    }
    if (isFinite(min) && lessEquals(newVal, min)) {
      newVal = min;
    }
    emitValue = api.getDecimal(newVal).toString();
    if (props.modelTruncation) {
      emitValue = roundFixed(emitValue, format.fraction, format.rounding, plugin);
    }
    if (!props.holdZero) {
      emitValue = api.getDecimal(emitValue).toString();
    }
    if (!stringMode) {
      emitValue = Number(emitValue);
    }
  }
  return { newVal, emitValue };
};
const setCurrentValue = ({
  api,
  constants,
  dispatch,
  emit,
  props,
  state
}) => (newVal) => {
  const { max, min, allowEmpty, validateEvent, stringMode, plugin } = props;
  const { format } = state;
  const oldVal = state.currentValue;
  const bigNew = api.getDecimal(newVal);
  const defaultVal = isFinite(min) ? min : 0;
  let emitValue = bigNew.toString();
  if (equalsDecimal(state.currentValue, newVal)) {
    state.userInput = state.currentValue;
    return;
  }
  let args = { newVal, emitValue, allowEmpty, defaultVal, bigNew, oldVal };
  Object.assign(args, { max, min, api, props, format, plugin, stringMode });
  let ret = getEmitValue(args);
  newVal = ret.newVal;
  emitValue = ret.emitValue;
  state.userInput = emitValue;
  state.lastInput = emitValue;
  if (emitValue !== oldVal) {
    emit("update:modelValue", emitValue);
    emit("change", emitValue, oldVal);
    state.currentValue = emitValue;
    state.userInput = emitValue;
    if (validateEvent && oldVal === "") {
      dispatch(constants.COMPONENT_NAME, constants.EVENT_NAME.blur, [state.currentValue]);
    }
    if (validateEvent) {
      dispatch(constants.COMPONENT_NAME, constants.EVENT_NAME.change, [state.currentValue]);
    }
  }
};
const handleInput = ({ state, api, emit, props }) => (event) => {
  const { fraction } = state.format;
  const emitError = () => {
    if (state.pasting) {
      emit("paste-error", event.target.value);
    }
  };
  let value = event.target.value.replace(/^-+/, "-");
  if (value !== "-" && api.getDecimal(value).isNaN()) {
    emitError();
    if (!(value === "" && props.allowEmpty)) {
      value = !value.includes("e") ? state.lastInput : value;
    }
  } else {
    value = value.split(".").map((a, i) => {
      if (i && a.length > fraction) {
        emitError();
      }
      return i && state.strictInput && typeof fraction === "number" ? a.substr(0, fraction) : a;
    }).join(".");
  }
  event.target.value = isNull(value) ? "" : value;
  state.lastInput = value;
  state.userInput = value;
};
const handleInputChange = ({ api, state, props }) => (event) => {
  var _a, _b;
  const value = ((_a = event.target) == null ? void 0 : _a.value) === "-" ? 0 : (_b = event.target) == null ? void 0 : _b.value;
  if (props.stepStrictly) {
    const previousValue = Number((props.mouseWheel ? state.displayValue : props.modelValue) || 0);
    if (Math.abs(previousValue - value) % Number(props.step) === 0)
      return api.setCurrentValue(value);
    const step = Number(props.step);
    const difference = value - previousValue;
    const sign = difference >= 0 ? 1 : -1;
    return api.setCurrentValue(sign * Math.round(Math.abs(difference) / step) * step + previousValue);
  }
  api.setCurrentValue(value);
};
const select = (refs) => () => refs.input.select();
const mounted = ({ constants, parent, props, state }) => () => {
  const innerInput = parent.$el.querySelector("input");
  innerInput.setAttribute(constants.KEY, constants.VALUE);
  innerInput.setAttribute(constants.MAX, props.max);
  innerInput.setAttribute(constants.MIN, props.min);
  innerInput.setAttribute(constants.VALUENOW, state.currentValue);
  innerInput.setAttribute(constants.DISABLED, state.inputDisabled);
  state.onPase = () => {
    state.pasting = true;
    setTimeout(() => state.pasting = false);
  };
  on(innerInput, "paste", state.onPase);
};
const unmounted = ({ parent, state }) => () => {
  const innerInput = parent.$el.querySelector("input");
  off(innerInput, "paste", state.onPase);
};
const updated = ({ constants, parent, state }) => () => {
  const innerInput = parent.$el.querySelector("input");
  innerInput && innerInput.setAttribute(constants.VALUENOW, state.currentValue);
};
const displayValue = ({ props, state }) => () => {
  const { currentValue, inputStatus, userInput } = state;
  if (inputStatus) {
    return userInput;
  }
  if (props.allowEmpty && currentValue === "") {
    return "";
  }
  return formatNumber(currentValue, state.format);
};
const getNumPecision = ({ api, props }) => () => {
  const stepPrecision = api.getPrecision(props.step);
  if (props.precision !== void 0) {
    return props.precision;
  } else {
    return Math.max(api.getPrecision(props.modelValue), stepPrecision);
  }
};
const mouseEvent = ({ api, props, state }) => (event) => {
  if (props.mouseWheel && state.inputStatus) {
    let delta = 0;
    if (event.wheelDelta) {
      delta = event.wheelDelta / MOUSEDELTA;
    }
    delta > 0 ? api.increase() : api.decrease();
    return false;
  }
};
const getUnitPrecision = ({
  service,
  props
}) => {
  let fraction, rounding;
  const { format = {}, precision, unit } = props;
  const defaultFmt = {
    groupSeparator: "",
    decimalSeparator: ".",
    zeroize: props.holdZero
  };
  const { getUnitPrecision: getUnitPrecision2, getNumberFormat } = service;
  const serFra = getUnitPrecision2(unit) || {};
  const serFmt = getNumberFormat() || {};
  fraction = isNumber(precision) ? precision : isNumber(format.fraction) ? format.fraction : serFra.fraction;
  rounding = isNumber(format.rounding) ? format.rounding : serFra.rounding;
  return __spreadValues(__spreadValues(__spreadProps(__spreadValues({}, defaultFmt), { fraction, rounding }), serFmt), format);
};
const dispatchDisplayedValue = ({ state, api, dispatch }) => () => {
  if (state.isDisplayOnly) {
    dispatch("FormItem", "displayed-value-changed", { type: "numeric", val: api.getDisplayedValue() });
  }
};
const getDisplayedValue = ({ state, props }) => () => {
  return state.displayValue || state.displayValue === 0 ? state.displayValue + " " + (props.unit || "") : "-";
};
const getDisplayOnlyText = ({ parent, state, props }) => () => {
  const showEmptyValue = props.showEmptyValue || (parent.tinyForm || {}).showEmptyValue;
  if (showEmptyValue) {
    return state.displayValue;
  } else {
    if (state.displayValue || state.displayValue === 0) {
      return state.displayValue;
    } else {
      return "-";
    }
  }
};
export {
  decrease,
  dispatchDisplayedValue,
  displayValue,
  focus,
  getDecimal,
  getDisplayOnlyText,
  getDisplayedValue,
  getNumPecision,
  getPrecision,
  getUnitPrecision,
  handleBlur,
  handleFocus,
  handleInput,
  handleInputChange,
  increase,
  initService,
  internalDecrease,
  internalIncrease,
  mounted,
  mouseEvent,
  select,
  setCurrentValue,
  toPrecision,
  unmounted,
  updated,
  watchValue
};
