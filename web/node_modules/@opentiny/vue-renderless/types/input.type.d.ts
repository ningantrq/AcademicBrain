import { ComputedRef, ExtractPropTypes } from 'vue';
import { PropType } from '@opentiny/vue-common';
import { ISharedRenderlessParamUtils, ISharedRenderlessFunctionParams } from './shared.type.js';

declare const $constants: {
    INPUT_PC: string;
    INPUTGROUP_PC: string;
    INPUT_MOBILE: string;
    INPUTGROUP_MOBILE: string;
    Mode: string;
    inputMode(mode: any): any;
    inputGroupMode(mode: any): any;
    VALIDATE_ICON: {
        Validating: string;
        Success: string;
        Error: string;
    };
    COMPONENT_NAME: {
        FormItem: string;
    };
    MASKSYMBOL: string;
};
declare const inputProps: {
    _constants: {
        type: ObjectConstructor;
        default: () => {
            INPUT_PC: string;
            INPUTGROUP_PC: string;
            INPUT_MOBILE: string;
            INPUTGROUP_MOBILE: string;
            Mode: string;
            inputMode(mode: any): any;
            inputGroupMode(mode: any): any;
            VALIDATE_ICON: {
                Validating: string;
                Success: string;
                Error: string;
            };
            COMPONENT_NAME: {
                FormItem: string;
            };
            MASKSYMBOL: string;
        };
    };
    name: StringConstructor;
    size: StringConstructor;
    form: StringConstructor;
    label: StringConstructor;
    height: NumberConstructor;
    resize: StringConstructor;
    tabindex: {
        type: StringConstructor;
        default: string;
    };
    disabled: BooleanConstructor;
    readonly: BooleanConstructor;
    hoverExpand: BooleanConstructor;
    mask: BooleanConstructor;
    suffixIcon: (StringConstructor | ObjectConstructor)[];
    prefixIcon: (StringConstructor | ObjectConstructor)[];
    modelValue: PropType<string | number | null>;
    type: {
        type: StringConstructor;
        default: string;
    };
    memorySpace: {
        type: NumberConstructor;
        default: number;
    };
    vertical: {
        type: BooleanConstructor;
        default: boolean;
    };
    selectMenu: {
        type: {
            (arrayLength: number): {
                id: string;
                label: string;
            }[];
            (...items: {
                id: string;
                label: string;
            }[]): {
                id: string;
                label: string;
            }[];
            new (arrayLength: number): {
                id: string;
                label: string;
            }[];
            new (...items: {
                id: string;
                label: string;
            }[]): {
                id: string;
                label: string;
            }[];
            isArray(arg: any): arg is any[];
            readonly prototype: any[];
            from<T>(arrayLike: ArrayLike<T>): T[];
            from<T_1, U>(arrayLike: ArrayLike<T_1>, mapfn: (v: T_1, k: number) => U, thisArg?: any): U[];
            from<T_2>(iterable: Iterable<T_2> | ArrayLike<T_2>): T_2[];
            from<T_3, U_1>(iterable: Iterable<T_3> | ArrayLike<T_3>, mapfn: (v: T_3, k: number) => U_1, thisArg?: any): U_1[];
            of<T_4>(...items: T_4[]): T_4[];
            readonly [Symbol.species]: ArrayConstructor;
        };
        default: () => never[];
    };
    ellipsis: {
        type: BooleanConstructor;
        default: boolean;
    };
    contentStyle: {
        type: ObjectConstructor;
        default: () => {};
    };
    isSelect: {
        type: BooleanConstructor;
        default: boolean;
    };
    tips: StringConstructor;
    counter: {
        type: BooleanConstructor;
        default: boolean;
    };
    autosize: {
        type: (BooleanConstructor | ObjectConstructor)[];
        default: boolean;
    };
    clearable: {
        type: BooleanConstructor;
        default: boolean;
    };
    autocomplete: {
        type: StringConstructor;
        default: string;
    };
    showPassword: {
        type: BooleanConstructor;
        default: boolean;
    };
    showWordLimit: {
        type: BooleanConstructor;
        default: boolean;
    };
    showTitle: {
        type: BooleanConstructor;
        default: boolean;
    };
    validateEvent: {
        type: BooleanConstructor;
        default: boolean;
    };
    textareaTitle: {
        type: StringConstructor;
        default: string;
    };
    displayOnly: {
        type: BooleanConstructor;
        default: boolean;
    };
    displayOnlyContent: {
        type: StringConstructor;
        default: string;
    };
    customClass: {
        type: StringConstructor;
        default: string;
    };
    frontClearIcon: {
        type: BooleanConstructor;
        default: boolean;
    };
    showEmptyValue: {
        type: BooleanConstructor;
        default: boolean;
    };
    textAlign: {
        type: StringConstructor;
        default: string;
    };
    width: {
        type: PropType<string | number | null>;
    };
    tiny_mode: StringConstructor;
    tiny_mode_root: BooleanConstructor;
    tiny_template: (FunctionConstructor | ObjectConstructor)[];
    tiny_renderless: FunctionConstructor;
    tiny_theme: StringConstructor;
    tiny_chart_theme: ObjectConstructor;
};

/**
 * Copyright (c) 2022 - present TinyVue Authors.
 * Copyright (c) 2022 - present Huawei Cloud Computing Technologies Co., Ltd.
 *
 * Use of this source code is governed by an MIT-style license.
 *
 * THE OPEN SOURCE SOFTWARE IN THIS PRODUCT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 * A PARTICULAR PURPOSE. SEE THE APPLICABLE LICENSES FOR MORE DETAILS.
 *
 */
declare const _default: ({ api, props, reactive, toRefs }: {
    api: any;
    props: any;
    reactive: any;
    toRefs: any;
}) => any;

/**
 * Copyright (c) 2022 - present TinyVue Authors.
 * Copyright (c) 2022 - present Huawei Cloud Computing Technologies Co., Ltd.
 *
 * Use of this source code is governed by an MIT-style license.
 *
 * THE OPEN SOURCE SOFTWARE IN THIS PRODUCT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
 * BUT WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 * A PARTICULAR PURPOSE. SEE THE APPLICABLE LICENSES FOR MORE DETAILS.
 *
 */

declare const inputStyle: ({ props }: {
    props: any;
}) => () => {
    textAlign: any;
};
declare const calculateNodeStyling: () => (targetElement: HTMLElement) => {
    contextStyle: string;
    paddingSize: number;
    borderSize: number;
    boxSizing: string;
};
declare const calcTextareaHeight: ({ api, hiddenTextarea, props, state }: Pick<IInputRenderlessParams, "state" | "api" | "props"> & {
    hiddenTextarea: HTMLTextAreaElement | null;
}) => (targetElement: HTMLTextAreaElement, minRows?: number, maxRows?: null) => {
    minHeight?: string | undefined;
    height?: string | undefined;
};
declare const getInput: (vm: IInputRenderlessParamUtils['vm']) => () => HTMLTextAreaElement | HTMLInputElement;
declare const focus: (api: IInputApi) => () => void;
declare const handleInput: ({ api, emit, nextTick, state }: Pick<IInputRenderlessParams, 'api' | 'emit' | 'nextTick' | 'state'>) => (event: Event) => void;
declare const resizeTextarea: ({ api, parent, refs, state }: Pick<IInputRenderlessParams, 'api' | 'parent' | 'refs' | 'state'>) => () => void;
declare const setNativeInputValue: ({ api, state }: Pick<IInputRenderlessParams, 'api' | 'state'>) => () => void;
declare const calcIconOffset: ({ CLASS_PREFIX, parent }: Pick<IInputRenderlessParams, "parent"> & {
    CLASS_PREFIX: IInputClassPrefixConstants;
}) => (place: 'prefix' | 'suffix') => void;
declare const updateIconOffset: (api: IInputApi) => () => void;
declare const watchFormSelect: ({ emit, props, state }: Pick<IInputRenderlessParams, 'emit' | 'props' | 'state'>) => (value: string | number | undefined) => void;
declare const hiddenPassword: ({ state, props }: Pick<IInputRenderlessParams, 'state' | 'props'>) => () => string;
declare const dispatchDisplayedValue: ({ state, props, dispatch, api }: Pick<IInputRenderlessParams, 'state' | 'props' | 'dispatch' | 'api'>) => () => void;
declare const getDisplayedValue: ({ state, props }: Pick<IInputRenderlessParams, 'state' | 'props'>) => () => string;

interface IInputState {
    mode: string;
    focused: boolean;
    hovering: boolean;
    isComposing: boolean;
    passwordVisible: boolean;
    boxVisibility: boolean;
    textareaCalcStyle: object;
    checkedLabel: string;
    width: string;
    sheetvalue: string | number | undefined;
    inputSize: ComputedRef<string>;
    showClear: ComputedRef<boolean>;
    upperLimit: ComputedRef<string>;
    textLength: ComputedRef<string>;
    inputExceed: ComputedRef<boolean>;
    formItemSize: ComputedRef<string>;
    validateIcon: ComputedRef<typeof $constants.VALIDATE_ICON | null>;
    showWordLimit: ComputedRef<boolean>;
    inputDisabled: ComputedRef<boolean>;
    validateState: ComputedRef<string>;
    textareaStyle: ComputedRef<object>;
    needStatusIcon: ComputedRef<boolean>;
    showPwdVisible: ComputedRef<boolean>;
    nativeInputValue: ComputedRef<string>;
    isWordLimitVisible: ComputedRef<boolean>;
    isDisplayOnly: ComputedRef<boolean>;
    displayOnlyTooltip: string;
    hiddenPassword: ComputedRef<string>;
}
type IInputRenderlessParamUtils = ISharedRenderlessParamUtils<IInputConstants>;
type IInputProps = ExtractPropTypes<typeof inputProps>;
type IInputConstants = typeof $constants;
interface IInputApi extends Pick<IInputRenderlessParamUtils, 'dispatch'> {
    state: IInputState;
    isMemoryStorage: ReturnType<typeof _default>['isMemoryStorage'];
    searchMemory: ReturnType<typeof _default>['searchMemory'];
    setNativeInputValue: ReturnType<typeof setNativeInputValue>;
    resizeTextarea: ReturnType<typeof resizeTextarea>;
    updateIconOffset: ReturnType<typeof updateIconOffset>;
    dispatchDisplayedValue: ReturnType<typeof dispatchDisplayedValue>;
    hiddenPassword: ReturnType<typeof hiddenPassword>;
    watchFormSelect: ReturnType<typeof watchFormSelect>;
    getInput: ReturnType<typeof getInput>;
    calcTextareaHeight: ReturnType<typeof calcTextareaHeight>;
    calculateNodeStyling: ReturnType<typeof calculateNodeStyling>;
    handleInput: ReturnType<typeof handleInput>;
    calcIconOffset: ReturnType<typeof calcIconOffset>;
    focus: ReturnType<typeof focus>;
    getDisplayedValue: ReturnType<typeof getDisplayedValue>;
    inputStyle: ReturnType<typeof inputStyle>;
}
type IInputRenderlessParams = ISharedRenderlessFunctionParams<IInputConstants> & {
    state: IInputState;
    props: IInputProps;
    api: IInputApi;
};
interface IInputClassPrefixConstants {
    Input: string;
    InputGroup: string;
}
interface IInputEventNameConstants {
    change: string;
    blur: string;
}

export { IInputApi, IInputClassPrefixConstants, IInputConstants, IInputEventNameConstants, IInputProps, IInputRenderlessParamUtils, IInputRenderlessParams, IInputState };
