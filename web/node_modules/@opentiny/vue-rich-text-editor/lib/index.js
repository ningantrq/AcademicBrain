var _excluded = ["start"];
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn2) {
  try {
    return Function.toString.call(fn2).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn2 === "function";
  }
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _toPrimitive(t, r2) {
  if ("object" != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
import { renderless, api } from "@opentiny/vue-renderless/rich-text-edtior/vue";
import { defineComponent, ref, onMounted, onBeforeUnmount, h, reactive, markRaw, getCurrentInstance, watchEffect, nextTick, unref, Teleport, customRef, provide, resolveComponent, openBlock, createBlock, withCtx, withDirectives, createElementVNode, createElementBlock, Fragment as Fragment$1, renderList, toDisplayString, vModelSelect, createVNode, resolveDirective, withModifiers, normalizeClass, createCommentVNode, resolveDynamicComponent, renderSlot } from "vue";
import { defineComponent as defineComponent$1, $prefix, directive, setup as _setup, $props } from "@opentiny/vue-common";
function _createForOfIteratorHelperLoose_tiny(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray_tiny(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray_tiny(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray_tiny(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray_tiny(o, minLen);
}
function _arrayLikeToArray_tiny(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var _export_sfc = function _export_sfc2(sfc, props) {
  var target = sfc.__vccOpts || sfc;
  for (var _iterator = _createForOfIteratorHelperLoose_tiny(props), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, key = _step$value[0], val = _step$value[1];
    target[key] = val;
  }
  return target;
};

import { iconRichTextAddColumnAfter, iconRichTextAddColumnBefore, iconRichTextAddRowAfter, iconRichTextAddRowBefore, iconRichTextAlignCenter, iconRichTextAlignLeft, iconRichTextAlignRight, iconRichTextBold, iconRichTextCodeBlock, iconRichTextCodeView, IconEditorTextcolor, IconEditorBackground, iconRichTextDeleteColumn, iconRichTextDeleteRow, iconRichTextDeleteTable, iconRichTextFontSize, iconRichTextFormatClear, iconRichTextH1, iconRichTextH2, iconRichTextH3, iconRichTextH4, iconRichTextH5, iconRichTextH6, iconRichTextHeading, iconRichTextHighLight, iconRichTextItalic, IconRichTextImage, iconRichTextLineHeight, iconRichTextLink, iconRichTextLinkUnlink, iconRichTextListOrdered, iconRichTextListUnordered, iconRichTextMergeCells, iconRichTextMergeCellsVertical, iconRichTextNodeDelete, iconRichTextParagraph, iconRichTextQuoteText, iconRichTextRedo, iconRichTextSplitCellsHorizontal, iconRichTextSplitCellsVertical, iconRichTextStrikeThrough, iconRichTextSubscript, iconRichTextSuperscript, iconRichTextTable, iconRichTextTaskList, iconRichTextUnderline, iconRichTextUndo } from "@opentiny/vue-icon";
import "@opentiny/vue-theme/rich-text-editor/index.css";
import Clickoutside from "@opentiny/vue-renderless/common/deps/clickoutside";
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function OrderedMap(content5) {
  this.content = content5;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function find(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function get(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function update(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content5 = self.content.slice();
    if (found2 == -1) {
      content5.push(newKey || key, value);
    } else {
      content5[found2 + 1] = value;
      if (newKey)
        content5[found2] = newKey;
    }
    return new OrderedMap(content5);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function remove(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content5 = this.content.slice();
    content5.splice(found2, 2);
    return new OrderedMap(content5);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function addToStart(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function addToEnd(key, value) {
    var content5 = this.remove(key).content.slice();
    content5.push(key, value);
    return new OrderedMap(content5);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function addBefore(place, key, value) {
    var without = this.remove(key), content5 = without.content.slice();
    var found2 = without.find(place);
    content5.splice(found2 == -1 ? content5.length : found2, 0, key, value);
    return new OrderedMap(content5);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function forEach(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function prepend(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size)
      return this;
    return new OrderedMap(map3.content.concat(this.subtract(map3).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function append(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size)
      return this;
    return new OrderedMap(this.subtract(map3).content.concat(map3.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function subtract(map3) {
    var result = this;
    map3 = OrderedMap.from(map3);
    for (var i = 0; i < map3.content.length; i += 2)
      result = result.remove(map3.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function toObject() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content5 = [];
  if (value)
    for (var prop in value)
      content5.push(prop, value[prop]);
  return new OrderedMap(content5);
};
function _findDiffStart(a, b, pos) {
  for (var _i2 = 0; ; _i2++) {
    if (_i2 == a.childCount || _i2 == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    var childA = a.child(_i2), childB = b.child(_i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = _findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function _findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment = /* @__PURE__ */ function() {
  function Fragment2(content5, size) {
    this.content = content5;
    this.size = size || 0;
    if (size == null)
      for (var _i3 = 0; _i3 < content5.length; _i3++)
        this.size += content5[_i3].nodeSize;
  }
  var _proto = Fragment2.prototype;
  _proto.nodesBetween = function nodesBetween(from2, to, f, nodeStart, parent) {
    if (nodeStart === void 0) {
      nodeStart = 0;
    }
    for (var _i4 = 0, pos = 0; pos < to; _i4++) {
      var child = this.content[_i4], _end = pos + child.nodeSize;
      if (_end > from2 && f(child, nodeStart + pos, parent || null, _i4) !== false && child.content.size) {
        var _start = pos + 1;
        child.nodesBetween(Math.max(0, from2 - _start), Math.min(child.content.size, to - _start), f, nodeStart + _start);
      }
      pos = _end;
    }
  };
  _proto.descendants = function descendants(f) {
    this.nodesBetween(0, this.size, f);
  };
  _proto.textBetween = function textBetween(from2, to, blockSeparator, leafText) {
    var text = "", first3 = true;
    this.nodesBetween(from2, to, function(node, pos) {
      var nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first3)
          first3 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  };
  _proto.append = function append3(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    var last = this.lastChild, first3 = other.firstChild, content5 = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first3)) {
      content5[content5.length - 1] = last.withText(last.text + first3.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content5.push(other.content[i]);
    return new Fragment2(content5, this.size + other.size);
  };
  _proto.cut = function cut3(from2, to) {
    if (to === void 0) {
      to = this.size;
    }
    if (from2 == 0 && to == this.size)
      return this;
    var result = [], size = 0;
    if (to > from2)
      for (var _i5 = 0, pos = 0; pos < to; _i5++) {
        var child = this.content[_i5], _end2 = pos + child.nodeSize;
        if (_end2 > from2) {
          if (pos < from2 || _end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = _end2;
      }
    return new Fragment2(result, size);
  };
  _proto.cutByIndex = function cutByIndex(from2, to) {
    if (from2 == to)
      return Fragment2.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new Fragment2(this.content.slice(from2, to));
  };
  _proto.replaceChild = function replaceChild(index, node) {
    var current = this.content[index];
    if (current == node)
      return this;
    var copy2 = this.content.slice();
    var size = this.size + node.nodeSize - current.nodeSize;
    copy2[index] = node;
    return new Fragment2(copy2, size);
  };
  _proto.addToStart = function addToStart2(node) {
    return new Fragment2([node].concat(this.content), this.size + node.nodeSize);
  };
  _proto.addToEnd = function addToEnd2(node) {
    return new Fragment2(this.content.concat(node), this.size + node.nodeSize);
  };
  _proto.eq = function eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (var _i6 = 0; _i6 < this.content.length; _i6++)
      if (!this.content[_i6].eq(other.content[_i6]))
        return false;
    return true;
  };
  _proto.child = function child(index) {
    var found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  };
  _proto.maybeChild = function maybeChild(index) {
    return this.content[index] || null;
  };
  _proto.forEach = function forEach5(f) {
    for (var _i7 = 0, p = 0; _i7 < this.content.length; _i7++) {
      var child = this.content[_i7];
      f(child, p, _i7);
      p += child.nodeSize;
    }
  };
  _proto.findDiffStart = function findDiffStart(other, pos) {
    if (pos === void 0) {
      pos = 0;
    }
    return _findDiffStart(this, other, pos);
  };
  _proto.findDiffEnd = function findDiffEnd(other, pos, otherPos) {
    if (pos === void 0) {
      pos = this.size;
    }
    if (otherPos === void 0) {
      otherPos = other.size;
    }
    return _findDiffEnd(this, other, pos, otherPos);
  };
  _proto.findIndex = function findIndex(pos, round2) {
    if (round2 === void 0) {
      round2 = -1;
    }
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
    for (var _i8 = 0, curPos = 0; ; _i8++) {
      var cur = this.child(_i8), _end3 = curPos + cur.nodeSize;
      if (_end3 >= pos) {
        if (_end3 == pos || round2 > 0)
          return retIndex(_i8 + 1, _end3);
        return retIndex(_i8, curPos);
      }
      curPos = _end3;
    }
  };
  _proto.toString = function toString2() {
    return "<" + this.toStringInner() + ">";
  };
  _proto.toStringInner = function toStringInner() {
    return this.content.join(", ");
  };
  _proto.toJSON = function toJSON() {
    return this.content.length ? this.content.map(function(n) {
      return n.toJSON();
    }) : null;
  };
  Fragment2.fromJSON = function fromJSON(schema, value) {
    if (!value)
      return Fragment2.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment2(value.map(schema.nodeFromJSON));
  };
  Fragment2.fromArray = function fromArray(array) {
    if (!array.length)
      return Fragment2.empty;
    var joined, size = 0;
    for (var _i9 = 0; _i9 < array.length; _i9++) {
      var node = array[_i9];
      size += node.nodeSize;
      if (_i9 && node.isText && array[_i9 - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, _i9);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment2(joined || array, size);
  };
  Fragment2.from = function from2(nodes) {
    if (!nodes)
      return Fragment2.empty;
    if (nodes instanceof Fragment2)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment2([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  };
  _createClass(Fragment2, [{
    key: "firstChild",
    get: function get5() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
  }, {
    key: "lastChild",
    get: function get5() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
  }, { key: "childCount", get: function get5() {
    return this.content.length;
  } }]);
  return Fragment2;
}();
Fragment.empty = new Fragment([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index, offset2) {
  found.index = index;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  var array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (var _i10 = 0; _i10 < a.length; _i10++)
      if (!compareDeep(a[_i10], b[_i10]))
        return false;
  } else {
    for (var p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (var _p2 in b)
      if (!(_p2 in a))
        return false;
  }
  return true;
}
var Mark$1 = /* @__PURE__ */ function() {
  function Mark2(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  var _proto2 = Mark2.prototype;
  _proto2.addToSet = function addToSet(set2) {
    var copy2, placed = false;
    for (var _i11 = 0; _i11 < set2.length; _i11++) {
      var _other = set2[_i11];
      if (this.eq(_other))
        return set2;
      if (this.type.excludes(_other.type)) {
        if (!copy2)
          copy2 = set2.slice(0, _i11);
      } else if (_other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && _other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set2.slice(0, _i11);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(_other);
      }
    }
    if (!copy2)
      copy2 = set2.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  };
  _proto2.removeFromSet = function removeFromSet(set2) {
    for (var _i12 = 0; _i12 < set2.length; _i12++)
      if (this.eq(set2[_i12]))
        return set2.slice(0, _i12).concat(set2.slice(_i12 + 1));
    return set2;
  };
  _proto2.isInSet = function isInSet(set2) {
    for (var _i13 = 0; _i13 < set2.length; _i13++)
      if (this.eq(set2[_i13]))
        return true;
    return false;
  };
  _proto2.eq = function eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  };
  _proto2.toJSON = function toJSON() {
    var obj = { type: this.type.name };
    for (var _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  };
  Mark2.fromJSON = function fromJSON(schema, json2) {
    if (!json2)
      throw new RangeError("Invalid input for Mark.fromJSON");
    var type = schema.marks[json2.type];
    if (!type)
      throw new RangeError("There is no mark type " + json2.type + " in this schema");
    return type.create(json2.attrs);
  };
  Mark2.sameSet = function sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (var _i14 = 0; _i14 < a.length; _i14++)
      if (!a[_i14].eq(b[_i14]))
        return false;
    return true;
  };
  Mark2.setFrom = function setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark2.none;
    if (marks instanceof Mark2)
      return [marks];
    var copy2 = marks.slice();
    copy2.sort(function(a, b) {
      return a.type.rank - b.type.rank;
    });
    return copy2;
  };
  return Mark2;
}();
Mark$1.none = [];
var ReplaceError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(ReplaceError2, _Error);
  function ReplaceError2() {
    return _Error.apply(this, arguments) || this;
  }
  return ReplaceError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var Slice = /* @__PURE__ */ function() {
  function Slice2(content5, openStart, openEnd) {
    this.content = content5;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  var _proto3 = Slice2.prototype;
  _proto3.insertAt = function insertAt(pos, fragment) {
    var content5 = insertInto(this.content, pos + this.openStart, fragment);
    return content5 && new Slice2(content5, this.openStart, this.openEnd);
  };
  _proto3.removeBetween = function removeBetween(from2, to) {
    return new Slice2(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  };
  _proto3.eq = function eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  };
  _proto3.toString = function toString2() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  };
  _proto3.toJSON = function toJSON() {
    if (!this.content.size)
      return null;
    var json2 = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json2.openStart = this.openStart;
    if (this.openEnd > 0)
      json2.openEnd = this.openEnd;
    return json2;
  };
  Slice2.fromJSON = function fromJSON(schema, json2) {
    if (!json2)
      return Slice2.empty;
    var openStart = json2.openStart || 0, openEnd = json2.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice2(Fragment.fromJSON(schema, json2.content), openStart, openEnd);
  };
  Slice2.maxOpen = function maxOpen(fragment, openIsolating) {
    if (openIsolating === void 0) {
      openIsolating = true;
    }
    var openStart = 0, openEnd = 0;
    for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild)
      openEnd++;
    return new Slice2(fragment, openStart, openEnd);
  };
  _createClass(Slice2, [{ key: "size", get: function get5() {
    return this.content.size - this.openStart - this.openEnd;
  } }]);
  return Slice2;
}();
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content5, from2, to) {
  var _content$findIndex = content5.findIndex(from2), index = _content$findIndex.index, offset2 = _content$findIndex.offset, child = content5.maybeChild(index);
  var _content$findIndex2 = content5.findIndex(to), indexTo = _content$findIndex2.index, offsetTo = _content$findIndex2.offset;
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content5.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content5.cut(0, from2).append(content5.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content5.replaceChild(index, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content5, dist, insert, parent) {
  var _content$findIndex3 = content5.findIndex(dist), index = _content$findIndex3.index, offset2 = _content$findIndex3.offset, child = content5.maybeChild(index);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert))
      return null;
    return content5.cut(0, dist).append(insert).append(content5.cut(dist));
  }
  var inner = insertInto(child.content, dist - offset2 - 1, insert);
  return inner && content5.replaceChild(index, child.copy(inner));
}
function _replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  var index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    var inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content5 = parent.content;
    return close(parent, content5.cut(0, $from.parentOffset).append(slice2.content).append(content5.cut($to.parentOffset)));
  } else {
    var _prepareSliceForRepla = prepareSliceForReplace(slice2, $from), _start2 = _prepareSliceForRepla.start, _end4 = _prepareSliceForRepla.end;
    return close(node, replaceThreeWay($from, _start2, _end4, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable$1($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (var _i15 = startIndex2; _i15 < endIndex2; _i15++)
    addNode(node.child(_i15), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content5) {
  node.type.checkContent(content5);
  return node.copy(content5);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  var content5 = [];
  addRange(null, $from, depth, content5);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content5);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content5);
    addRange($start, $end, depth, content5);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content5);
  }
  addRange($to, null, depth, content5);
  return new Fragment(content5);
}
function replaceTwoWay($from, $to, depth) {
  var content5 = [];
  addRange(null, $from, depth, content5);
  if ($from.depth > depth) {
    var type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content5);
  }
  addRange($to, null, depth, content5);
  return new Fragment(content5);
}
function prepareSliceForReplace(slice2, $along) {
  var extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  var node = parent.copy(slice2.content);
  for (var _i16 = extra - 1; _i16 >= 0; _i16--)
    node = $along.node(_i16).copy(Fragment.from(node));
  return { start: node.resolveNoCache(slice2.openStart + extra), end: node.resolveNoCache(node.content.size - slice2.openEnd - extra) };
}
var ResolvedPos = /* @__PURE__ */ function() {
  function ResolvedPos2(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  var _proto4 = ResolvedPos2.prototype;
  _proto4.resolveDepth = function resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  };
  _proto4.node = function node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  };
  _proto4.index = function index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  };
  _proto4.indexAfter = function indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  };
  _proto4.start = function start2(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  };
  _proto4.end = function end2(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  };
  _proto4.before = function before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  };
  _proto4.after = function after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  };
  _proto4.posAtIndex = function posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (var _i17 = 0; _i17 < index; _i17++)
      pos += node.child(_i17).nodeSize;
    return pos;
  };
  _proto4.marks = function marks() {
    var parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return parent.child(index).marks;
    var main2 = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main2) {
      var tmp = main2;
      main2 = other;
      other = tmp;
    }
    var marks2 = main2.marks;
    for (var i = 0; i < marks2.length; i++)
      if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks)))
        marks2 = marks2[i--].removeFromSet(marks2);
    return marks2;
  };
  _proto4.marksAcross = function marksAcross($end) {
    var after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    var marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  };
  _proto4.sharedDepth = function sharedDepth(pos) {
    for (var depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  };
  _proto4.blockRange = function blockRange(other, pred) {
    if (other === void 0) {
      other = this;
    }
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  };
  _proto4.sameParent = function sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  };
  _proto4.max = function max2(other) {
    return other.pos > this.pos ? other : this;
  };
  _proto4.min = function min2(other) {
    return other.pos < this.pos ? other : this;
  };
  _proto4.toString = function toString2() {
    var str = "";
    for (var _i18 = 1; _i18 <= this.depth; _i18++)
      str += (str ? "/" : "") + this.node(_i18).type.name + "_" + this.index(_i18 - 1);
    return str + ":" + this.parentOffset;
  };
  ResolvedPos2.resolve = function resolve2(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    var path = [];
    var start2 = 0, parentOffset = pos;
    for (var node = doc2; ; ) {
      var _node$content$findInd = node.content.findIndex(parentOffset), index = _node$content$findInd.index, _offset2 = _node$content$findInd.offset;
      var rem = parentOffset - _offset2;
      path.push(node, index, start2 + _offset2);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start2 += _offset2 + 1;
    }
    return new ResolvedPos2(pos, path, parentOffset);
  };
  ResolvedPos2.resolveCached = function resolveCached(doc2, pos) {
    for (var _i19 = 0; _i19 < resolveCache.length; _i19++) {
      var cached = resolveCache[_i19];
      if (cached.pos == pos && cached.doc == doc2)
        return cached;
    }
    var result = resolveCache[resolveCachePos] = ResolvedPos2.resolve(doc2, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  };
  _createClass(ResolvedPos2, [{
    key: "parent",
    get: function get5() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
  }, { key: "doc", get: function get5() {
    return this.node(0);
  } }, {
    key: "textOffset",
    get: function get5() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
  }, {
    key: "nodeAfter",
    get: function get5() {
      var parent = this.parent, index = this.index(this.depth);
      if (index == parent.childCount)
        return null;
      var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
  }, { key: "nodeBefore", get: function get5() {
    var index = this.index(this.depth);
    var dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  } }]);
  return ResolvedPos2;
}();
var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
var NodeRange = /* @__PURE__ */ function() {
  function NodeRange2($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  _createClass(NodeRange2, [{
    key: "start",
    get: function get5() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
  }, {
    key: "end",
    get: function get5() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
  }, {
    key: "parent",
    get: function get5() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
  }, {
    key: "startIndex",
    get: function get5() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
  }, { key: "endIndex", get: function get5() {
    return this.$to.indexAfter(this.depth);
  } }]);
  return NodeRange2;
}();
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node$1 = /* @__PURE__ */ function() {
  function Node2(type, attrs, content5, marks) {
    if (marks === void 0) {
      marks = Mark$1.none;
    }
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content5 || Fragment.empty;
  }
  var _proto5 = Node2.prototype;
  _proto5.child = function child(index) {
    return this.content.child(index);
  };
  _proto5.maybeChild = function maybeChild(index) {
    return this.content.maybeChild(index);
  };
  _proto5.forEach = function forEach5(f) {
    this.content.forEach(f);
  };
  _proto5.nodesBetween = function nodesBetween(from2, to, f, startPos) {
    if (startPos === void 0) {
      startPos = 0;
    }
    this.content.nodesBetween(from2, to, f, startPos, this);
  };
  _proto5.descendants = function descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  };
  _proto5.textBetween = function textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  };
  _proto5.eq = function eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  };
  _proto5.sameMarkup = function sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  };
  _proto5.hasMarkup = function hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
  };
  _proto5.copy = function copy2(content5) {
    if (content5 === void 0) {
      content5 = null;
    }
    if (content5 == this.content)
      return this;
    return new Node2(this.type, this.attrs, content5, this.marks);
  };
  _proto5.mark = function mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  };
  _proto5.cut = function cut3(from2, to) {
    if (to === void 0) {
      to = this.content.size;
    }
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  };
  _proto5.slice = function slice2(from2, to, includeParents) {
    if (to === void 0) {
      to = this.content.size;
    }
    if (includeParents === void 0) {
      includeParents = false;
    }
    if (from2 == to)
      return Slice.empty;
    var $from = this.resolve(from2), $to = this.resolve(to);
    var depth = includeParents ? 0 : $from.sharedDepth(to);
    var start2 = $from.start(depth), node = $from.node(depth);
    var content5 = node.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content5, $from.depth - depth, $to.depth - depth);
  };
  _proto5.replace = function replace(from2, to, slice2) {
    return _replace(this.resolve(from2), this.resolve(to), slice2);
  };
  _proto5.nodeAt = function nodeAt(pos) {
    for (var node = this; ; ) {
      var _node$content$findInd2 = node.content.findIndex(pos), index = _node$content$findInd2.index, _offset3 = _node$content$findInd2.offset;
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (_offset3 == pos || node.isText)
        return node;
      pos -= _offset3 + 1;
    }
  };
  _proto5.childAfter = function childAfter(pos) {
    var _this$content$findInd = this.content.findIndex(pos), index = _this$content$findInd.index, offset2 = _this$content$findInd.offset;
    return { node: this.content.maybeChild(index), index, offset: offset2 };
  };
  _proto5.childBefore = function childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    var _this$content$findInd2 = this.content.findIndex(pos), index = _this$content$findInd2.index, offset2 = _this$content$findInd2.offset;
    if (offset2 < pos)
      return { node: this.content.child(index), index, offset: offset2 };
    var node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset2 - node.nodeSize };
  };
  _proto5.resolve = function resolve2(pos) {
    return ResolvedPos.resolveCached(this, pos);
  };
  _proto5.resolveNoCache = function resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  };
  _proto5.rangeHasMark = function rangeHasMark(from2, to, type) {
    var found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, function(node) {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  };
  _proto5.toString = function toString2() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    var name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  };
  _proto5.contentMatchAt = function contentMatchAt(index) {
    var match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  };
  _proto5.canReplace = function canReplace(from2, to, replacement, start2, end2) {
    if (replacement === void 0) {
      replacement = Fragment.empty;
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = replacement.childCount;
    }
    var one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
    var two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (var _i20 = start2; _i20 < end2; _i20++)
      if (!this.type.allowsMarks(replacement.child(_i20).marks))
        return false;
    return true;
  };
  _proto5.canReplaceWith = function canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    var start2 = this.contentMatchAt(from2).matchType(type);
    var end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  };
  _proto5.canAppend = function canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  };
  _proto5.check = function check2() {
    this.type.checkContent(this.content);
    var copy2 = Mark$1.none;
    for (var _i21 = 0; _i21 < this.marks.length; _i21++)
      copy2 = this.marks[_i21].addToSet(copy2);
    if (!Mark$1.sameSet(copy2, this.marks))
      throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
        return m.type.name;
      }));
    this.content.forEach(function(node) {
      return node.check();
    });
  };
  _proto5.toJSON = function toJSON() {
    var obj = { type: this.type.name };
    for (var _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map(function(n) {
        return n.toJSON();
      });
    return obj;
  };
  Node2.fromJSON = function fromJSON(schema, json2) {
    if (!json2)
      throw new RangeError("Invalid input for Node.fromJSON");
    var marks = null;
    if (json2.marks) {
      if (!Array.isArray(json2.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json2.marks.map(schema.markFromJSON);
    }
    if (json2.type == "text") {
      if (typeof json2.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json2.text, marks);
    }
    var content5 = Fragment.fromJSON(schema, json2.content);
    return schema.nodeType(json2.type).create(json2.attrs, content5, marks);
  };
  _createClass(Node2, [{
    key: "nodeSize",
    get: function get5() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
  }, { key: "childCount", get: function get5() {
    return this.content.childCount;
  } }, { key: "textContent", get: function get5() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  } }, {
    key: "firstChild",
    get: function get5() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
  }, { key: "lastChild", get: function get5() {
    return this.content.lastChild;
  } }, {
    key: "isBlock",
    get: function get5() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
  }, {
    key: "isTextblock",
    get: function get5() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
  }, {
    key: "inlineContent",
    get: function get5() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
  }, {
    key: "isInline",
    get: function get5() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
  }, {
    key: "isText",
    get: function get5() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
  }, {
    key: "isLeaf",
    get: function get5() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
  }, { key: "isAtom", get: function get5() {
    return this.type.isAtom;
  } }]);
  return Node2;
}();
Node$1.prototype.text = void 0;
var TextNode = /* @__PURE__ */ function(_Node$) {
  _inheritsLoose(TextNode2, _Node$);
  function TextNode2(type, attrs, content5, marks) {
    var _this;
    _this = _Node$.call(this, type, attrs, null, marks) || this;
    if (!content5)
      throw new RangeError("Empty text nodes are not allowed");
    _this.text = content5;
    return _this;
  }
  var _proto6 = TextNode2.prototype;
  _proto6.toString = function toString2() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  };
  _proto6.textBetween = function textBetween(from2, to) {
    return this.text.slice(from2, to);
  };
  _proto6.mark = function mark(marks) {
    return marks == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks);
  };
  _proto6.withText = function withText(text) {
    if (text == this.text)
      return this;
    return new TextNode2(this.type, this.attrs, text, this.marks);
  };
  _proto6.cut = function cut3(from2, to) {
    if (from2 === void 0) {
      from2 = 0;
    }
    if (to === void 0) {
      to = this.text.length;
    }
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  };
  _proto6.eq = function eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  _proto6.toJSON = function toJSON() {
    var base2 = _Node$.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  _createClass(TextNode2, [{ key: "textContent", get: function get5() {
    return this.text;
  } }, { key: "nodeSize", get: function get5() {
    return this.text.length;
  } }]);
  return TextNode2;
}(Node$1);
function wrapMarks(marks, str) {
  for (var _i22 = marks.length - 1; _i22 >= 0; _i22--)
    str = marks[_i22].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = /* @__PURE__ */ function() {
  function ContentMatch2(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  ContentMatch2.parse = function parse(string, nodeTypes) {
    var stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch2.empty;
    var expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    var match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  };
  var _proto7 = ContentMatch2.prototype;
  _proto7.matchType = function matchType(type) {
    for (var _i23 = 0; _i23 < this.next.length; _i23++)
      if (this.next[_i23].type == type)
        return this.next[_i23].next;
    return null;
  };
  _proto7.matchFragment = function matchFragment(frag, start2, end2) {
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = frag.childCount;
    }
    var cur = this;
    for (var _i24 = start2; cur && _i24 < end2; _i24++)
      cur = cur.matchType(frag.child(_i24).type);
    return cur;
  };
  _proto7.compatible = function compatible(other) {
    for (var _i25 = 0; _i25 < this.next.length; _i25++)
      for (var j = 0; j < other.next.length; j++)
        if (this.next[_i25].type == other.next[j].type)
          return true;
    return false;
  };
  _proto7.fillBefore = function fillBefore(after, toEnd, startIndex2) {
    if (toEnd === void 0) {
      toEnd = false;
    }
    if (startIndex2 === void 0) {
      startIndex2 = 0;
    }
    var seen = [this];
    function search(match, types) {
      var finished = match.matchFragment(after, startIndex2);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map(function(tp) {
          return tp.createAndFill();
        }));
      for (var _i26 = 0; _i26 < match.next.length; _i26++) {
        var _match$next$_i = match.next[_i26], type = _match$next$_i.type, next = _match$next$_i.next;
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          var _found = search(next, types.concat(type));
          if (_found)
            return _found;
        }
      }
      return null;
    }
    return search(this, []);
  };
  _proto7.findWrapping = function findWrapping2(target) {
    for (var _i27 = 0; _i27 < this.wrapCache.length; _i27 += 2)
      if (this.wrapCache[_i27] == target)
        return this.wrapCache[_i27 + 1];
    var computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  };
  _proto7.computeWrapping = function computeWrapping(target) {
    var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      var current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        var result = [];
        for (var obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (var _i28 = 0; _i28 < match.next.length; _i28++) {
        var _match$next$_i2 = match.next[_i28], type = _match$next$_i2.type, next = _match$next$_i2.next;
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  };
  _proto7.edge = function edge(n) {
    if (n >= this.next.length)
      throw new RangeError("There's no " + n + "th edge in this content match");
    return this.next[n];
  };
  _proto7.toString = function toString2() {
    var seen = [];
    function scan(m) {
      seen.push(m);
      for (var _i29 = 0; _i29 < m.next.length; _i29++)
        if (seen.indexOf(m.next[_i29].next) == -1)
          scan(m.next[_i29].next);
    }
    scan(this);
    return seen.map(function(m, i) {
      var out = i + (m.validEnd ? "*" : " ") + " ";
      for (var _i30 = 0; _i30 < m.next.length; _i30++)
        out += (_i30 ? ", " : "") + m.next[_i30].type.name + "->" + seen.indexOf(m.next[_i30].next);
      return out;
    }).join("\n");
  };
  _createClass(ContentMatch2, [{
    key: "inlineContent",
    get: function get5() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
  }, { key: "defaultType", get: function get5() {
    for (var _i31 = 0; _i31 < this.next.length; _i31++) {
      var type = this.next[_i31].type;
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  } }, { key: "edgeCount", get: function get5() {
    return this.next.length;
  } }]);
  return ContentMatch2;
}();
ContentMatch.empty = new ContentMatch(true);
var TokenStream = /* @__PURE__ */ function() {
  function TokenStream2(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  var _proto8 = TokenStream2.prototype;
  _proto8.eat = function eat(tok) {
    return this.next == tok && (this.pos++ || true);
  };
  _proto8.err = function err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  };
  _createClass(TokenStream2, [{ key: "next", get: function get5() {
    return this.tokens[this.pos];
  } }]);
  return TokenStream2;
}();
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  var result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  var min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  var result = [];
  for (var typeName in types) {
    var _type = types[typeName];
    if (_type.groups.indexOf(name) > -1)
      result.push(_type);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function(type) {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  var nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    var edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach(function(edge2) {
      return edge2.to = to;
    });
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile(expr3, from2));
      }, []);
    } else if (expr2.type == "seq") {
      for (var _i32 = 0; ; _i32++) {
        var next = compile(expr2.exprs[_i32], from2);
        if (_i32 == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      var loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      var _loop2 = node();
      connect(compile(expr2.expr, from2), _loop2);
      connect(compile(expr2.expr, _loop2), _loop2);
      return [edge(_loop2)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      var cur = from2;
      for (var _i33 = 0; _i33 < expr2.min; _i33++) {
        var _next = node();
        connect(compile(expr2.expr, cur), _next);
        cur = _next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (var _i34 = expr2.min; _i34 < expr2.max; _i34++) {
          var _next2 = node();
          edge(cur, _next2);
          connect(compile(expr2.expr, cur), _next2);
          cur = _next2;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  var result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    var edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (var _i35 = 0; _i35 < edges.length; _i35++) {
      var _edges$_i = edges[_i35], term = _edges$_i.term, to = _edges$_i.to;
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node) {
      nfa2[node].forEach(function(_ref6) {
        var term = _ref6.term, to = _ref6.to;
        if (!term)
          return;
        var set2;
        for (var _i36 = 0; _i36 < out.length; _i36++)
          if (out[_i36][0] == term)
            set2 = out[_i36][1];
        nullFrom(nfa2, to).forEach(function(node2) {
          if (!set2)
            out.push([term, set2 = []]);
          if (set2.indexOf(node2) == -1)
            set2.push(node2);
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (var _i37 = 0; _i37 < out.length; _i37++) {
      var _states = out[_i37][1].sort(cmp);
      state.next.push({ type: out[_i37][0], next: labeled[_states.join(",")] || explore(_states) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (var _i38 = 0, work = [match]; _i38 < work.length; _i38++) {
    var state = work[_i38], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j++) {
      var _state$next$j = state.next[j], type = _state$next$j.type, next = _state$next$j.next;
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  var defaults2 = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function _computeAttrs(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (var name in attrs)
      result[name] = new Attribute(attrs[name]);
  return result;
}
var NodeType$1 = /* @__PURE__ */ function() {
  function NodeType2(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  var _proto9 = NodeType2.prototype;
  _proto9.hasRequiredAttrs = function hasRequiredAttrs() {
    for (var n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  };
  _proto9.compatibleContent = function compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  };
  _proto9.computeAttrs = function computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return _computeAttrs(this.attrs, attrs);
  };
  _proto9.create = function create2(attrs, content5, marks) {
    if (attrs === void 0) {
      attrs = null;
    }
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content5), Mark$1.setFrom(marks));
  };
  _proto9.createChecked = function createChecked(attrs, content5, marks) {
    if (attrs === void 0) {
      attrs = null;
    }
    content5 = Fragment.from(content5);
    this.checkContent(content5);
    return new Node$1(this, this.computeAttrs(attrs), content5, Mark$1.setFrom(marks));
  };
  _proto9.createAndFill = function createAndFill(attrs, content5, marks) {
    if (attrs === void 0) {
      attrs = null;
    }
    attrs = this.computeAttrs(attrs);
    content5 = Fragment.from(content5);
    if (content5.size) {
      var before = this.contentMatch.fillBefore(content5);
      if (!before)
        return null;
      content5 = before.append(content5);
    }
    var matched = this.contentMatch.matchFragment(content5);
    var after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$1(this, attrs, content5.append(after), Mark$1.setFrom(marks));
  };
  _proto9.validContent = function validContent(content5) {
    var result = this.contentMatch.matchFragment(content5);
    if (!result || !result.validEnd)
      return false;
    for (var _i39 = 0; _i39 < content5.childCount; _i39++)
      if (!this.allowsMarks(content5.child(_i39).marks))
        return false;
    return true;
  };
  _proto9.checkContent = function checkContent(content5) {
    if (!this.validContent(content5))
      throw new RangeError("Invalid content for node " + this.name + ": " + content5.toString().slice(0, 50));
  };
  _proto9.allowsMarkType = function allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  };
  _proto9.allowsMarks = function allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (var _i40 = 0; _i40 < marks.length; _i40++)
      if (!this.allowsMarkType(marks[_i40].type))
        return false;
    return true;
  };
  _proto9.allowedMarks = function allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    var copy2;
    for (var _i41 = 0; _i41 < marks.length; _i41++) {
      if (!this.allowsMarkType(marks[_i41].type)) {
        if (!copy2)
          copy2 = marks.slice(0, _i41);
      } else if (copy2) {
        copy2.push(marks[_i41]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
  };
  NodeType2.compile = function compile(nodes, schema) {
    var result = /* @__PURE__ */ Object.create(null);
    nodes.forEach(function(name, spec) {
      return result[name] = new NodeType2(name, schema, spec);
    });
    var topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (var _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  };
  _createClass(NodeType2, [{
    key: "isInline",
    get: function get5() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
  }, {
    key: "isTextblock",
    get: function get5() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
  }, {
    key: "isLeaf",
    get: function get5() {
      return this.contentMatch == ContentMatch.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
  }, {
    key: "isAtom",
    get: function get5() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
  }, { key: "whitespace", get: function get5() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  } }]);
  return NodeType2;
}();
var Attribute = /* @__PURE__ */ function() {
  function Attribute2(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  _createClass(Attribute2, [{ key: "isRequired", get: function get5() {
    return !this.hasDefault;
  } }]);
  return Attribute2;
}();
var MarkType = /* @__PURE__ */ function() {
  function MarkType2(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    var defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark$1(this, defaults2) : null;
  }
  var _proto10 = MarkType2.prototype;
  _proto10.create = function create2(attrs) {
    if (attrs === void 0) {
      attrs = null;
    }
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$1(this, _computeAttrs(this.attrs, attrs));
  };
  MarkType2.compile = function compile(marks, schema) {
    var result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach(function(name, spec) {
      return result[name] = new MarkType2(name, rank++, schema, spec);
    });
    return result;
  };
  _proto10.removeFromSet = function removeFromSet(set2) {
    for (var i = 0; i < set2.length; i++)
      if (set2[i].type == this) {
        set2 = set2.slice(0, i).concat(set2.slice(i + 1));
        i--;
      }
    return set2;
  };
  _proto10.isInSet = function isInSet(set2) {
    for (var _i42 = 0; _i42 < set2.length; _i42++)
      if (set2[_i42].type == this)
        return set2[_i42];
  };
  _proto10.excludes = function excludes(other) {
    return this.excluded.indexOf(other) > -1;
  };
  return MarkType2;
}();
var Schema = /* @__PURE__ */ function() {
  function Schema2(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    var instanceSpec = this.spec = {};
    for (var prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    var contentExprCache = /* @__PURE__ */ Object.create(null);
    for (var _prop in this.nodes) {
      if (_prop in this.marks)
        throw new RangeError(_prop + " can not be both a node and a mark");
      var type = this.nodes[_prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (var _prop2 in this.marks) {
      var _type2 = this.marks[_prop2], excl = _type2.spec.excludes;
      _type2.excluded = excl == null ? [_type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  var _proto11 = Schema2.prototype;
  _proto11.node = function node(type, attrs, content5, marks) {
    if (attrs === void 0) {
      attrs = null;
    }
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content5, marks);
  };
  _proto11.text = function text(_text, marks) {
    var type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, _text, Mark$1.setFrom(marks));
  };
  _proto11.mark = function mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  };
  _proto11.nodeFromJSON = function nodeFromJSON(json2) {
    return Node$1.fromJSON(this, json2);
  };
  _proto11.markFromJSON = function markFromJSON(json2) {
    return Mark$1.fromJSON(this, json2);
  };
  _proto11.nodeType = function nodeType(name) {
    var found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  };
  return Schema2;
}();
function gatherMarks(schema, marks) {
  var found2 = [];
  for (var _i43 = 0; _i43 < marks.length; _i43++) {
    var name = marks[_i43], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (var prop in schema.marks) {
        var _mark = schema.marks[prop];
        if (name == "_" || _mark.spec.group && _mark.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = _mark);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[_i43] + "'");
  }
  return found2;
}
var DOMParser = /* @__PURE__ */ function() {
  function DOMParser2(schema, rules) {
    var _this2 = this;
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach(function(rule) {
      if (rule.tag)
        _this2.tags.push(rule);
      else if (rule.style)
        _this2.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some(function(r2) {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      var node = schema.nodes[r2.node];
      return node.contentMatch.matchType(node);
    });
  }
  var _proto12 = DOMParser2.prototype;
  _proto12.parse = function parse(dom, options) {
    if (options === void 0) {
      options = {};
    }
    var context = new ParseContext(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  };
  _proto12.parseSlice = function parseSlice(dom, options) {
    if (options === void 0) {
      options = {};
    }
    var context = new ParseContext(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice.maxOpen(context.finish());
  };
  _proto12.matchTag = function matchTag(dom, context, after) {
    for (var _i44 = after ? this.tags.indexOf(after) + 1 : 0; _i44 < this.tags.length; _i44++) {
      var rule = this.tags[_i44];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          var result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  };
  _proto12.matchStyle = function matchStyle(prop, value, context, after) {
    for (var _i45 = after ? this.styles.indexOf(after) + 1 : 0; _i45 < this.styles.length; _i45++) {
      var rule = this.styles[_i45], _style = rule.style;
      if (_style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      _style.length > prop.length && (_style.charCodeAt(prop.length) != 61 || _style.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        var result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  };
  DOMParser2.schemaRules = function schemaRules(schema) {
    var result = [];
    function insert(rule) {
      var priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    var _loop3 = function _loop32(name2) {
      var rules = schema.marks[name2].spec.parseDOM;
      if (rules)
        rules.forEach(function(rule) {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name2;
        });
    };
    for (var name in schema.marks) {
      _loop3(name);
    }
    var _loop4 = function _loop42(_name22) {
      var rules = schema.nodes[_name22].spec.parseDOM;
      if (rules)
        rules.forEach(function(rule) {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = _name22;
        });
    };
    for (var _name2 in schema.nodes) {
      _loop4(_name2);
    }
    return result;
  };
  DOMParser2.fromSchema = function fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  };
  return DOMParser2;
}();
var blockTags = { address: true, article: true, aside: true, blockquote: true, canvas: true, dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true, footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true, h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true, output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true };
var ignoreTags = { head: true, noscript: true, object: true, script: true, style: true, title: true };
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = /* @__PURE__ */ function() {
  function NodeContext2(type, attrs, marks, pendingMarks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark$1.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  var _proto13 = NodeContext2.prototype;
  _proto13.findWrapping = function findWrapping2(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        var _start3 = this.type.contentMatch, _wrap;
        if (_wrap = _start3.findWrapping(node.type)) {
          this.match = _start3;
          return _wrap;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  };
  _proto13.finish = function finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      var last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        var text = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    var content5 = Fragment.from(this.content);
    if (!openEnd && this.match)
      content5 = content5.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content5, this.marks) : content5;
  };
  _proto13.popFromStashMark = function popFromStashMark(mark) {
    for (var _i46 = this.stashMarks.length - 1; _i46 >= 0; _i46--)
      if (mark.eq(this.stashMarks[_i46]))
        return this.stashMarks.splice(_i46, 1)[0];
  };
  _proto13.applyPending = function applyPending(nextType) {
    for (var _i47 = 0, pending = this.pendingMarks; _i47 < pending.length; _i47++) {
      var mark = pending[_i47];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  };
  _proto13.inlineContext = function inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  };
  return NodeContext2;
}();
var ParseContext = /* @__PURE__ */ function() {
  function ParseContext2(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    var topNode = options.topNode, topContext;
    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$1.none, Mark$1.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, Mark$1.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  var _proto14 = ParseContext2.prototype;
  _proto14.addDOM = function addDOM(dom) {
    if (dom.nodeType == 3)
      this.addTextNode(dom);
    else if (dom.nodeType == 1)
      this.addElement(dom);
  };
  _proto14.withStyleRules = function withStyleRules(dom, f) {
    var style2 = dom.getAttribute("style");
    if (!style2)
      return f();
    var marks = this.readStyles(parseStyles(style2));
    if (!marks)
      return;
    var addMarks = marks[0], removeMarks = marks[1], top2 = this.top;
    for (var _i48 = 0; _i48 < removeMarks.length; _i48++)
      this.removePendingMark(removeMarks[_i48], top2);
    for (var _i49 = 0; _i49 < addMarks.length; _i49++)
      this.addPendingMark(addMarks[_i49]);
    f();
    for (var _i50 = 0; _i50 < addMarks.length; _i50++)
      this.removePendingMark(addMarks[_i50], top2);
    for (var _i51 = 0; _i51 < removeMarks.length; _i51++)
      this.addPendingMark(removeMarks[_i51]);
  };
  _proto14.addTextNode = function addTextNode(dom) {
    var value = dom.nodeValue;
    var top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          var nodeBefore = top2.content[top2.content.length - 1];
          var domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  };
  _proto14.addElement = function addElement(dom, matchAfter) {
    var _this3 = this;
    var name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      var sync, _top = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (_top.content.length && _top.content[0].isInline && this.open) {
          this.open--;
          _top = this.top;
        }
        sync = true;
        if (!_top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      if (rule && rule.skip)
        this.addAll(dom);
      else
        this.withStyleRules(dom, function() {
          return _this3.addAll(dom);
        });
      if (sync)
        this.sync(_top);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.withStyleRules(dom, function() {
        _this3.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
      });
    }
  };
  _proto14.leafFallback = function leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  };
  _proto14.ignoreFallback = function ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  };
  _proto14.readStyles = function readStyles(styles) {
    var _this4 = this;
    var add = Mark$1.none, remove2 = Mark$1.none;
    for (var _i52 = 0; _i52 < styles.length; _i52 += 2) {
      var _loop5 = function _loop52(_after) {
        var rule = _this4.parser.matchStyle(styles[_i52], styles[_i52 + 1], _this4, _after);
        if (!rule) {
          after = _after;
          return 0;
        }
        if (rule.ignore)
          return { v: null };
        if (rule.clearMark) {
          _this4.top.pendingMarks.concat(_this4.top.activeMarks).forEach(function(m) {
            if (rule.clearMark(m))
              remove2 = m.addToSet(remove2);
          });
        } else {
          add = _this4.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
        }
        if (rule.consuming === false)
          _after = rule;
        else {
          after = _after;
          return 0;
        }
        after = _after;
      }, _ret2;
      for (var after = void 0; ; ) {
        _ret2 = _loop5(after);
        if (_ret2 === 0)
          break;
        if (_ret2)
          return _ret2.v;
      }
    }
    return [add, remove2];
  };
  _proto14.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
    var _this5 = this;
    var sync, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      var markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    var startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach(function(node) {
        return _this5.insertNode(node);
      });
    } else {
      var contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  };
  _proto14.addAll = function addAll(parent, startIndex2, endIndex2) {
    var index = startIndex2 || 0;
    for (var dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, _end5 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != _end5; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index);
  };
  _proto14.findPlace = function findPlace(node) {
    var route, sync;
    for (var depth = this.open; depth >= 0; depth--) {
      var cx = this.nodes[depth];
      var _found2 = cx.findWrapping(node);
      if (_found2 && (!route || route.length > _found2.length)) {
        route = _found2;
        sync = cx;
        if (!_found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync);
    for (var _i53 = 0; _i53 < route.length; _i53++)
      this.enterInner(route[_i53], null, false);
    return true;
  };
  _proto14.insertNode = function insertNode(node) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      var block = this.textblockFromContext();
      if (block)
        this.enterInner(block);
    }
    if (this.findPlace(node)) {
      this.closeExtra();
      var _top2 = this.top;
      _top2.applyPending(node.type);
      if (_top2.match)
        _top2.match = _top2.match.matchType(node.type);
      var marks = _top2.activeMarks;
      for (var _i54 = 0; _i54 < node.marks.length; _i54++)
        if (!_top2.type || _top2.type.allowsMarkType(node.marks[_i54].type))
          marks = node.marks[_i54].addToSet(marks);
      _top2.content.push(node.mark(marks));
      return true;
    }
    return false;
  };
  _proto14.enter = function enter3(type, attrs, preserveWS) {
    var ok = this.findPlace(type.create(attrs));
    if (ok)
      this.enterInner(type, attrs, true, preserveWS);
    return ok;
  };
  _proto14.enterInner = function enterInner(type, attrs, solid, preserveWS) {
    if (attrs === void 0) {
      attrs = null;
    }
    if (solid === void 0) {
      solid = false;
    }
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type);
    var options = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
    this.open++;
  };
  _proto14.closeExtra = function closeExtra(openEnd) {
    if (openEnd === void 0) {
      openEnd = false;
    }
    var i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  };
  _proto14.finish = function finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  };
  _proto14.sync = function sync(to) {
    for (var _i55 = this.open; _i55 >= 0; _i55--)
      if (this.nodes[_i55] == to) {
        this.open = _i55;
        return true;
      }
    return false;
  };
  _proto14.findAtPoint = function findAtPoint(parent, offset2) {
    if (this.find)
      for (var _i56 = 0; _i56 < this.find.length; _i56++) {
        if (this.find[_i56].node == parent && this.find[_i56].offset == offset2)
          this.find[_i56].pos = this.currentPos;
      }
  };
  _proto14.findInside = function findInside(parent) {
    if (this.find)
      for (var _i57 = 0; _i57 < this.find.length; _i57++) {
        if (this.find[_i57].pos == null && parent.nodeType == 1 && parent.contains(this.find[_i57].node))
          this.find[_i57].pos = this.currentPos;
      }
  };
  _proto14.findAround = function findAround(parent, content5, before) {
    if (parent != content5 && this.find)
      for (var _i58 = 0; _i58 < this.find.length; _i58++) {
        if (this.find[_i58].pos == null && parent.nodeType == 1 && parent.contains(this.find[_i58].node)) {
          var pos = content5.compareDocumentPosition(this.find[_i58].node);
          if (pos & (before ? 2 : 4))
            this.find[_i58].pos = this.currentPos;
        }
      }
  };
  _proto14.findInText = function findInText(textNode) {
    if (this.find)
      for (var _i59 = 0; _i59 < this.find.length; _i59++) {
        if (this.find[_i59].node == textNode)
          this.find[_i59].pos = this.currentPos - (textNode.nodeValue.length - this.find[_i59].offset);
      }
  };
  _proto14.matchesContext = function matchesContext(context) {
    var _this6 = this;
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    var parts = context.split("/");
    var option = this.options.context;
    var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    var match = function match2(i, depth) {
      for (; i >= 0; i--) {
        var part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match2(i - 1, depth))
              return true;
          return false;
        } else {
          var next = depth > 0 || depth == 0 && useRoot ? _this6.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  };
  _proto14.textblockFromContext = function textblockFromContext() {
    var $context = this.options.context;
    if ($context)
      for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (var name in this.parser.schema.nodes) {
      var type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  };
  _proto14.addPendingMark = function addPendingMark(mark) {
    var found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  };
  _proto14.removePendingMark = function removePendingMark(mark, upto) {
    for (var depth = this.open; depth >= 0; depth--) {
      var level = this.nodes[depth];
      var _found3 = level.pendingMarks.lastIndexOf(mark);
      if (_found3 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        var stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  };
  _createClass(ParseContext2, [{ key: "top", get: function get5() {
    return this.nodes[this.open];
  } }, { key: "currentPos", get: function get5() {
    this.closeExtra();
    var pos = 0;
    for (var _i60 = this.open; _i60 >= 0; _i60--) {
      var content5 = this.nodes[_i60].content;
      for (var j = content5.length - 1; j >= 0; j--)
        pos += content5[j].nodeSize;
      if (_i60)
        pos++;
    }
    return pos;
  } }]);
  return ParseContext2;
}();
function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style2) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style2))
    result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  var copy2 = {};
  for (var prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;
  var _loop6 = function _loop62() {
    var parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      return 0;
    var seen = [], scan = function scan2(match) {
      seen.push(match);
      for (var _i61 = 0; _i61 < match.edgeCount; _i61++) {
        var _match$edge = match.edge(_i61), type = _match$edge.type, next = _match$edge.next;
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan2(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return { v: true };
  }, _ret3;
  for (var name in nodes) {
    _ret3 = _loop6();
    if (_ret3 === 0)
      continue;
    if (_ret3)
      return _ret3.v;
  }
}
function findSameMarkInSet(mark, set2) {
  for (var _i62 = 0; _i62 < set2.length; _i62++) {
    if (mark.eq(set2[_i62]))
      return set2[_i62];
  }
}
var DOMSerializer = /* @__PURE__ */ function() {
  function DOMSerializer2(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  var _proto15 = DOMSerializer2.prototype;
  _proto15.serializeFragment = function serializeFragment(fragment, options, target) {
    var _this7 = this;
    if (options === void 0) {
      options = {};
    }
    if (!target)
      target = doc$1(options).createDocumentFragment();
    var top2 = target, active = [];
    fragment.forEach(function(node) {
      if (active.length || node.marks.length) {
        var keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          var next = node.marks[rendered];
          if (!_this7.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          var add = node.marks[rendered++];
          var markDOM = _this7.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(_this7.serializeNodeInner(node, options));
    });
    return target;
  };
  _proto15.serializeNodeInner = function serializeNodeInner(node, options) {
    var _DOMSerializer$render = DOMSerializer2.renderSpec(doc$1(options), this.nodes[node.type.name](node)), dom = _DOMSerializer$render.dom, contentDOM = _DOMSerializer$render.contentDOM;
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  };
  _proto15.serializeNode = function serializeNode(node, options) {
    if (options === void 0) {
      options = {};
    }
    var dom = this.serializeNodeInner(node, options);
    for (var _i63 = node.marks.length - 1; _i63 >= 0; _i63--) {
      var _wrap2 = this.serializeMark(node.marks[_i63], node.isInline, options);
      if (_wrap2) {
        (_wrap2.contentDOM || _wrap2.dom).appendChild(dom);
        dom = _wrap2.dom;
      }
    }
    return dom;
  };
  _proto15.serializeMark = function serializeMark(mark, inline2, options) {
    if (options === void 0) {
      options = {};
    }
    var toDOM = this.marks[mark.type.name];
    return toDOM && DOMSerializer2.renderSpec(doc$1(options), toDOM(mark, inline2));
  };
  DOMSerializer2.renderSpec = function renderSpec(doc2, structure, xmlNS) {
    if (xmlNS === void 0) {
      xmlNS = null;
    }
    if (typeof structure == "string")
      return { dom: doc2.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    var tagName = structure[0], space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    var contentDOM;
    var dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
    var attrs = structure[1], start2 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start2 = 2;
      for (var name in attrs)
        if (attrs[name] != null) {
          var _space = name.indexOf(" ");
          if (_space > 0)
            dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (var _i64 = start2; _i64 < structure.length; _i64++) {
      var child = structure[_i64];
      if (child === 0) {
        if (_i64 < structure.length - 1 || _i64 > start2)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        var _DOMSerializer$render2 = DOMSerializer2.renderSpec(doc2, child, xmlNS), inner = _DOMSerializer$render2.dom, innerContent = _DOMSerializer$render2.contentDOM;
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  };
  DOMSerializer2.fromSchema = function fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer2(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  };
  DOMSerializer2.nodesFromSchema = function nodesFromSchema(schema) {
    var result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = function(node) {
        return node.text;
      };
    return result;
  };
  DOMSerializer2.marksFromSchema = function marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  };
  return DOMSerializer2;
}();
function gatherToDOM(obj) {
  var result = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc$1(options) {
  return options.document || window.document;
}
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset2) {
  return index + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
var MapResult = /* @__PURE__ */ function() {
  function MapResult2(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  _createClass(MapResult2, [{
    key: "deleted",
    get: function get5() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
  }, {
    key: "deletedBefore",
    get: function get5() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
  }, {
    key: "deletedAfter",
    get: function get5() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
  }, { key: "deletedAcross", get: function get5() {
    return (this.delInfo & DEL_ACROSS) > 0;
  } }]);
  return MapResult2;
}();
var StepMap = /* @__PURE__ */ function() {
  function StepMap2(ranges, inverted) {
    if (inverted === void 0) {
      inverted = false;
    }
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap2.empty)
      return StepMap2.empty;
  }
  var _proto16 = StepMap2.prototype;
  _proto16.recover = function recover(value) {
    var diff2 = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (var _i65 = 0; _i65 < index; _i65++)
        diff2 += this.ranges[_i65 * 3 + 2] - this.ranges[_i65 * 3 + 1];
    return this.ranges[index * 3] + diff2 + recoverOffset(value);
  };
  _proto16.mapResult = function mapResult(pos, assoc) {
    if (assoc === void 0) {
      assoc = 1;
    }
    return this._map(pos, assoc, false);
  };
  _proto16.map = function map3(pos, assoc) {
    if (assoc === void 0) {
      assoc = 1;
    }
    return this._map(pos, assoc, true);
  };
  _proto16._map = function _map(pos, assoc, simple) {
    var diff2 = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var _i66 = 0; _i66 < this.ranges.length; _i66 += 3) {
      var _start4 = this.ranges[_i66] - (this.inverted ? diff2 : 0);
      if (_start4 > pos)
        break;
      var oldSize = this.ranges[_i66 + oldIndex], newSize = this.ranges[_i66 + newIndex], _end6 = _start4 + oldSize;
      if (pos <= _end6) {
        var side = !oldSize ? assoc : pos == _start4 ? -1 : pos == _end6 ? 1 : assoc;
        var result = _start4 + diff2 + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        var recover = pos == (assoc < 0 ? _start4 : _end6) ? null : makeRecover(_i66 / 3, pos - _start4);
        var del = pos == _start4 ? DEL_AFTER : pos == _end6 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != _start4 : pos != _end6)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff2 += newSize - oldSize;
    }
    return simple ? pos + diff2 : new MapResult(pos + diff2, 0, null);
  };
  _proto16.touches = function touches(pos, recover) {
    var diff2 = 0, index = recoverIndex(recover);
    var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var _i67 = 0; _i67 < this.ranges.length; _i67 += 3) {
      var _start5 = this.ranges[_i67] - (this.inverted ? diff2 : 0);
      if (_start5 > pos)
        break;
      var oldSize = this.ranges[_i67 + oldIndex], _end7 = _start5 + oldSize;
      if (pos <= _end7 && _i67 == index * 3)
        return true;
      diff2 += this.ranges[_i67 + newIndex] - oldSize;
    }
    return false;
  };
  _proto16.forEach = function forEach5(f) {
    var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (var _i68 = 0, _diff = 0; _i68 < this.ranges.length; _i68 += 3) {
      var _start6 = this.ranges[_i68], oldStart = _start6 - (this.inverted ? _diff : 0), newStart = _start6 + (this.inverted ? 0 : _diff);
      var oldSize = this.ranges[_i68 + oldIndex], newSize = this.ranges[_i68 + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      _diff += newSize - oldSize;
    }
  };
  _proto16.invert = function invert() {
    return new StepMap2(this.ranges, !this.inverted);
  };
  _proto16.toString = function toString2() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  };
  StepMap2.offset = function offset2(n) {
    return n == 0 ? StepMap2.empty : new StepMap2(n < 0 ? [0, -n, 0] : [0, 0, n]);
  };
  return StepMap2;
}();
StepMap.empty = new StepMap([]);
var Mapping = /* @__PURE__ */ function() {
  function Mapping2(maps, mirror, from2, to) {
    if (maps === void 0) {
      maps = [];
    }
    if (from2 === void 0) {
      from2 = 0;
    }
    if (to === void 0) {
      to = maps.length;
    }
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  var _proto17 = Mapping2.prototype;
  _proto17.slice = function slice2(from2, to) {
    if (from2 === void 0) {
      from2 = 0;
    }
    if (to === void 0) {
      to = this.maps.length;
    }
    return new Mapping2(this.maps, this.mirror, from2, to);
  };
  _proto17.copy = function copy2() {
    return new Mapping2(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  };
  _proto17.appendMap = function appendMap(map3, mirrors) {
    this.to = this.maps.push(map3);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  };
  _proto17.appendMapping = function appendMapping(mapping) {
    for (var _i69 = 0, startSize = this.maps.length; _i69 < mapping.maps.length; _i69++) {
      var mirr = mapping.getMirror(_i69);
      this.appendMap(mapping.maps[_i69], mirr != null && mirr < _i69 ? startSize + mirr : void 0);
    }
  };
  _proto17.getMirror = function getMirror(n) {
    if (this.mirror) {
      for (var _i70 = 0; _i70 < this.mirror.length; _i70++)
        if (this.mirror[_i70] == n)
          return this.mirror[_i70 + (_i70 % 2 ? -1 : 1)];
    }
  };
  _proto17.setMirror = function setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  };
  _proto17.appendMappingInverted = function appendMappingInverted(mapping) {
    for (var _i71 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; _i71 >= 0; _i71--) {
      var mirr = mapping.getMirror(_i71);
      this.appendMap(mapping.maps[_i71].invert(), mirr != null && mirr > _i71 ? totalSize - mirr - 1 : void 0);
    }
  };
  _proto17.invert = function invert() {
    var inverse = new Mapping2();
    inverse.appendMappingInverted(this);
    return inverse;
  };
  _proto17.map = function map3(pos, assoc) {
    if (assoc === void 0) {
      assoc = 1;
    }
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (var _i72 = this.from; _i72 < this.to; _i72++)
      pos = this.maps[_i72].map(pos, assoc);
    return pos;
  };
  _proto17.mapResult = function mapResult(pos, assoc) {
    if (assoc === void 0) {
      assoc = 1;
    }
    return this._map(pos, assoc, false);
  };
  _proto17._map = function _map(pos, assoc, simple) {
    var delInfo = 0;
    for (var _i73 = this.from; _i73 < this.to; _i73++) {
      var map3 = this.maps[_i73], result = map3.mapResult(pos, assoc);
      if (result.recover != null) {
        var corr = this.getMirror(_i73);
        if (corr != null && corr > _i73 && corr < this.to) {
          _i73 = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  };
  return Mapping2;
}();
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = /* @__PURE__ */ function() {
  function Step2() {
  }
  var _proto18 = Step2.prototype;
  _proto18.getMap = function getMap() {
    return StepMap.empty;
  };
  _proto18.merge = function merge(other) {
    return null;
  };
  Step2.fromJSON = function fromJSON(schema, json2) {
    if (!json2 || !json2.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    var type = stepsByID[json2.stepType];
    if (!type)
      throw new RangeError("No step type " + json2.stepType + " defined");
    return type.fromJSON(schema, json2);
  };
  Step2.jsonID = function jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  };
  return Step2;
}();
var StepResult = /* @__PURE__ */ function() {
  function StepResult2(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  StepResult2.ok = function ok(doc2) {
    return new StepResult2(doc2, null);
  };
  StepResult2.fail = function fail(message) {
    return new StepResult2(null, message);
  };
  StepResult2.fromReplace = function fromReplace(doc2, from2, to, slice2) {
    try {
      return StepResult2.ok(doc2.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult2.fail(e.message);
      throw e;
    }
  };
  return StepResult2;
}();
function mapFragment(fragment, f, parent) {
  var mapped = [];
  for (var _i74 = 0; _i74 < fragment.childCount; _i74++) {
    var child = fragment.child(_i74);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, _i74);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = /* @__PURE__ */ function(_Step) {
  _inheritsLoose(AddMarkStep2, _Step);
  function AddMarkStep2(from2, to, mark) {
    var _this8;
    _this8 = _Step.call(this) || this;
    _this8.from = from2;
    _this8.to = to;
    _this8.mark = mark;
    return _this8;
  }
  var _proto19 = AddMarkStep2.prototype;
  _proto19.apply = function apply6(doc2) {
    var _this9 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice2 = new Slice(mapFragment(oldSlice.content, function(node, parent2) {
      if (!node.isAtom || !parent2.type.allowsMarkType(_this9.mark.type))
        return node;
      return node.mark(_this9.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  };
  _proto19.invert = function invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  };
  _proto19.map = function map3(mapping) {
    var from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new AddMarkStep2(from2.pos, to.pos, this.mark);
  };
  _proto19.merge = function merge(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  };
  _proto19.toJSON = function toJSON() {
    return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to };
  };
  AddMarkStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep2(json2.from, json2.to, schema.markFromJSON(json2.mark));
  };
  return AddMarkStep2;
}(Step);
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = /* @__PURE__ */ function(_Step2) {
  _inheritsLoose(RemoveMarkStep2, _Step2);
  function RemoveMarkStep2(from2, to, mark) {
    var _this10;
    _this10 = _Step2.call(this) || this;
    _this10.from = from2;
    _this10.to = to;
    _this10.mark = mark;
    return _this10;
  }
  var _proto20 = RemoveMarkStep2.prototype;
  _proto20.apply = function apply6(doc2) {
    var _this11 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice2 = new Slice(mapFragment(oldSlice.content, function(node) {
      return node.mark(_this11.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  };
  _proto20.invert = function invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  };
  _proto20.map = function map3(mapping) {
    var from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new RemoveMarkStep2(from2.pos, to.pos, this.mark);
  };
  _proto20.merge = function merge(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  };
  _proto20.toJSON = function toJSON() {
    return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to };
  };
  RemoveMarkStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep2(json2.from, json2.to, schema.markFromJSON(json2.mark));
  };
  return RemoveMarkStep2;
}(Step);
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = /* @__PURE__ */ function(_Step3) {
  _inheritsLoose(AddNodeMarkStep2, _Step3);
  function AddNodeMarkStep2(pos, mark) {
    var _this12;
    _this12 = _Step3.call(this) || this;
    _this12.pos = pos;
    _this12.mark = mark;
    return _this12;
  }
  var _proto21 = AddNodeMarkStep2.prototype;
  _proto21.apply = function apply6(doc2) {
    var node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  };
  _proto21.invert = function invert(doc2) {
    var node = doc2.nodeAt(this.pos);
    if (node) {
      var newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (var _i75 = 0; _i75 < node.marks.length; _i75++)
          if (!node.marks[_i75].isInSet(newSet))
            return new AddNodeMarkStep2(this.pos, node.marks[_i75]);
        return new AddNodeMarkStep2(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  };
  _proto21.map = function map3(mapping) {
    var pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep2(pos.pos, this.mark);
  };
  _proto21.toJSON = function toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  };
  AddNodeMarkStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep2(json2.pos, schema.markFromJSON(json2.mark));
  };
  return AddNodeMarkStep2;
}(Step);
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = /* @__PURE__ */ function(_Step4) {
  _inheritsLoose(RemoveNodeMarkStep2, _Step4);
  function RemoveNodeMarkStep2(pos, mark) {
    var _this13;
    _this13 = _Step4.call(this) || this;
    _this13.pos = pos;
    _this13.mark = mark;
    return _this13;
  }
  var _proto22 = RemoveNodeMarkStep2.prototype;
  _proto22.apply = function apply6(doc2) {
    var node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  };
  _proto22.invert = function invert(doc2) {
    var node = doc2.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  };
  _proto22.map = function map3(mapping) {
    var pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep2(pos.pos, this.mark);
  };
  _proto22.toJSON = function toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  };
  RemoveNodeMarkStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep2(json2.pos, schema.markFromJSON(json2.mark));
  };
  return RemoveNodeMarkStep2;
}(Step);
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = /* @__PURE__ */ function(_Step5) {
  _inheritsLoose(ReplaceStep2, _Step5);
  function ReplaceStep2(from2, to, slice2, structure) {
    var _this14;
    if (structure === void 0) {
      structure = false;
    }
    _this14 = _Step5.call(this) || this;
    _this14.from = from2;
    _this14.to = to;
    _this14.slice = slice2;
    _this14.structure = structure;
    return _this14;
  }
  var _proto23 = ReplaceStep2.prototype;
  _proto23.apply = function apply6(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  };
  _proto23.getMap = function getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  };
  _proto23.invert = function invert(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  _proto23.map = function map3(mapping) {
    var from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep2(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  };
  _proto23.merge = function merge(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var _slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, _slice, this.structure);
    } else {
      return null;
    }
  };
  _proto23.toJSON = function toJSON() {
    var json2 = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json2.slice = this.slice.toJSON();
    if (this.structure)
      json2.structure = true;
    return json2;
  };
  ReplaceStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep2(json2.from, json2.to, Slice.fromJSON(schema, json2.slice), !!json2.structure);
  };
  return ReplaceStep2;
}(Step);
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = /* @__PURE__ */ function(_Step6) {
  _inheritsLoose(ReplaceAroundStep2, _Step6);
  function ReplaceAroundStep2(from2, to, gapFrom, gapTo, slice2, insert, structure) {
    var _this15;
    if (structure === void 0) {
      structure = false;
    }
    _this15 = _Step6.call(this) || this;
    _this15.from = from2;
    _this15.to = to;
    _this15.gapFrom = gapFrom;
    _this15.gapTo = gapTo;
    _this15.slice = slice2;
    _this15.insert = insert;
    _this15.structure = structure;
    return _this15;
  }
  var _proto24 = ReplaceAroundStep2.prototype;
  _proto24.apply = function apply6(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  };
  _proto24.getMap = function getMap() {
    return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
  };
  _proto24.invert = function invert(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  _proto24.map = function map3(mapping) {
    var from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep2(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  _proto24.toJSON = function toJSON() {
    var json2 = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };
    if (this.slice.size)
      json2.slice = this.slice.toJSON();
    if (this.structure)
      json2.structure = true;
    return json2;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number" || typeof json2.gapFrom != "number" || typeof json2.gapTo != "number" || typeof json2.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep2(json2.from, json2.to, json2.gapFrom, json2.gapTo, Slice.fromJSON(schema, json2.slice), json2.insert, !!json2.structure);
  };
  return ReplaceAroundStep2;
}(Step);
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from2, to) {
  var $from = doc2.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function _addMark(tr4, from2, to, mark) {
  var removed = [], added = [];
  var removing, adding;
  tr4.doc.nodesBetween(from2, to, function(node, pos, parent) {
    if (!node.isInline)
      return;
    var marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var _start7 = Math.max(pos, from2), _end8 = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);
      for (var _i76 = 0; _i76 < marks.length; _i76++) {
        if (!marks[_i76].isInSet(newSet)) {
          if (removing && removing.to == _start7 && removing.mark.eq(marks[_i76]))
            removing.to = _end8;
          else
            removed.push(removing = new RemoveMarkStep(_start7, _end8, marks[_i76]));
        }
      }
      if (adding && adding.to == _start7)
        adding.to = _end8;
      else
        added.push(adding = new AddMarkStep(_start7, _end8, mark));
    }
  });
  removed.forEach(function(s) {
    return tr4.step(s);
  });
  added.forEach(function(s) {
    return tr4.step(s);
  });
}
function _removeMark(tr4, from2, to, mark) {
  var matched = [], step = 0;
  tr4.doc.nodesBetween(from2, to, function(node, pos) {
    if (!node.isInline)
      return;
    step++;
    var toRemove = null;
    if (mark instanceof MarkType) {
      var set2 = node.marks, _found4;
      while (_found4 = mark.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(_found4);
        set2 = _found4.removeFromSet(set2);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      var _end9 = Math.min(pos + node.nodeSize, to);
      for (var _i77 = 0; _i77 < toRemove.length; _i77++) {
        var _style2 = toRemove[_i77], _found5 = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && _style2.eq(matched[j].style))
            _found5 = m;
        }
        if (_found5) {
          _found5.to = _end9;
          _found5.step = step;
        } else {
          matched.push({ style: _style2, from: Math.max(pos, from2), to: _end9, step });
        }
      }
    }
  });
  matched.forEach(function(m) {
    return tr4.step(new RemoveMarkStep(m.from, m.to, m.style));
  });
}
function _clearIncompatible(tr4, pos, parentType, match) {
  if (match === void 0) {
    match = parentType.contentMatch;
  }
  var node = tr4.doc.nodeAt(pos);
  var replSteps = [], cur = pos + 1;
  for (var _i78 = 0; _i78 < node.childCount; _i78++) {
    var child = node.child(_i78), _end10 = cur + child.nodeSize;
    var allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, _end10, Slice.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr4.step(new RemoveMarkStep(cur, _end10, child.marks[j]));
      if (child.isText && !parentType.spec.code) {
        var m = void 0, newline = /\r?\n|\r/g, slice2 = void 0;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = _end10;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(Fragment.empty, true);
    tr4.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (var _i79 = replSteps.length - 1; _i79 >= 0; _i79--)
    tr4.step(replSteps[_i79]);
}
function canCut(node, start2, end2) {
  return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
}
function liftTarget(range) {
  var parent = range.parent;
  var content5 = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth; ; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth), endIndex2 = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex2, content5))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex2))
      break;
  }
  return null;
}
function lift$2(tr4, range, target) {
  var $from = range.$from, $to = range.$to, depth = range.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start2 = gapStart, end2 = gapEnd;
  var before = Fragment.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start2--;
    }
  var after = Fragment.empty, openEnd = 0;
  for (var _d2 = depth, _splitting = false; _d2 > target; _d2--)
    if (_splitting || $to.after(_d2 + 1) < $to.end(_d2)) {
      _splitting = true;
      after = Fragment.from($to.node(_d2).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr4.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs, innerRange) {
  if (attrs === void 0) {
    attrs = null;
  }
  if (innerRange === void 0) {
    innerRange = range;
  }
  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  var parent = range.parent, startIndex2 = range.startIndex, endIndex2 = range.endIndex;
  var around = parent.contentMatchAt(startIndex2).findWrapping(type);
  if (!around)
    return null;
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex2, endIndex2, outer) ? around : null;
}
function findWrappingInside(range, type) {
  var parent = range.parent, startIndex2 = range.startIndex, endIndex2 = range.endIndex;
  var inner = parent.child(startIndex2);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var _i80 = startIndex2; innerMatch && _i80 < endIndex2; _i80++)
    innerMatch = innerMatch.matchType(parent.child(_i80).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function _wrap4(tr4, range, wrappers) {
  var content5 = Fragment.empty;
  for (var _i81 = wrappers.length - 1; _i81 >= 0; _i81--) {
    if (content5.size) {
      var match = wrappers[_i81].type.contentMatch.matchFragment(content5);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content5 = Fragment.from(wrappers[_i81].type.create(wrappers[_i81].attrs, content5));
  }
  var start2 = range.start, end2 = range.end;
  tr4.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content5, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr4, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  var mapFrom = tr4.steps.length;
  tr4.doc.nodesBetween(from2, to, function(node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr4.doc, tr4.mapping.slice(mapFrom).map(pos), type)) {
      tr4.clearIncompatible(tr4.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = tr4.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr4.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc2, pos, type) {
  var $pos = doc2.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function _setNodeMarkup(tr4, pos, type, attrs, marks) {
  var node = tr4.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  var newNode3 = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr4.replaceWith(pos, pos + node.nodeSize, newNode3);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr4.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode3), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth, typesAfter) {
  if (depth === void 0) {
    depth = 1;
  }
  var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (var d = $pos.depth - 1, _i82 = depth - 2; d > base2; d--, _i82--) {
    var node = $pos.node(d), _index = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    var rest = node.content.cutByIndex(_index, node.childCount);
    var overrideChild = typesAfter && typesAfter[_i82 + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    var after = typesAfter && typesAfter[_i82] || node;
    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  var index = $pos.indexAfter(base2);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function _split(tr4, pos, depth, typesAfter) {
  if (depth === void 0) {
    depth = 1;
  }
  var $pos = tr4.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, _i83 = depth - 1; d > e; d--, _i83--) {
    before = Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[_i83];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr4.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  var $pos = doc2.resolve(pos), index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function joinable(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function joinPoint(doc2, pos, dir) {
  if (dir === void 0) {
    dir = -1;
  }
  var $pos = doc2.resolve(pos);
  for (var d = $pos.depth; ; d--) {
    var before = void 0, after = void 0, index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function _join(tr4, pos, depth) {
  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr4.step(step);
}
function insertPoint(doc2, pos, nodeType) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (var _d3 = $pos.depth - 1; _d3 >= 0; _d3--) {
      var _index2 = $pos.indexAfter(_d3);
      if ($pos.node(_d3).canReplaceWith(_index2, _index2, nodeType))
        return $pos.after(_d3 + 1);
      if (_index2 < $pos.node(_d3).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice2) {
  var $pos = doc2.resolve(pos);
  if (!slice2.content.size)
    return pos;
  var content5 = slice2.content;
  for (var _i84 = 0; _i84 < slice2.openStart; _i84++)
    content5 = content5.firstChild.content;
  for (var pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content5);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content5.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from2, to, slice2) {
  if (to === void 0) {
    to = from2;
  }
  if (slice2 === void 0) {
    slice2 = Slice.empty;
  }
  if (from2 == to && !slice2.size)
    return null;
  var $from = doc2.resolve(from2), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = /* @__PURE__ */ function() {
  function Fitter2($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (var _i85 = 0; _i85 <= $from.depth; _i85++) {
      var node = $from.node(_i85);
      this.frontier.push({ type: node.type, match: node.contentMatchAt($from.indexAfter(_i85)) });
    }
    for (var _i86 = $from.depth; _i86 > 0; _i86--)
      this.placed = Fragment.from($from.node(_i86).copy(this.placed));
  }
  var _proto25 = Fitter2.prototype;
  _proto25.fit = function fit() {
    while (this.unplaced.size) {
      var fit2 = this.findFittable();
      if (fit2)
        this.placeNodes(fit2);
      else
        this.openMore() || this.dropNode();
    }
    var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    var content5 = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content5.childCount == 1) {
      content5 = content5.firstChild.content;
      openStart--;
      openEnd--;
    }
    var slice2 = new Slice(content5, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  };
  _proto25.findFittable = function findFittable() {
    var startDepth = this.unplaced.openStart;
    for (var cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      var node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (var pass = 1; pass <= 2; pass++) {
      for (var sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        var fragment = void 0, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        var _first = fragment.firstChild;
        for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          var _this$frontier$fronti = this.frontier[frontierDepth], type = _this$frontier$fronti.type, match = _this$frontier$fronti.match, _wrap3 = void 0, inject = null;
          if (pass == 1 && (_first ? match.matchType(_first.type) || (inject = match.fillBefore(Fragment.from(_first), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && _first && (_wrap3 = match.findWrapping(_first.type)))
            return { sliceDepth, frontierDepth, parent, wrap: _wrap3 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  };
  _proto25.openMore = function openMore() {
    var _this$unplaced = this.unplaced, content5 = _this$unplaced.content, openStart = _this$unplaced.openStart, openEnd = _this$unplaced.openEnd;
    var inner = contentAt(content5, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content5, openStart + 1, Math.max(openEnd, inner.size + openStart >= content5.size - openEnd ? openStart + 1 : 0));
    return true;
  };
  _proto25.dropNode = function dropNode() {
    var _this$unplaced2 = this.unplaced, content5 = _this$unplaced2.content, openStart = _this$unplaced2.openStart, openEnd = _this$unplaced2.openEnd;
    var inner = contentAt(content5, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      var openAtEnd = content5.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content5, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content5, openStart, 1), openStart, openEnd);
    }
  };
  _proto25.placeNodes = function placeNodes(_ref7) {
    var sliceDepth = _ref7.sliceDepth, frontierDepth = _ref7.frontierDepth, parent = _ref7.parent, inject = _ref7.inject, wrap = _ref7.wrap;
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap)
      for (var _i87 = 0; _i87 < wrap.length; _i87++)
        this.openFrontierNode(wrap[_i87]);
    var slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    var openStart = slice2.openStart - sliceDepth;
    var taken = 0, add = [];
    var _this$frontier$fronti2 = this.frontier[frontierDepth], match = _this$frontier$fronti2.match, type = _this$frontier$fronti2.type;
    if (inject) {
      for (var _i88 = 0; _i88 < inject.childCount; _i88++)
        add.push(inject.child(_i88));
      match = match.matchFragment(inject);
    }
    var openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      var next = fragment.child(taken), _matches = match.matchType(next.type);
      if (!_matches)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = _matches;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    var toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (var _i89 = 0, cur = fragment; _i89 < openEndCount; _i89++) {
      var node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  };
  _proto25.mustMoveInline = function mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    var top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    var depth = this.$to.depth, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  };
  _proto25.findCloseLevel = function findCloseLevel($to) {
    scan:
      for (var _i90 = Math.min(this.depth, $to.depth); _i90 >= 0; _i90--) {
        var _this$frontier$_i = this.frontier[_i90], match = _this$frontier$_i.match, type = _this$frontier$_i.type;
        var dropInner = _i90 < $to.depth && $to.end(_i90 + 1) == $to.pos + ($to.depth - (_i90 + 1));
        var fit = contentAfterFits($to, _i90, type, match, dropInner);
        if (!fit)
          continue;
        for (var d = _i90 - 1; d >= 0; d--) {
          var _this$frontier$d = this.frontier[d], _match = _this$frontier$d.match, _type3 = _this$frontier$d.type;
          var _matches2 = contentAfterFits($to, d, _type3, _match, true);
          if (!_matches2 || _matches2.childCount)
            continue scan;
        }
        return { depth: _i90, fit, move: dropInner ? $to.doc.resolve($to.after(_i90 + 1)) : $to };
      }
  };
  _proto25.close = function close2($to) {
    var close3 = this.findCloseLevel($to);
    if (!close3)
      return null;
    while (this.depth > close3.depth)
      this.closeFrontierNode();
    if (close3.fit.childCount)
      this.placed = addToFragment(this.placed, close3.depth, close3.fit);
    $to = close3.move;
    for (var d = close3.depth + 1; d <= $to.depth; d++) {
      var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  };
  _proto25.openFrontierNode = function openFrontierNode(type, attrs, content5) {
    if (attrs === void 0) {
      attrs = null;
    }
    var top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content5)));
    this.frontier.push({ type, match: type.contentMatch });
  };
  _proto25.closeFrontierNode = function closeFrontierNode() {
    var open = this.frontier.pop();
    var add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  };
  _createClass(Fitter2, [{ key: "depth", get: function get5() {
    return this.frontier.length - 1;
  } }]);
  return Fitter2;
}();
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content5) {
  if (depth == 0)
    return fragment.append(content5);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content5)));
}
function contentAt(fragment, depth) {
  for (var _i91 = 0; _i91 < depth; _i91++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  var frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (var _i92 = start2; _i92 < fragment.childCount; _i92++)
    if (!type.allowsMarks(fragment.child(_i92).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function _replaceRange(tr4, from2, to, slice2) {
  if (!slice2.size)
    return tr4.deleteRange(from2, to);
  var $from = tr4.doc.resolve(from2), $to = tr4.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr4.step(new ReplaceStep(from2, to, slice2));
  var targetDepths = coveredDepths($from, tr4.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice2.openStart;
  for (var content5 = slice2.content, _i93 = 0; ; _i93++) {
    var node = content5.firstChild;
    leftNodes.push(node);
    if (_i93 == slice2.openStart)
      break;
    content5 = node.content;
  }
  for (var _d4 = preferredDepth - 1; _d4 >= 0; _d4--) {
    var leftNode = leftNodes[_d4], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = _d4;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (var j = slice2.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (var _i94 = 0; _i94 < targetDepths.length; _i94++) {
      var targetDepth = targetDepths[(_i94 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return tr4.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  var startSteps = tr4.steps.length;
  for (var _i95 = targetDepths.length - 1; _i95 >= 0; _i95--) {
    tr4.replace(from2, to, slice2);
    if (tr4.steps.length > startSteps)
      break;
    var depth = targetDepths[_i95];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var _first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, _first2.copy(closeFragment(_first2.content, depth + 1, oldOpen, newOpen, _first2)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var _start8 = match.fillBefore(fragment).append(fragment);
    fragment = _start8.append(match.matchFragment(_start8).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function _replaceRangeWith(tr4, from2, to, node) {
  if (!node.isInline && from2 == to && tr4.doc.resolve(from2).parent.content.size) {
    var point = insertPoint(tr4.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr4.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange$1(tr4, from2, to) {
  var $from = tr4.doc.resolve(from2), $to = tr4.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var _i96 = 0; _i96 < covered.length; _i96++) {
    var depth = covered[_i96], last = _i96 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr4.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr4.delete($from.before(depth), $to.after(depth));
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr4.delete($from.before(d), to);
  }
  tr4.delete(from2, to);
}
function coveredDepths($from, $to) {
  var result = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var _start9 = $from.start(d);
    if (_start9 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (_start9 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == _start9 - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = /* @__PURE__ */ function(_Step7) {
  _inheritsLoose(AttrStep2, _Step7);
  function AttrStep2(pos, attr, value) {
    var _this16;
    _this16 = _Step7.call(this) || this;
    _this16.pos = pos;
    _this16.attr = attr;
    _this16.value = value;
    return _this16;
  }
  var _proto26 = AttrStep2.prototype;
  _proto26.apply = function apply6(doc2) {
    var node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    var attrs = /* @__PURE__ */ Object.create(null);
    for (var name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    var updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  };
  _proto26.getMap = function getMap() {
    return StepMap.empty;
  };
  _proto26.invert = function invert(doc2) {
    return new AttrStep2(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  };
  _proto26.map = function map3(mapping) {
    var pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep2(pos.pos, this.attr, this.value);
  };
  _proto26.toJSON = function toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  };
  AttrStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.pos != "number" || typeof json2.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep2(json2.pos, json2.attr, json2.value);
  };
  return AttrStep2;
}(Step);
Step.jsonID("attr", AttrStep);
var DocAttrStep = /* @__PURE__ */ function(_Step8) {
  _inheritsLoose(DocAttrStep2, _Step8);
  function DocAttrStep2(attr, value) {
    var _this17;
    _this17 = _Step8.call(this) || this;
    _this17.attr = attr;
    _this17.value = value;
    return _this17;
  }
  var _proto27 = DocAttrStep2.prototype;
  _proto27.apply = function apply6(doc2) {
    var attrs = /* @__PURE__ */ Object.create(null);
    for (var name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    var updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  };
  _proto27.getMap = function getMap() {
    return StepMap.empty;
  };
  _proto27.invert = function invert(doc2) {
    return new DocAttrStep2(this.attr, doc2.attrs[this.attr]);
  };
  _proto27.map = function map3(mapping) {
    return this;
  };
  _proto27.toJSON = function toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  };
  DocAttrStep2.fromJSON = function fromJSON(schema, json2) {
    if (typeof json2.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep2(json2.attr, json2.value);
  };
  return DocAttrStep2;
}(Step);
Step.jsonID("docAttr", DocAttrStep);
var TransformError = /* @__PURE__ */ function(_Error2) {
  _inheritsLoose(TransformError3, _Error2);
  function TransformError3() {
    return _Error2.apply(this, arguments) || this;
  }
  return TransformError3;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
TransformError = function TransformError2(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = /* @__PURE__ */ function() {
  function Transform2(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  var _proto28 = Transform2.prototype;
  _proto28.step = function step(_step) {
    var result = this.maybeStep(_step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  };
  _proto28.maybeStep = function maybeStep(step) {
    var result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  };
  _proto28.addStep = function addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  };
  _proto28.replace = function replace(from2, to, slice2) {
    if (to === void 0) {
      to = from2;
    }
    if (slice2 === void 0) {
      slice2 = Slice.empty;
    }
    var step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  };
  _proto28.replaceWith = function replaceWith(from2, to, content5) {
    return this.replace(from2, to, new Slice(Fragment.from(content5), 0, 0));
  };
  _proto28.delete = function _delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  };
  _proto28.insert = function insert(pos, content5) {
    return this.replaceWith(pos, pos, content5);
  };
  _proto28.replaceRange = function replaceRange(from2, to, slice2) {
    _replaceRange(this, from2, to, slice2);
    return this;
  };
  _proto28.replaceRangeWith = function replaceRangeWith(from2, to, node) {
    _replaceRangeWith(this, from2, to, node);
    return this;
  };
  _proto28.deleteRange = function deleteRange3(from2, to) {
    deleteRange$1(this, from2, to);
    return this;
  };
  _proto28.lift = function lift3(range, target) {
    lift$2(this, range, target);
    return this;
  };
  _proto28.join = function join(pos, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    _join(this, pos, depth);
    return this;
  };
  _proto28.wrap = function wrap(range, wrappers) {
    _wrap4(this, range, wrappers);
    return this;
  };
  _proto28.setBlockType = function setBlockType2(from2, to, type, attrs) {
    if (to === void 0) {
      to = from2;
    }
    if (attrs === void 0) {
      attrs = null;
    }
    setBlockType$1(this, from2, to, type, attrs);
    return this;
  };
  _proto28.setNodeMarkup = function setNodeMarkup(pos, type, attrs, marks) {
    if (attrs === void 0) {
      attrs = null;
    }
    _setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  };
  _proto28.setNodeAttribute = function setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  };
  _proto28.setDocAttribute = function setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  };
  _proto28.addNodeMark = function addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  };
  _proto28.removeNodeMark = function removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark$1)) {
      var node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  };
  _proto28.split = function split(pos, depth, typesAfter) {
    if (depth === void 0) {
      depth = 1;
    }
    _split(this, pos, depth, typesAfter);
    return this;
  };
  _proto28.addMark = function addMark(from2, to, mark) {
    _addMark(this, from2, to, mark);
    return this;
  };
  _proto28.removeMark = function removeMark(from2, to, mark) {
    _removeMark(this, from2, to, mark);
    return this;
  };
  _proto28.clearIncompatible = function clearIncompatible(pos, parentType, match) {
    _clearIncompatible(this, pos, parentType, match);
    return this;
  };
  _createClass(Transform2, [{ key: "before", get: function get5() {
    return this.docs.length ? this.docs[0] : this.doc;
  } }, { key: "docChanged", get: function get5() {
    return this.steps.length > 0;
  } }]);
  return Transform2;
}();
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = /* @__PURE__ */ function() {
  function Selection2($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  var _proto29 = Selection2.prototype;
  _proto29.content = function content5() {
    return this.$from.doc.slice(this.from, this.to, true);
  };
  _proto29.replace = function replace(tr4, content5) {
    if (content5 === void 0) {
      content5 = Slice.empty;
    }
    var lastNode = content5.content.lastChild, lastParent = null;
    for (var _i97 = 0; _i97 < content5.openEnd; _i97++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    var mapFrom = tr4.steps.length, ranges = this.ranges;
    for (var _i98 = 0; _i98 < ranges.length; _i98++) {
      var _ranges$_i = ranges[_i98], $from = _ranges$_i.$from, $to = _ranges$_i.$to, mapping = tr4.mapping.slice(mapFrom);
      tr4.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i98 ? Slice.empty : content5);
      if (_i98 == 0)
        selectionToInsertionEnd$1(tr4, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  };
  _proto29.replaceWith = function replaceWith(tr4, node) {
    var mapFrom = tr4.steps.length, ranges = this.ranges;
    for (var _i99 = 0; _i99 < ranges.length; _i99++) {
      var _ranges$_i2 = ranges[_i99], $from = _ranges$_i2.$from, $to = _ranges$_i2.$to, mapping = tr4.mapping.slice(mapFrom);
      var _from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (_i99) {
        tr4.deleteRange(_from2, to);
      } else {
        tr4.replaceRangeWith(_from2, to, node);
        selectionToInsertionEnd$1(tr4, mapFrom, node.isInline ? -1 : 1);
      }
    }
  };
  Selection2.findFrom = function findFrom($pos, dir, textOnly) {
    if (textOnly === void 0) {
      textOnly = false;
    }
    var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (var depth = $pos.depth - 1; depth >= 0; depth--) {
      var _found6 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (_found6)
        return _found6;
    }
    return null;
  };
  Selection2.near = function near($pos, bias) {
    if (bias === void 0) {
      bias = 1;
    }
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  };
  Selection2.atStart = function atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  };
  Selection2.atEnd = function atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  };
  Selection2.fromJSON = function fromJSON(doc2, json2) {
    if (!json2 || !json2.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    var cls = classesById[json2.type];
    if (!cls)
      throw new RangeError("No selection type " + json2.type + " defined");
    return cls.fromJSON(doc2, json2);
  };
  Selection2.jsonID = function jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  };
  _proto29.getBookmark = function getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  };
  _createClass(Selection2, [{
    key: "anchor",
    get: function get5() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
  }, {
    key: "head",
    get: function get5() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
  }, {
    key: "from",
    get: function get5() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
  }, {
    key: "to",
    get: function get5() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
  }, {
    key: "$from",
    get: function get5() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
  }, {
    key: "$to",
    get: function get5() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
  }, { key: "empty", get: function get5() {
    var ranges = this.ranges;
    for (var _i100 = 0; _i100 < ranges.length; _i100++)
      if (ranges[_i100].$from.pos != ranges[_i100].$to.pos)
        return false;
    return true;
  } }]);
  return Selection2;
}();
Selection.prototype.visible = true;
var SelectionRange = (
  /**
  Create a range.
  */
  function SelectionRange2($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
);
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = /* @__PURE__ */ function(_Selection) {
  _inheritsLoose(TextSelection2, _Selection);
  function TextSelection2($anchor, $head) {
    if ($head === void 0) {
      $head = $anchor;
    }
    checkTextSelection($anchor);
    checkTextSelection($head);
    return _Selection.call(this, $anchor, $head) || this;
  }
  var _proto30 = TextSelection2.prototype;
  _proto30.map = function map3(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  _proto30.replace = function replace(tr4, content5) {
    if (content5 === void 0) {
      content5 = Slice.empty;
    }
    _Selection.prototype.replace.call(this, tr4, content5);
    if (content5 == Slice.empty) {
      var marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr4.ensureMarks(marks);
    }
  };
  _proto30.eq = function eq(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  _proto30.getBookmark = function getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  };
  _proto30.toJSON = function toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON(doc2, json2) {
    if (typeof json2.anchor != "number" || typeof json2.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection2(doc2.resolve(json2.anchor), doc2.resolve(json2.head));
  };
  TextSelection2.create = function create2(doc2, anchor, head) {
    if (head === void 0) {
      head = anchor;
    }
    var $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      var _found7 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (_found7)
        $head = _found7.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection2($anchor, $head);
  };
  _createClass(TextSelection2, [{ key: "$cursor", get: function get5() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  } }]);
  return TextSelection2;
}(Selection);
Selection.jsonID("text", TextSelection);
var TextBookmark = /* @__PURE__ */ function() {
  function TextBookmark2(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  var _proto31 = TextBookmark2.prototype;
  _proto31.map = function map3(mapping) {
    return new TextBookmark2(mapping.map(this.anchor), mapping.map(this.head));
  };
  _proto31.resolve = function resolve2(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  };
  return TextBookmark2;
}();
var NodeSelection = /* @__PURE__ */ function(_Selection2) {
  _inheritsLoose(NodeSelection2, _Selection2);
  function NodeSelection2($pos) {
    var _this18;
    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    _this18 = _Selection2.call(this, $pos, $end) || this;
    _this18.node = node;
    return _this18;
  }
  var _proto32 = NodeSelection2.prototype;
  _proto32.map = function map3(doc2, mapping) {
    var _mapping$mapResult = mapping.mapResult(this.anchor), deleted = _mapping$mapResult.deleted, pos = _mapping$mapResult.pos;
    var $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection2($pos);
  };
  _proto32.content = function content5() {
    return new Slice(Fragment.from(this.node), 0, 0);
  };
  _proto32.eq = function eq(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  _proto32.toJSON = function toJSON() {
    return { type: "node", anchor: this.anchor };
  };
  _proto32.getBookmark = function getBookmark() {
    return new NodeBookmark(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON(doc2, json2) {
    if (typeof json2.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection2(doc2.resolve(json2.anchor));
  };
  NodeSelection2.create = function create2(doc2, from2) {
    return new NodeSelection2(doc2.resolve(from2));
  };
  NodeSelection2.isSelectable = function isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection);
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = /* @__PURE__ */ function() {
  function NodeBookmark2(anchor) {
    this.anchor = anchor;
  }
  var _proto33 = NodeBookmark2.prototype;
  _proto33.map = function map3(mapping) {
    var _mapping$mapResult2 = mapping.mapResult(this.anchor), deleted = _mapping$mapResult2.deleted, pos = _mapping$mapResult2.pos;
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark2(pos);
  };
  _proto33.resolve = function resolve2(doc2) {
    var $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  };
  return NodeBookmark2;
}();
var AllSelection = /* @__PURE__ */ function(_Selection3) {
  _inheritsLoose(AllSelection2, _Selection3);
  function AllSelection2(doc2) {
    return _Selection3.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size)) || this;
  }
  var _proto34 = AllSelection2.prototype;
  _proto34.replace = function replace(tr4, content5) {
    if (content5 === void 0) {
      content5 = Slice.empty;
    }
    if (content5 == Slice.empty) {
      tr4.delete(0, tr4.doc.content.size);
      var sel = Selection.atStart(tr4.doc);
      if (!sel.eq(tr4.selection))
        tr4.setSelection(sel);
    } else {
      _Selection3.prototype.replace.call(this, tr4, content5);
    }
  };
  _proto34.toJSON = function toJSON() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON(doc2) {
    return new AllSelection2(doc2);
  };
  _proto34.map = function map3(doc2) {
    return new AllSelection2(doc2);
  };
  _proto34.eq = function eq(other) {
    return other instanceof AllSelection2;
  };
  _proto34.getBookmark = function getBookmark() {
    return AllBookmark;
  };
  return AllSelection2;
}(Selection);
Selection.jsonID("all", AllSelection);
var AllBookmark = { map: function map() {
  return this;
}, resolve: function resolve(doc2) {
  return new AllSelection(doc2);
} };
function findSelectionIn(doc2, node, pos, index, dir, text) {
  if (text === void 0) {
    text = false;
  }
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (var _i101 = index - (dir > 0 ? 0 : 1); dir > 0 ? _i101 < node.childCount : _i101 >= 0; _i101 += dir) {
    var child = node.child(_i101);
    if (!child.isAtom) {
      var inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$1(tr4, startLen, bias) {
  var last = tr4.steps.length - 1;
  if (last < startLen)
    return;
  var step = tr4.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  var map3 = tr4.mapping.maps[last], end2;
  map3.forEach(function(_from, _to, _newFrom, newTo) {
    if (end2 == null)
      end2 = newTo;
  });
  tr4.setSelection(Selection.near(tr4.doc.resolve(end2), bias));
}
var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
var Transaction = /* @__PURE__ */ function(_Transform) {
  _inheritsLoose(Transaction2, _Transform);
  function Transaction2(state) {
    var _this19;
    _this19 = _Transform.call(this, state.doc) || this;
    _this19.curSelectionFor = 0;
    _this19.updated = 0;
    _this19.meta = /* @__PURE__ */ Object.create(null);
    _this19.time = Date.now();
    _this19.curSelection = state.selection;
    _this19.storedMarks = state.storedMarks;
    return _this19;
  }
  var _proto35 = Transaction2.prototype;
  _proto35.setSelection = function setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  };
  _proto35.setStoredMarks = function setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  };
  _proto35.ensureMarks = function ensureMarks2(marks) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  };
  _proto35.addStoredMark = function addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  _proto35.removeStoredMark = function removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  _proto35.addStep = function addStep(step, doc2) {
    _Transform.prototype.addStep.call(this, step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };
  _proto35.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  _proto35.replaceSelection = function replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  };
  _proto35.replaceSelectionWith = function replaceSelectionWith(node, inheritMarks) {
    if (inheritMarks === void 0) {
      inheritMarks = true;
    }
    var selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    selection.replaceWith(this, node);
    return this;
  };
  _proto35.deleteSelection = function deleteSelection3() {
    this.selection.replace(this);
    return this;
  };
  _proto35.insertText = function insertText(text, from2, to) {
    var schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      var marks = this.storedMarks;
      if (!marks) {
        var $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  };
  _proto35.setMeta = function setMeta3(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  };
  _proto35.getMeta = function getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  };
  _proto35.scrollIntoView = function scrollIntoView3() {
    this.updated |= UPDATED_SCROLL;
    return this;
  };
  _createClass(Transaction2, [{ key: "selection", get: function get5() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  } }, { key: "selectionSet", get: function get5() {
    return (this.updated & UPDATED_SEL) > 0;
  } }, { key: "storedMarksSet", get: function get5() {
    return (this.updated & UPDATED_MARKS) > 0;
  } }, { key: "isGeneric", get: function get5() {
    for (var _ in this.meta)
      return false;
    return true;
  } }, { key: "scrolledIntoView", get: function get5() {
    return (this.updated & UPDATED_SCROLL) > 0;
  } }]);
  return Transaction2;
}(Transform);
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
var FieldDesc = function FieldDesc2(name, desc, self) {
  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
};
var baseFields = [new FieldDesc("doc", { init: function init(config) {
  return config.doc || config.schema.topNodeType.createAndFill();
}, apply: function apply(tr4) {
  return tr4.doc;
} }), new FieldDesc("selection", { init: function init2(config, instance) {
  return config.selection || Selection.atStart(instance.doc);
}, apply: function apply2(tr4) {
  return tr4.selection;
} }), new FieldDesc("storedMarks", { init: function init3(config) {
  return config.storedMarks || null;
}, apply: function apply3(tr4, _marks, _old, state) {
  return state.selection.$cursor ? tr4.storedMarks : null;
} }), new FieldDesc("scrollToSelection", { init: function init4() {
  return 0;
}, apply: function apply4(tr4, prev) {
  return tr4.scrolledIntoView ? prev + 1 : prev;
} })];
var Configuration = function Configuration2(schema, plugins) {
  var _this20 = this;
  this.schema = schema;
  this.plugins = [];
  this.pluginsByKey = /* @__PURE__ */ Object.create(null);
  this.fields = baseFields.slice();
  if (plugins)
    plugins.forEach(function(plugin) {
      if (_this20.pluginsByKey[plugin.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      _this20.plugins.push(plugin);
      _this20.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state)
        _this20.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
    });
};
var EditorState = /* @__PURE__ */ function() {
  function EditorState2(config) {
    this.config = config;
  }
  var _proto36 = EditorState2.prototype;
  _proto36.apply = function apply6(tr4) {
    return this.applyTransaction(tr4).state;
  };
  _proto36.filterTransaction = function filterTransaction(tr4, ignore) {
    if (ignore === void 0) {
      ignore = -1;
    }
    for (var _i102 = 0; _i102 < this.config.plugins.length; _i102++)
      if (_i102 != ignore) {
        var plugin = this.config.plugins[_i102];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr4, this))
          return false;
      }
    return true;
  };
  _proto36.applyTransaction = function applyTransaction2(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      var haveNew = false;
      for (var _i103 = 0; _i103 < this.config.plugins.length; _i103++) {
        var plugin = this.config.plugins[_i103];
        if (plugin.spec.appendTransaction) {
          var n = seen ? seen[_i103].n : 0, oldState = seen ? seen[_i103].state : this;
          var _tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (_tr && newState.filterTransaction(_tr, _i103)) {
            _tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (var j = 0; j < this.config.plugins.length; j++)
                seen.push(j < _i103 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(_tr);
            newState = newState.applyInner(_tr);
            haveNew = true;
          }
          if (seen)
            seen[_i103] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  };
  _proto36.applyInner = function applyInner(tr4) {
    if (!tr4.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    var newInstance = new EditorState2(this.config), fields = this.config.fields;
    for (var _i104 = 0; _i104 < fields.length; _i104++) {
      var field = fields[_i104];
      newInstance[field.name] = field.apply(tr4, this[field.name], this, newInstance);
    }
    return newInstance;
  };
  EditorState2.create = function create2(config) {
    var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    var instance = new EditorState2($config);
    for (var _i105 = 0; _i105 < $config.fields.length; _i105++)
      instance[$config.fields[_i105].name] = $config.fields[_i105].init(config, instance);
    return instance;
  };
  _proto36.reconfigure = function reconfigure(config) {
    var $config = new Configuration(this.schema, config.plugins);
    var fields = $config.fields, instance = new EditorState2($config);
    for (var _i106 = 0; _i106 < fields.length; _i106++) {
      var name = fields[_i106].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[_i106].init(config, instance);
    }
    return instance;
  };
  _proto36.toJSON = function toJSON(pluginFields) {
    var result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map(function(m) {
        return m.toJSON();
      });
    if (pluginFields && typeof pluginFields == "object")
      for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        var plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  };
  EditorState2.fromJSON = function fromJSON(config, json2, pluginFields) {
    if (!json2)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    var $config = new Configuration(config.schema, config.plugins);
    var instance = new EditorState2($config);
    $config.fields.forEach(function(field) {
      if (field.name == "doc") {
        instance.doc = Node$1.fromJSON(config.schema, json2.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json2.selection);
      } else if (field.name == "storedMarks") {
        if (json2.storedMarks)
          instance.storedMarks = json2.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (var prop in pluginFields) {
            var plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json2, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json2[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  };
  _createClass(EditorState2, [{
    key: "schema",
    get: function get5() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
  }, { key: "plugins", get: function get5() {
    return this.config.plugins;
  } }, { key: "tr", get: function get5() {
    return new Transaction(this);
  } }]);
  return EditorState2;
}();
function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = /* @__PURE__ */ function() {
  function Plugin2(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  var _proto37 = Plugin2.prototype;
  _proto37.getState = function getState(state) {
    return state[this.key];
  };
  return Plugin2;
}();
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = /* @__PURE__ */ function() {
  function PluginKey2(name) {
    if (name === void 0) {
      name = "key";
    }
    this.key = createKey(name);
  }
  var _proto38 = PluginKey2.prototype;
  _proto38.get = function get5(state) {
    return state.config.pluginsByKey[this.key];
  };
  _proto38.getState = function getState(state) {
    return state[this.key];
  };
  return PluginKey2;
}();
var domIndex = function domIndex2(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
var parentNode = function parentNode2(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function textRange2(node, from2, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var isEquivalentPosition = function isEquivalentPosition2(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset2, parent) {
  for (var atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    var index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function selectionCollapsed2(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  var elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y) {
  if (doc2.caretPositionFromPoint) {
    try {
      var pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: pos.offset };
    } catch (_) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    var range = doc2.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: range.startOffset };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  return { left: 0, right: doc2.documentElement.clientWidth, top: 0, bottom: doc2.documentElement.clientHeight };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  var rect = node.getBoundingClientRect();
  var scaleX = rect.width / node.offsetWidth || 1;
  var scaleY = rect.height / node.offsetHeight || 1;
  return { left: rect.left, right: rect.left + node.clientWidth * scaleX, top: rect.top, bottom: rect.top + node.clientHeight * scaleY };
}
function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc2 = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    var elt = parent;
    var atTop = elt == doc2.body;
    var bounding = atTop ? windowRect(doc2) : clientRect(elt);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        var dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  var stack = [], doc2 = dom.ownerDocument;
  for (var cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack;
}
function resetScrollPos(_ref8) {
  var refDOM = _ref8.refDOM, refTop = _ref8.refTop, stack = _ref8.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var _i107 = 0; _i107 < stack.length; _i107++) {
    var _stack$_i = stack[_i107], dom = _stack$_i.dom, _top3 = _stack$_i.top, _left = _stack$_i.left;
    if (dom.scrollTop != _top3 + dTop)
      dom.scrollTop = _top3 + dTop;
    if (dom.scrollLeft != _left)
      dom.scrollLeft = _left;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? { get preventScroll() {
    preventScrollSupported = { preventScroll: true };
    return true;
  } } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  var firstBelow, coordsBelow;
  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = void 0;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (var _i108 = 0; _i108 < rects.length; _i108++) {
      var rect = rects[_i108];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();
  for (var _i109 = 0; _i109 < len; _i109++) {
    range.setEnd(node, _i109 + 1);
    range.setStart(node, _i109);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: _i109 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  var _findOffsetInNode = findOffsetInNode(elt, coords), node = _findOffsetInNode.node, offset2 = _findOffsetInNode.offset, bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  var outsideBlock = -1;
  for (var cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
      var rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent && !sawBlock) {
        sawBlock = true;
        if (rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        var before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), _i110 = startI; ; ) {
      var child = element.childNodes[_i110];
      if (child.nodeType == 1) {
        var rects = child.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((_i110 = (_i110 + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function _posAtCoords(view, coords) {
  var doc2 = view.dom.ownerDocument, node, offset2 = 0;
  var caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret) {
    node = caret.node;
    offset2 = caret.offset;
  }
  var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  var pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (var p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        var next = node.childNodes[offset2], _box2;
        if (next.nodeName == "IMG" && (_box2 = next.getBoundingClientRect()).right <= coords.left && _box2.bottom > coords.top)
          offset2++;
      }
    }
    var prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  var rects = target.getClientRects();
  if (rects.length) {
    var _first3 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(_first3))
      return _first3;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function _coordsAtPos(view, pos, side) {
  var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1), node = _view$docView$domFrom.node, offset2 = _view$docView$domFrom.offset, atom = _view$docView$domFrom.atom;
  var supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      var _from3 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        _from3--;
        takeSide = 1;
      } else if (side < 0) {
        _from3--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, _from3, to), takeSide), takeSide < 0);
    }
  }
  var $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      var before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      var after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    var _before = node.childNodes[offset2 - 1];
    var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node)) {
    var _after2 = node.childNodes[offset2];
    while (_after2.pmViewDesc && _after2.pmViewDesc.ignoreForCoords)
      _after2 = _after2.nextSibling;
    var _target = !_after2 ? null : _after2.nodeType == 3 ? textRange(_after2, 0, supportEmptyRange ? 0 : 1) : _after2.nodeType == 1 ? _after2 : null;
    if (_target)
      return flattenV(singleRect(_target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  var x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  var y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function() {
    var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1), dom = _view$docView$domFrom2.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = _coordsAtPos(view, $pos.pos, 1);
    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = void 0;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (var _i111 = 0; _i111 < boxes.length; _i111++) {
        var box = boxes[_i111];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  var $head = state.selection.$head;
  if (!$head.parent.isTextblock)
    return false;
  var offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  var sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, function() {
    var _view$domSelectionRan = view.domSelectionRange(), oldNode = _view$domSelectionRan.focusNode, oldOff = _view$domSelectionRan.focusOffset, anchorNode = _view$domSelectionRan.anchorNode, anchorOffset = _view$domSelectionRan.anchorOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var _view$domSelectionRan2 = view.domSelectionRange(), newNode3 = _view$domSelectionRan2.focusNode, newOff = _view$domSelectionRan2.focusOffset;
    var result = newNode3 && !parentDOM.contains(newNode3.nodeType == 1 ? newNode3 : newNode3.parentNode) || oldNode == newNode3 && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function _endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
var ViewDesc = /* @__PURE__ */ function() {
  function ViewDesc2(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  var _proto39 = ViewDesc2.prototype;
  _proto39.matchesWidget = function matchesWidget(widget) {
    return false;
  };
  _proto39.matchesMark = function matchesMark(mark) {
    return false;
  };
  _proto39.matchesNode = function matchesNode(node, outerDeco, innerDeco) {
    return false;
  };
  _proto39.matchesHack = function matchesHack(nodeName) {
    return false;
  };
  _proto39.parseRule = function parseRule() {
    return null;
  };
  _proto39.stopEvent = function stopEvent(event) {
    return false;
  };
  _proto39.destroy = function destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (var _i112 = 0; _i112 < this.children.length; _i112++)
      this.children[_i112].destroy();
  };
  _proto39.posBeforeChild = function posBeforeChild(child) {
    for (var _i113 = 0, pos = this.posAtStart; ; _i113++) {
      var cur = this.children[_i113];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  };
  _proto39.localPosFromDOM = function localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        var domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        var domAfter, _desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
      }
    }
    var atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (var search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (var _search = dom; ; _search = _search.parentNode) {
          if (_search == this.dom) {
            atEnd = true;
            break;
          }
          if (_search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  };
  _proto39.nearestDesc = function nearestDesc(dom, onlyNodes) {
    if (onlyNodes === void 0) {
      onlyNodes = false;
    }
    for (var _first4 = true, cur = dom; cur; cur = cur.parentNode) {
      var desc = this.getDesc(cur), nodeDOM = void 0;
      if (desc && (!onlyNodes || desc.node)) {
        if (_first4 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          _first4 = false;
        else
          return desc;
      }
    }
  };
  _proto39.getDesc = function getDesc(dom) {
    var desc = dom.pmViewDesc;
    for (var cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  };
  _proto39.posFromDOM = function posFromDOM(dom, offset2, bias) {
    for (var scan = dom; scan; scan = scan.parentNode) {
      var desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  };
  _proto39.descAt = function descAt(pos) {
    for (var _i114 = 0, _offset4 = 0; _i114 < this.children.length; _i114++) {
      var child = this.children[_i114], _end11 = _offset4 + child.size;
      if (_offset4 == pos && _end11 != _offset4) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < _end11)
        return child.descAt(pos - _offset4 - child.border);
      _offset4 = _end11;
    }
  };
  _proto39.domFromPos = function domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    var i = 0, offset2 = 0;
    for (var curPos = 0; i < this.children.length; i++) {
      var child = this.children[i], _end12 = curPos + child.size;
      if (_end12 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = _end12;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      var _prev, _enter = true;
      for (; ; i--, _enter = false) {
        _prev = i ? this.children[i - 1] : null;
        if (!_prev || _prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (_prev && side && _enter && !_prev.border && !_prev.domAtom)
        return _prev.domFromPos(_prev.size, side);
      return { node: this.contentDOM, offset: _prev ? domIndex(_prev.dom) + 1 : 0 };
    } else {
      var next, _enter2 = true;
      for (; ; i++, _enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && _enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  };
  _proto39.parseRange = function parseRange(from2, to, base2) {
    if (base2 === void 0) {
      base2 = 0;
    }
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    var fromOffset = -1, toOffset = -1;
    for (var _offset5 = base2, _i115 = 0; ; _i115++) {
      var child = this.children[_i115], _end13 = _offset5 + child.size;
      if (fromOffset == -1 && from2 <= _end13) {
        var childBase = _offset5 + child.border;
        if (from2 >= childBase && to <= _end13 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = _offset5;
        for (var j = _i115; j > 0; j--) {
          var prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (_end13 > to || _i115 == this.children.length - 1)) {
        to = _end13;
        for (var _j2 = _i115 + 1; _j2 < this.children.length; _j2++) {
          var next = this.children[_j2];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      _offset5 = _end13;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  };
  _proto39.emptyChildAt = function emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    var child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  };
  _proto39.domAfterPos = function domAfterPos(pos) {
    var _this$domFromPos = this.domFromPos(pos, 0), node = _this$domFromPos.node, offset2 = _this$domFromPos.offset;
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  };
  _proto39.setSelection = function setSelection(anchor, head, root, force) {
    if (force === void 0) {
      force = false;
    }
    var from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (var _i116 = 0, _offset6 = 0; _i116 < this.children.length; _i116++) {
      var child = this.children[_i116], _end14 = _offset6 + child.size;
      if (from2 > _offset6 && to < _end14)
        return child.setSelection(anchor - _offset6 - child.border, head - _offset6 - child.border, root, force);
      _offset6 = _end14;
    }
    var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    var domSel = root.getSelection();
    var brKludge = false;
    if ((gecko || safari) && anchor == head) {
      var _anchorDOM = anchorDOM, node = _anchorDOM.node, _offset7 = _anchorDOM.offset;
      if (node.nodeType == 3) {
        brKludge = !!(_offset7 && node.nodeValue[_offset7 - 1] == "\n");
        if (brKludge && _offset7 == node.nodeValue.length) {
          for (var scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            var desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        var prev = node.childNodes[_offset7 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      var _after3 = domSel.focusNode.childNodes[domSel.focusOffset];
      if (_after3 && _after3.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    var domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        var tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      var range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  };
  _proto39.ignoreMutation = function ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  };
  _proto39.markDirty = function markDirty(from2, to) {
    for (var _offset8 = 0, _i117 = 0; _i117 < this.children.length; _i117++) {
      var child = this.children[_i117], _end15 = _offset8 + child.size;
      if (_offset8 == _end15 ? from2 <= _end15 && to >= _offset8 : from2 < _end15 && to > _offset8) {
        var startInside = _offset8 + child.border, endInside = _end15 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == _offset8 || to == _end15 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      _offset8 = _end15;
    }
    this.dirty = CONTENT_DIRTY;
  };
  _proto39.markParentsDirty = function markParentsDirty() {
    var level = 1;
    for (var node = this.parent; node; node = node.parent, level++) {
      var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  };
  _createClass(ViewDesc2, [{
    key: "size",
    get: function get5() {
      var size = 0;
      for (var _i118 = 0; _i118 < this.children.length; _i118++)
        size += this.children[_i118].size;
      return size;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
  }, { key: "border", get: function get5() {
    return 0;
  } }, { key: "posBefore", get: function get5() {
    return this.parent.posBeforeChild(this);
  } }, { key: "posAtStart", get: function get5() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  } }, { key: "posAfter", get: function get5() {
    return this.posBefore + this.size;
  } }, { key: "posAtEnd", get: function get5() {
    return this.posAtStart + this.size - 2 * this.border;
  } }, { key: "contentLost", get: function get5() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  } }, { key: "domAtom", get: function get5() {
    return false;
  } }, { key: "ignoreForCoords", get: function get5() {
    return false;
  } }]);
  return ViewDesc2;
}();
var WidgetViewDesc = /* @__PURE__ */ function(_ViewDesc) {
  _inheritsLoose(WidgetViewDesc2, _ViewDesc);
  function WidgetViewDesc2(parent, widget, view, pos) {
    var _this21;
    var self, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, function() {
        if (!self)
          return pos;
        if (self.parent)
          return self.parent.posBeforeChild(self);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    _this21 = _ViewDesc.call(this, parent, [], dom, null) || this;
    _this21.widget = widget;
    _this21.widget = widget;
    self = _assertThisInitialized(_this21);
    return _this21;
  }
  var _proto40 = WidgetViewDesc2.prototype;
  _proto40.matchesWidget = function matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  };
  _proto40.parseRule = function parseRule() {
    return { ignore: true };
  };
  _proto40.stopEvent = function stopEvent(event) {
    var stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  };
  _proto40.ignoreMutation = function ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  };
  _proto40.destroy = function destroy() {
    this.widget.type.destroy(this.dom);
    _ViewDesc.prototype.destroy.call(this);
  };
  _createClass(WidgetViewDesc2, [{ key: "domAtom", get: function get5() {
    return true;
  } }, { key: "side", get: function get5() {
    return this.widget.type.side;
  } }]);
  return WidgetViewDesc2;
}(ViewDesc);
var CompositionViewDesc = /* @__PURE__ */ function(_ViewDesc2) {
  _inheritsLoose(CompositionViewDesc2, _ViewDesc2);
  function CompositionViewDesc2(parent, dom, textDOM, text) {
    var _this22;
    _this22 = _ViewDesc2.call(this, parent, [], dom, null) || this;
    _this22.textDOM = textDOM;
    _this22.text = text;
    return _this22;
  }
  var _proto41 = CompositionViewDesc2.prototype;
  _proto41.localPosFromDOM = function localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  };
  _proto41.domFromPos = function domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  };
  _proto41.ignoreMutation = function ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  };
  _createClass(CompositionViewDesc2, [{ key: "size", get: function get5() {
    return this.text.length;
  } }]);
  return CompositionViewDesc2;
}(ViewDesc);
var MarkViewDesc = /* @__PURE__ */ function(_ViewDesc3) {
  _inheritsLoose(MarkViewDesc2, _ViewDesc3);
  function MarkViewDesc2(parent, mark, dom, contentDOM) {
    var _this23;
    _this23 = _ViewDesc3.call(this, parent, [], dom, contentDOM) || this;
    _this23.mark = mark;
    return _this23;
  }
  MarkViewDesc2.create = function create2(parent, mark, inline2, view) {
    var custom = view.nodeViews[mark.type.name];
    var spec = custom && custom(mark, view, inline2);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline2));
    return new MarkViewDesc2(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  };
  var _proto42 = MarkViewDesc2.prototype;
  _proto42.parseRule = function parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  _proto42.matchesMark = function matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  };
  _proto42.markDirty = function markDirty(from2, to) {
    _ViewDesc3.prototype.markDirty.call(this, from2, to);
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  };
  _proto42.slice = function slice2(from2, to, view) {
    var copy2 = MarkViewDesc2.create(this.parent, this.mark, true, view);
    var nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (var _i119 = 0; _i119 < nodes.length; _i119++)
      nodes[_i119].parent = copy2;
    copy2.children = nodes;
    return copy2;
  };
  return MarkViewDesc2;
}(ViewDesc);
var NodeViewDesc = /* @__PURE__ */ function(_ViewDesc4) {
  _inheritsLoose(NodeViewDesc2, _ViewDesc4);
  function NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    var _this24;
    _this24 = _ViewDesc4.call(this, parent, [], dom, contentDOM) || this;
    _this24.node = node;
    _this24.outerDeco = outerDeco;
    _this24.innerDeco = innerDeco;
    _this24.nodeDOM = nodeDOM;
    return _this24;
  }
  NodeViewDesc2.create = function create2(parent, node, outerDeco, innerDeco, view, pos) {
    var custom = view.nodeViews[node.type.name], descObj;
    var spec = custom && custom(node, view, function() {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      var _DOMSerializer$render3 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node));
      dom = _DOMSerializer$render3.dom;
      contentDOM = _DOMSerializer$render3.contentDOM;
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    var nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  };
  var _proto43 = NodeViewDesc2.prototype;
  _proto43.parseRule = function parseRule() {
    var _this25 = this;
    if (this.node.type.spec.reparseInView)
      return null;
    var rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = function() {
        return _this25.node.content;
      };
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (var _i120 = this.children.length - 1; _i120 >= 0; _i120--) {
        var child = this.children[_i120];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = function() {
          return Fragment.empty;
        };
    }
    return rule;
  };
  _proto43.matchesNode = function matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  _proto43.updateChildren = function updateChildren(view, pos) {
    var _this26 = this;
    var inline2 = this.node.inlineContent, off = pos;
    var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, function(widget, i, insideNode) {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline2, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == _this26.node.childCount ? Mark$1.none : _this26.node.child(i).marks, inline2, view);
      updater.placeWidget(widget, view, off);
    }, function(child, outerDeco, innerDeco, i) {
      updater.syncToMarks(child.marks, inline2, view);
      var compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline2, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  };
  _proto43.localCompositionInfo = function localCompositionInfo(view, pos) {
    var _view$state$selection = view.state.selection, from2 = _view$state$selection.from, to = _view$state$selection.to;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    var sel = view.domSelectionRange();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      var text = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  };
  _proto43.protectLocalComposition = function protectLocalComposition(view, _ref9) {
    var node = _ref9.node, pos = _ref9.pos, text = _ref9.text;
    if (this.getDesc(node))
      return;
    var topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    var desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  };
  _proto43.update = function update2(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  };
  _proto43.updateInner = function updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  };
  _proto43.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  _proto43.selectNode = function selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  };
  _proto43.deselectNode = function deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  };
  _createClass(NodeViewDesc2, [{ key: "size", get: function get5() {
    return this.node.nodeSize;
  } }, { key: "border", get: function get5() {
    return this.node.isLeaf ? 0 : 1;
  } }, { key: "domAtom", get: function get5() {
    return this.node.isAtom;
  } }]);
  return NodeViewDesc2;
}(ViewDesc);
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  var docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = /* @__PURE__ */ function(_NodeViewDesc) {
  _inheritsLoose(TextViewDesc2, _NodeViewDesc);
  function TextViewDesc2(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    return _NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0) || this;
  }
  var _proto44 = TextViewDesc2.prototype;
  _proto44.parseRule = function parseRule() {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  };
  _proto44.update = function update2(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  };
  _proto44.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  };
  _proto44.domFromPos = function domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  _proto44.localPosFromDOM = function localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return _NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset2, bias);
  };
  _proto44.ignoreMutation = function ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  };
  _proto44.slice = function slice2(from2, to, view) {
    var node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new TextViewDesc2(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  };
  _proto44.markDirty = function markDirty(from2, to) {
    _NodeViewDesc.prototype.markDirty.call(this, from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  };
  _createClass(TextViewDesc2, [{ key: "domAtom", get: function get5() {
    return false;
  } }]);
  return TextViewDesc2;
}(NodeViewDesc);
var TrailingHackViewDesc = /* @__PURE__ */ function(_ViewDesc5) {
  _inheritsLoose(TrailingHackViewDesc2, _ViewDesc5);
  function TrailingHackViewDesc2() {
    return _ViewDesc5.apply(this, arguments) || this;
  }
  var _proto45 = TrailingHackViewDesc2.prototype;
  _proto45.parseRule = function parseRule() {
    return { ignore: true };
  };
  _proto45.matchesHack = function matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  };
  _createClass(TrailingHackViewDesc2, [{ key: "domAtom", get: function get5() {
    return true;
  } }, { key: "ignoreForCoords", get: function get5() {
    return this.dom.nodeName == "IMG";
  } }]);
  return TrailingHackViewDesc2;
}(ViewDesc);
var CustomNodeViewDesc = /* @__PURE__ */ function(_NodeViewDesc2) {
  _inheritsLoose(CustomNodeViewDesc2, _NodeViewDesc2);
  function CustomNodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    var _this27;
    _this27 = _NodeViewDesc2.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) || this;
    _this27.spec = spec;
    return _this27;
  }
  var _proto46 = CustomNodeViewDesc2.prototype;
  _proto46.update = function update2(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      var result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return _NodeViewDesc2.prototype.update.call(this, node, outerDeco, innerDeco, view);
    }
  };
  _proto46.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : _NodeViewDesc2.prototype.selectNode.call(this);
  };
  _proto46.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : _NodeViewDesc2.prototype.deselectNode.call(this);
  };
  _proto46.setSelection = function setSelection(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
  };
  _proto46.destroy = function destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    _NodeViewDesc2.prototype.destroy.call(this);
  };
  _proto46.stopEvent = function stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  _proto46.ignoreMutation = function ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc);
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var _i121 = 0; _i121 < descs.length; _i121++) {
    var desc = descs[_i121], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function OuterDecoLevel2(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  var top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (var _i122 = 0; _i122 < outerDeco.length; _i122++) {
    var attrs = outerDeco[_i122].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  var curDOM = nodeDOM;
  for (var _i123 = 0; _i123 < curComputed.length; _i123++) {
    var deco = curComputed[_i123], prev = prevComputed[_i123];
    if (_i123) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (var name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (var _name3 in cur)
    if (_name3 != "class" && _name3 != "style" && _name3 != "nodeName" && cur[_name3] != prev[_name3])
      dom.setAttribute(_name3, cur[_name3]);
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (var _i124 = 0; _i124 < prevList.length; _i124++)
      if (curList.indexOf(prevList[_i124]) == -1)
        dom.classList.remove(prevList[_i124]);
    for (var _i125 = 0; _i125 < curList.length; _i125++)
      if (prevList.indexOf(curList[_i125]) == -1)
        dom.classList.add(curList[_i125]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (var _i126 = 0; _i126 < a.length; _i126++)
    if (!a[_i126].type.eq(b[_i126].type))
      return false;
  return true;
}
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = /* @__PURE__ */ function() {
  function ViewTreeUpdater2(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  var _proto47 = ViewTreeUpdater2.prototype;
  _proto47.destroyBetween = function destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (var _i127 = start2; _i127 < end2; _i127++)
      this.top.children[_i127].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  };
  _proto47.destroyRest = function destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  };
  _proto47.syncToMarks = function syncToMarks(marks, inline2, view) {
    var keep = 0, depth = this.stack.length >> 1;
    var maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      var _found8 = -1;
      for (var _i128 = this.index; _i128 < Math.min(this.index + 3, this.top.children.length); _i128++) {
        var next = this.top.children[_i128];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          _found8 = _i128;
          break;
        }
      }
      if (_found8 > -1) {
        if (_found8 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, _found8);
        }
        this.top = this.top.children[this.index];
      } else {
        var markDesc = MarkViewDesc.create(this.top, marks[depth], inline2, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  };
  _proto47.findNodeMatch = function findNodeMatch(node, outerDeco, innerDeco, index) {
    var found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (var _i129 = this.index, e = Math.min(this.top.children.length, _i129 + 5); _i129 < e; _i129++) {
        var child = this.top.children[_i129];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = _i129;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  };
  _proto47.updateNodeAt = function updateNodeAt(node, outerDeco, innerDeco, index, view) {
    var child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  };
  _proto47.findIndexWithChild = function findIndexWithChild(domNode) {
    for (; ; ) {
      var parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        var desc = domNode.pmViewDesc;
        if (desc)
          for (var _i130 = this.index; _i130 < this.top.children.length; _i130++) {
            if (this.top.children[_i130] == desc)
              return _i130;
          }
        return -1;
      }
      domNode = parent;
    }
  };
  _proto47.updateNextNode = function updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (var _i131 = this.index; _i131 < this.top.children.length; _i131++) {
      var next = this.top.children[_i131];
      if (next instanceof NodeViewDesc) {
        var _preMatch = this.preMatch.matched.get(next);
        if (_preMatch != null && _preMatch != index)
          return false;
        var nextDOM = next.dom, updated = void 0;
        var locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, _i131);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  };
  _proto47.recreateWrapper = function recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content))
      return null;
    var wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (var _iterator = _createForOfIteratorHelperLoose(wrapper.children), _step2; !(_step2 = _iterator()).done; ) {
        var ch = _step2.value;
        ch.parent = wrapper;
      }
    }
    next.destroy();
    return wrapper;
  };
  _proto47.addNode = function addNode2(node, outerDeco, innerDeco, view, pos) {
    var desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  };
  _proto47.placeWidget = function placeWidget(widget, view, pos) {
    var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      var desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  };
  _proto47.addTextblockHacks = function addTextblockHacks() {
    var lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  };
  _proto47.addHackNode = function addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      var dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      var hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  };
  _proto47.isLocked = function isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  };
  return ViewTreeUpdater2;
}();
function preMatch(frag, parentDesc) {
  var curDesc = parentDesc, descI = curDesc.children.length;
  var fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      var desc = void 0;
      for (; ; ) {
        if (descI) {
          var next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      var node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (var _i132 = 0; _i132 < parent.childCount; _i132++) {
      var child = parent.child(_i132);
      onNode(child, locals, deco.forChild(offset2, child), _i132);
      offset2 += child.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    var widget = void 0, widgets = void 0;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      var next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (var _i133 = 0; _i133 < widgets.length; _i133++)
          onWidget(widgets[_i133], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    var _child = void 0, index = void 0;
    if (restNode) {
      index = -1;
      _child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      _child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var _i134 = 0; _i134 < active.length; _i134++)
      if (active[_i134].to <= offset2)
        active.splice(_i134--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    var _end16 = offset2 + _child.nodeSize;
    if (_child.isText) {
      var cutAt = _end16;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (var _i135 = 0; _i135 < active.length; _i135++)
        if (active[_i135].to < cutAt)
          cutAt = active[_i135].to;
      if (cutAt < _end16) {
        restNode = _child.cut(cutAt - offset2);
        _child = _child.cut(0, cutAt - offset2);
        _end16 = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to <= _end16)
        decoIndex++;
    }
    var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function(d) {
      return !d.inline;
    }) : active.slice();
    onNode(_child, outerDeco, deco.forChild(offset2, _child), index);
    offset2 = _end16;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.childNodes.length > offset2 && node.childNodes[offset2].nodeType == 3)
        return node.childNodes[offset2];
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      node = node.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (var _i136 = 0, pos = 0; _i136 < frag.childCount && pos <= to; ) {
    var child = frag.child(_i136++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    var str = child.text;
    while (_i136 < frag.childCount) {
      var next = frag.child(_i136++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      var _found9 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (_found9 >= 0 && _found9 + text.length + childStart >= from2)
        return childStart + _found9;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  var result = [];
  for (var _i137 = 0, off = 0; _i137 < nodes.length; _i137++) {
    var child = nodes[_i137], _start10 = off, _end17 = off += child.size;
    if (_start10 >= to || _end17 <= from2) {
      result.push(child);
    } else {
      if (_start10 < from2)
        result.push(child.slice(0, from2 - _start10, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (_end17 > to)
        result.push(child.slice(to - _start10, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin) {
  if (origin === void 0) {
    origin = null;
  }
  var domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    var nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force) {
  if (force === void 0) {
    force = false;
  }
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    var domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor, head = sel.head, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0), node = _view$docView$domFrom3.node, offset2 = _view$docView$domFrom3.offset;
  var after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  var before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  var doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  var domSel = view.domSelectionRange();
  var node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = function() {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  var domSel = view.domSelection(), range = document.createRange();
  var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setEnd(node.parentNode, domIndex(node) + 1);
  else
    range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f) {
    return f(view, $anchor, $head);
  }) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  var sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  var _state$selection = state.selection, $anchor = _state$selection.$anchor, $head = _state$selection.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply5(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      var $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply5(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply5(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      var _$head = sel.$head, _node = _$head.textOffset ? null : dir < 0 ? _$head.nodeBefore : _$head.nodeAfter, desc;
      if (!_node || _node.isText)
        return false;
      var nodePos = dir < 0 ? _$head.pos - _node.nodeSize : _$head.pos;
      if (!(_node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(_node)) {
        return apply5(view, new NodeSelection(dir < 0 ? view.state.doc.resolve(_$head.pos - _node.nodeSize) : _$head));
      } else if (webkit) {
        return apply5(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + _node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply5(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var _next3 = moveSelectionBlock(view.state, dir);
    if (_next3)
      return apply5(view, _next3);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  var sel = view.domSelectionRange();
  var node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  var moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        var before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      var prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  var sel = view.domSelectionRange();
  var node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  var len = nodeLen(node);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      var after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      var next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    var next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    var next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    var before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  var sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  var $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    var coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      var before = view.coordsAtPos(pos - 1);
      var mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      var after = view.coordsAtPos(pos + 1);
      var _mid = (after.top + after.bottom) / 2;
      if (_mid > coords.top && _mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  var computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  var $from = sel.$from, $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply5(view, next);
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply5(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  var _view$state$selection2 = view.state.selection, $head = _view$state$selection2.$head, $anchor = _view$state$selection2.$anchor, empty2 = _view$state$selection2.empty;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var _tr2 = view.state.tr;
    if (dir < 0)
      _tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      _tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(_tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  var _view$domSelectionRan3 = view.domSelectionRange(), focusNode = _view$domSelectionRan3.focusNode, focusOffset = _view$domSelectionRan3.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(function() {
      return switchEditable(view, child, "false");
    }, 20);
  }
  return false;
}
function getMods(event) {
  var result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac$2 && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac$2 && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac$2 && code == 66 && mods == "c") {
    var dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac$2 && code == 70 && mods == "c") {
    var _dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, _dir, mods) || skipIgnoredNodes(view, _dir);
  } else if (code == 38 || mac$2 && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac$2 && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", function(f) {
    slice2 = f(slice2, view);
  });
  var context = [], _slice2 = slice2, content5 = _slice2.content, openStart = _slice2.openStart, openEnd = _slice2.openEnd;
  while (openStart > 1 && openEnd > 1 && content5.childCount == 1 && content5.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content5.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content5 = node.content;
  }
  var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  var doc2 = detachedDoc(), wrap = doc2.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content5, { document: doc2 }));
  var firstChild = wrap.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var _i138 = needsWrap.length - 1; _i138 >= 0; _i138--) {
      var wrapper = doc2.createElement(needsWrap[_i138]);
      while (wrap.firstChild)
        wrapper.appendChild(wrap.firstChild);
      wrap.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + (wrappers ? " -" + wrappers : "") + " " + JSON.stringify(context));
  var text = view.someProp("clipboardTextSerializer", function(f) {
    return f(slice2, view);
  }) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap, text };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  var inCode = $context.parent.type.spec.code;
  var dom, slice2;
  if (!html && !text)
    return null;
  var asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function(f) {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    var parsed = view.someProp("clipboardTextParser", function(f) {
      return f(text, $context, plainText, view);
    });
    if (parsed) {
      slice2 = parsed;
    } else {
      var marks = $context.marks();
      var schema = view.state.schema, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function(block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f) {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (var _i139 = +sliceData[3]; _i139 > 0; _i139--) {
      var child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, { preserveWhitespace: !!(asText || sliceData), context: $context, ruleFromNode: function ruleFromNode2(dom2) {
      if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
        return { ignore: true };
      return null;
    } });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      var openStart = 0, openEnd = 0;
      for (var node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (var _node2 = slice2.content.lastChild; openEnd < slice2.openEnd && !_node2.type.spec.isolating; openEnd++, _node2 = _node2.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", function(f) {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  var _loop7 = function _loop72() {
    var parent = $context.node(d);
    var match = parent.contentMatchAt($context.index(d));
    var lastWrap, result = [];
    fragment.forEach(function(node) {
      if (!result)
        return;
      var wrap = match.findWrapping(node.type), inLast;
      if (!wrap)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        var wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap;
      }
    });
    if (result)
      return { v: Fragment.from(result) };
  }, _ret4;
  for (var d = $context.depth; d >= 0; d--) {
    _ret4 = _loop7();
    if (_ret4)
      return _ret4.v;
  }
  return fragment;
}
function withWrappers(node, wrap, from2) {
  if (from2 === void 0) {
    from2 = 0;
  }
  for (var _i140 = wrap.length - 1; _i140 >= from2; _i140--)
    node = wrap[_i140].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] };
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap.map(function(n) {
      return "<" + n + ">";
    }).join("") + html + wrap.map(function(n) {
      return "</" + n + ">";
    }).reverse().join("");
  elt.innerHTML = html;
  if (wrap)
    for (var _i141 = 0; _i141 < wrap.length; _i141++)
      elt = elt.querySelector(wrap[_i141]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var _i142 = 0; _i142 < nodes.length; _i142++) {
    var node = nodes[_i142];
    if (node.childNodes.length == 1 && node.textContent == " " && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  var schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  var content5 = slice2.content, openStart = slice2.openStart, openEnd = slice2.openEnd;
  for (var _i143 = array.length - 2; _i143 >= 0; _i143 -= 2) {
    var type = schema.nodes[array[_i143]];
    if (!type || type.hasRequiredAttrs())
      break;
    content5 = Fragment.from(type.create(array[_i143 + 1], content5));
    openStart++;
    openEnd++;
  }
  return new Slice(content5, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = function InputState2() {
  this.shiftKey = false;
  this.mouseDown = null;
  this.lastKeyCode = null;
  this.lastKeyCodeTime = 0;
  this.lastClick = { time: 0, x: 0, y: 0, type: "" };
  this.lastSelectionOrigin = null;
  this.lastSelectionTime = 0;
  this.lastIOSEnter = 0;
  this.lastIOSEnterFallbackTimeout = -1;
  this.lastFocus = 0;
  this.lastTouch = 0;
  this.lastAndroidDelete = 0;
  this.composing = false;
  this.composingTimeout = -1;
  this.compositionNodes = [];
  this.compositionEndedAt = -2e8;
  this.compositionID = 1;
  this.compositionPendingChanges = 0;
  this.domChangeCount = 0;
  this.eventHandlers = /* @__PURE__ */ Object.create(null);
  this.hideSelectionGuard = null;
};
function initInput(view) {
  var _loop8 = function _loop82() {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = function(event2) {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  };
  for (var event in handlers) {
    _loop8();
  }
  if (safari)
    view.dom.addEventListener("input", function() {
      return null;
    });
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = function(event) {
          return runCustomHandler(view, event);
        });
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (var node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function _dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = function(view, _event) {
  var event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(function() {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function(f) {
    return f(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = function(view, event) {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = function(view, _event) {
  var event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", function(f) {
    return f(view, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", function(f) {
      return f(view, sel.$from.pos, sel.$to.pos, text);
    }))
      view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  var $pos = view.state.doc.resolve(inside);
  var _loop9 = function _loop92(_i1442) {
    if (view.someProp(propName, function(f) {
      return _i1442 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(_i1442), event, true) : f(view, pos, $pos.node(_i1442), $pos.before(_i1442), event, false);
    }))
      return { v: true };
  }, _ret5;
  for (var _i144 = $pos.depth + 1; _i144 > 0; _i144--) {
    _ret5 = _loop9(_i144);
    if (_ret5)
      return _ret5.v;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  var tr4 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr4.setMeta("pointer", true);
  view.dispatch(tr4);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  var $pos = view.state.doc.resolve(inside);
  for (var _i145 = $pos.depth + 1; _i145 > 0; _i145--) {
    var node = _i145 > $pos.depth ? $pos.nodeAfter : $pos.node(_i145);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && _i145 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(_i145);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
    return f(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
    return f(view, pos, event);
  });
}
function handleTripleClick$1(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
    return f(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  var doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var _i146 = $pos.depth + 1; _i146 > 0; _i146--) {
    var node = _i146 > $pos.depth ? $pos.nodeAfter : $pos.node(_i146);
    var nodePos = $pos.before(_i146);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = function(view, _event) {
  var event = _event;
  view.input.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = /* @__PURE__ */ function() {
  function MouseDown2(view, pos, event, flushed) {
    var _this28 = this;
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    var targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      var $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    var target = flushed ? null : event.target;
    var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    var selection = view.state.selection;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = { node: targetNode, pos: targetPos, addAttr: !!(this.target && !this.target.draggable), setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable")) };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(function() {
          if (_this28.view.input.mouseDown == _this28)
            _this28.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  var _proto48 = MouseDown2.prototype;
  _proto48.done = function done() {
    var _this29 = this;
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(function() {
        return selectionToDOM(_this29.view);
      });
    this.view.input.mouseDown = null;
  };
  _proto48.up = function up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    var pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  };
  _proto48.move = function move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  };
  _proto48.updateAllowDefault = function updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  };
  return MouseDown2;
}();
handlers.touchstart = function(view) {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = function(view) {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = function(view) {
  return forceDOMFlush(view);
};
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
      return m.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.domSelectionRange();
        for (var node = sel.focusNode, _offset9 = sel.focusOffset; node && node.nodeType == 1 && _offset9 != 0; ) {
          var before = _offset9 < 0 ? node.lastChild : node.childNodes[_offset9 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            _offset9 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = function(view, event) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(function() {
        return view.domObserver.flush();
      });
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(function() {
      return endComposition(view);
    }, delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate) {
  if (forceUpdate === void 0) {
    forceUpdate = false;
  }
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function() {
    if (wrap.parentNode)
      wrap.parentNode.removeChild(wrap);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = function(view, _event) {
  var event = _event;
  var sel = view.state.selection, cut3 = event.type == "cut";
  if (sel.empty)
    return;
  var data2 = brokenClipboardAPI ? null : event.clipboardData;
  var slice2 = sel.content(), _serializeForClipboar = serializeForClipboard(view, slice2), dom = _serializeForClipboar.dom, text = _serializeForClipboar.text;
  if (data2) {
    event.preventDefault();
    data2.clearData();
    data2.setData("text/html", dom.innerHTML);
    data2.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut3)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(function() {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  var slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f) {
    return f(view, event, slice2 || Slice.empty);
  }))
    return true;
  if (!slice2)
    return false;
  var singleNode = sliceSingleNode(slice2);
  var tr4 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr4.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText$1(clipboardData) {
  var text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  var uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = function(view, _event) {
  var event = _event;
  if (view.composing && !android)
    return;
  var data2 = brokenClipboardAPI ? null : event.clipboardData;
  var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data2 && doPaste(view, getText$1(data2), data2.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = function Dragging2(slice2, move, node) {
  this.slice = slice2;
  this.move = move;
  this.node = node;
};
var dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
handlers.dragstart = function(view, _event) {
  var event = _event;
  var mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  var node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  var slice2 = (node || view.state.selection).content(), _serializeForClipboar2 = serializeForClipboard(view, slice2), dom = _serializeForClipboar2.dom, text = _serializeForClipboar2.text;
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = function(view) {
  var dragging = view.dragging;
  window.setTimeout(function() {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = function(_, e) {
  return e.preventDefault();
};
editHandlers.drop = function(view, _event) {
  var event = _event;
  var dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  var eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  var $mouse = view.state.doc.resolve(eventPos.pos);
  var slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", function(f) {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText$1(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", function(f) {
    return f(view, event, slice2 || Slice.empty, move);
  })) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  var insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  var tr4 = view.state.tr;
  if (move) {
    var node = dragging.node;
    if (node)
      node.replace(tr4);
    else
      tr4.deleteSelection();
  }
  var pos = tr4.mapping.map(insertPos);
  var isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  var beforeInsert = tr4.doc;
  if (isNode)
    tr4.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr4.replaceRange(pos, pos, slice2);
  if (tr4.doc.eq(beforeInsert))
    return;
  var $pos = tr4.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr4.setSelection(new NodeSelection($pos));
  } else {
    var _end18 = tr4.mapping.map(insertPos);
    tr4.mapping.maps[tr4.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
      return _end18 = newTo;
    });
    tr4.setSelection(selectionBetween(view, $pos, tr4.doc.resolve(_end18)));
  }
  view.focus();
  view.dispatch(tr4.setMeta("uiEvent", "drop"));
};
handlers.focus = function(view) {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function() {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = function(view, _event) {
  var event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = function(view, _event) {
  var event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.input.domChangeCount;
    setTimeout(function() {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(8, "Backspace"));
      }))
        return;
      var $cursor = view.state.selection.$cursor;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (var prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (var p in a)
    if (a[p] !== b[p])
      return false;
  for (var _p3 in b)
    if (!(_p3 in a))
      return false;
  return true;
}
var WidgetType = /* @__PURE__ */ function() {
  function WidgetType2(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  var _proto49 = WidgetType2.prototype;
  _proto49.map = function map3(mapping, span, offset2, oldOffset) {
    var _mapping$mapResult3 = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1), pos = _mapping$mapResult3.pos, deleted = _mapping$mapResult3.deleted;
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  };
  _proto49.valid = function valid() {
    return true;
  };
  _proto49.eq = function eq(other) {
    return this == other || other instanceof WidgetType2 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  };
  _proto49.destroy = function destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  };
  return WidgetType2;
}();
var InlineType = /* @__PURE__ */ function() {
  function InlineType2(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  var _proto50 = InlineType2.prototype;
  _proto50.map = function map3(mapping, span, offset2, oldOffset) {
    var from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  };
  _proto50.valid = function valid(_, span) {
    return span.from < span.to;
  };
  _proto50.eq = function eq(other) {
    return this == other || other instanceof InlineType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  };
  InlineType2.is = function is(span) {
    return span.type instanceof InlineType2;
  };
  _proto50.destroy = function destroy() {
  };
  return InlineType2;
}();
var NodeType = /* @__PURE__ */ function() {
  function NodeType2(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  var _proto51 = NodeType2.prototype;
  _proto51.map = function map3(mapping, span, offset2, oldOffset) {
    var from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    var to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  };
  _proto51.valid = function valid(node, span) {
    var _node$content$findInd3 = node.content.findIndex(span.from), index = _node$content$findInd3.index, offset2 = _node$content$findInd3.offset, child;
    return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
  };
  _proto51.eq = function eq(other) {
    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  };
  _proto51.destroy = function destroy() {
  };
  return NodeType2;
}();
var Decoration = /* @__PURE__ */ function() {
  function Decoration2(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  var _proto52 = Decoration2.prototype;
  _proto52.copy = function copy2(from2, to) {
    return new Decoration2(from2, to, this.type);
  };
  _proto52.eq = function eq(other, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  };
  _proto52.map = function map3(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  };
  Decoration2.widget = function widget(pos, toDOM, spec) {
    return new Decoration2(pos, pos, new WidgetType(toDOM, spec));
  };
  Decoration2.inline = function inline2(from2, to, attrs, spec) {
    return new Decoration2(from2, to, new InlineType(attrs, spec));
  };
  Decoration2.node = function node(from2, to, attrs, spec) {
    return new Decoration2(from2, to, new NodeType(attrs, spec));
  };
  _createClass(Decoration2, [{
    key: "spec",
    get: function get5() {
      return this.type.spec;
    }
    /**
    @internal
    */
  }, {
    key: "inline",
    get: function get5() {
      return this.type instanceof InlineType;
    }
    /**
    @internal
    */
  }, { key: "widget", get: function get5() {
    return this.type instanceof WidgetType;
  } }]);
  return Decoration2;
}();
var none = [], noSpec = {};
var DecorationSet = /* @__PURE__ */ function() {
  function DecorationSet2(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  DecorationSet2.create = function create2(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  };
  var _proto53 = DecorationSet2.prototype;
  _proto53.find = function find2(start2, end2, predicate) {
    var result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  };
  _proto53.findInner = function findInner(start2, end2, result, offset2, predicate) {
    for (var _i147 = 0; _i147 < this.local.length; _i147++) {
      var span = this.local[_i147];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (var _i148 = 0; _i148 < this.children.length; _i148 += 3) {
      if (this.children[_i148] < end2 && this.children[_i148 + 1] > start2) {
        var childOff = this.children[_i148] + 1;
        this.children[_i148 + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  };
  _proto53.map = function map3(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  };
  _proto53.mapInner = function mapInner(mapping, node, offset2, oldOffset, options) {
    var newLocal;
    for (var _i149 = 0; _i149 < this.local.length; _i149++) {
      var mapped = this.local[_i149].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[_i149].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet2(newLocal.sort(byPos), none) : empty;
  };
  _proto53.add = function add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet2.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  };
  _proto53.addInner = function addInner(doc2, decorations, offset2) {
    var _this30 = this;
    var children, childIndex = 0;
    doc2.forEach(function(childNode, childOffset) {
      var baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = _this30.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (var _i150 = 0; _i150 < local.length; _i150++)
      if (!local[_i150].type.valid(doc2, local[_i150]))
        local.splice(_i150--, 1);
    return new DecorationSet2(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  };
  _proto53.remove = function remove2(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  };
  _proto53.removeInner = function removeInner(decorations, offset2) {
    var children = this.children, local = this.local;
    for (var _i151 = 0; _i151 < children.length; _i151 += 3) {
      var _found10 = void 0;
      var _from4 = children[_i151] + offset2, to = children[_i151 + 1] + offset2;
      for (var j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > _from4 && span.to < to) {
            decorations[j] = null;
            (_found10 || (_found10 = [])).push(span);
          }
        }
      if (!_found10)
        continue;
      if (children == this.children)
        children = this.children.slice();
      var removed = children[_i151 + 2].removeInner(_found10, _from4 + 1);
      if (removed != empty) {
        children[_i151 + 2] = removed;
      } else {
        children.splice(_i151, 3);
        _i151 -= 3;
      }
    }
    if (local.length) {
      for (var _i152 = 0, _span; _i152 < decorations.length; _i152++)
        if (_span = decorations[_i152]) {
          for (var _j3 = 0; _j3 < local.length; _j3++)
            if (local[_j3].eq(_span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(_j3--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet2(local, children) : empty;
  };
  _proto53.forChild = function forChild(offset2, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet2.empty;
    var child, local;
    for (var _i153 = 0; _i153 < this.children.length; _i153 += 3)
      if (this.children[_i153] >= offset2) {
        if (this.children[_i153] == offset2)
          child = this.children[_i153 + 2];
        break;
      }
    var start2 = offset2 + 1, end2 = start2 + node.content.size;
    for (var _i154 = 0; _i154 < this.local.length; _i154++) {
      var dec = this.local[_i154];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        var _from5 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (_from5 < to)
          (local || (local = [])).push(dec.copy(_from5, to));
      }
    }
    if (local) {
      var localSet = new DecorationSet2(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  };
  _proto53.eq = function eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet2) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (var _i155 = 0; _i155 < this.local.length; _i155++)
      if (!this.local[_i155].eq(other.local[_i155]))
        return false;
    for (var _i156 = 0; _i156 < this.children.length; _i156 += 3)
      if (this.children[_i156] != other.children[_i156] || this.children[_i156 + 1] != other.children[_i156 + 1] || !this.children[_i156 + 2].eq(other.children[_i156 + 2]))
        return false;
    return true;
  };
  _proto53.locals = function locals(node) {
    return removeOverlap(this.localsInner(node));
  };
  _proto53.localsInner = function localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    var result = [];
    for (var _i157 = 0; _i157 < this.local.length; _i157++) {
      if (!(this.local[_i157].type instanceof InlineType))
        result.push(this.local[_i157]);
    }
    return result;
  };
  return DecorationSet2;
}();
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
var DecorationGroup = /* @__PURE__ */ function() {
  function DecorationGroup2(members) {
    this.members = members;
  }
  var _proto54 = DecorationGroup2.prototype;
  _proto54.map = function map3(mapping, doc2) {
    var mappedDecos = this.members.map(function(member) {
      return member.map(mapping, doc2, noSpec);
    });
    return DecorationGroup2.from(mappedDecos);
  };
  _proto54.forChild = function forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    var found2 = [];
    for (var _i158 = 0; _i158 < this.members.length; _i158++) {
      var result = this.members[_i158].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup2)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup2.from(found2);
  };
  _proto54.eq = function eq(other) {
    if (!(other instanceof DecorationGroup2) || other.members.length != this.members.length)
      return false;
    for (var _i159 = 0; _i159 < this.members.length; _i159++)
      if (!this.members[_i159].eq(other.members[_i159]))
        return false;
    return true;
  };
  _proto54.locals = function locals(node) {
    var result, sorted = true;
    for (var _i160 = 0; _i160 < this.members.length; _i160++) {
      var locals2 = this.members[_i160].localsInner(node);
      if (!locals2.length)
        continue;
      if (!result) {
        result = locals2;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (var j = 0; j < locals2.length; j++)
          result.push(locals2[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  };
  DecorationGroup2.from = function from2(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup2(members.every(function(m) {
          return m instanceof DecorationSet;
        }) ? members : members.reduce(function(r2, m) {
          return r2.concat(m instanceof DecorationSet ? m : m.members);
        }, []));
    }
  };
  return DecorationGroup2;
}();
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  var children = oldChildren.slice();
  var _loop10 = function _loop102(_baseOffset) {
    var moved = 0;
    mapping.maps[_i161].forEach(function(oldStart, oldEnd, newStart, newEnd) {
      var dSize = newEnd - newStart - (oldEnd - oldStart);
      for (var _i165 = 0; _i165 < children.length; _i165 += 3) {
        var _end19 = children[_i165 + 1];
        if (_end19 < 0 || oldStart > _end19 + _baseOffset - moved)
          continue;
        var _start11 = children[_i165] + _baseOffset - moved;
        if (oldEnd >= _start11) {
          children[_i165 + 1] = oldStart <= _start11 ? -2 : -1;
        } else if (oldStart >= _baseOffset && dSize) {
          children[_i165] += dSize;
          children[_i165 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    _baseOffset = mapping.maps[_i161].map(_baseOffset, -1);
    baseOffset = _baseOffset;
  };
  for (var _i161 = 0, baseOffset = oldOffset; _i161 < mapping.maps.length; _i161++) {
    _loop10(baseOffset);
  }
  var mustRebuild = false;
  for (var _i162 = 0; _i162 < children.length; _i162 += 3)
    if (children[_i162 + 1] < 0) {
      if (children[_i162 + 1] == -2) {
        mustRebuild = true;
        children[_i162 + 1] = -1;
        continue;
      }
      var _from6 = mapping.map(oldChildren[_i162] + oldOffset), fromLocal = _from6 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[_i162 + 1] + oldOffset, -1), toLocal = to - offset2;
      var _node$content$findInd4 = node.content.findIndex(fromLocal), index = _node$content$findInd4.index, childOffset = _node$content$findInd4.offset;
      var childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[_i162 + 2].mapInner(mapping, childNode, _from6 + 1, oldChildren[_i162] + oldOffset + 1, options);
        if (mapped != empty) {
          children[_i162] = fromLocal;
          children[_i162 + 1] = toLocal;
          children[_i162 + 2] = mapped;
        } else {
          children[_i162 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (var _i163 = 0; _i163 < children.length; _i163 += 3)
      if (children[_i163 + 1] < 0) {
        children.splice(_i163, 3);
        _i163 -= 3;
      }
    for (var _i164 = 0, j = 0; _i164 < built.children.length; _i164 += 3) {
      var _from7 = built.children[_i164];
      while (j < children.length && children[j] < _from7)
        j += 3;
      children.splice(j, 0, built.children[_i164], built.children[_i164 + 1], built.children[_i164 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  var result = [];
  for (var _i166 = 0; _i166 < spans.length; _i166++) {
    var span = spans[_i166];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (var _i167 = 0; _i167 < set2.local.length; _i167++) {
      var mapped = set2.local[_i167].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set2.local[_i167].spec);
    }
    for (var _i168 = 0; _i168 < set2.children.length; _i168 += 3)
      gather(set2.children[_i168 + 2], set2.children[_i168] + oldOffset2 + 1);
  }
  for (var _i169 = 0; _i169 < children.length; _i169 += 3)
    if (children[_i169 + 1] == -1)
      gather(children[_i169 + 2], oldChildren[_i169] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  var end2 = offset2 + node.nodeSize, found2 = null;
  for (var _i170 = 0, span; _i170 < spans.length; _i170++) {
    if ((span = spans[_i170]) && span.from > offset2 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[_i170] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  var result = [];
  for (var _i171 = 0; _i171 < array.length; _i171++)
    if (array[_i171] != null)
      result.push(array[_i171]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  var children = [], hasNulls = false;
  node.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (var _i172 = 0; _i172 < locals.length; _i172++)
    if (!locals[_i172].type.valid(node, locals[_i172])) {
      if (options.onRemove)
        options.onRemove(locals[_i172].spec);
      locals.splice(_i172--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  var working = spans;
  for (var _i173 = 0; _i173 < working.length - 1; _i173++) {
    var span = working[_i173];
    if (span.from != span.to)
      for (var j = _i173 + 1; j < working.length; j++) {
        var next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[_i173] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  var found2 = [];
  view.someProp("decorations", function(f) {
    var result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = { childList: true, characterData: true, characterDataOldValue: true, attributes: true, attributeOldValue: true, subtree: true };
var useCharData = ie$1 && ie_version <= 11;
var SelectionState = /* @__PURE__ */ function() {
  function SelectionState2() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  var _proto55 = SelectionState2.prototype;
  _proto55.set = function set2(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  };
  _proto55.clear = function clear() {
    this.anchorNode = this.focusNode = null;
  };
  _proto55.eq = function eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  };
  return SelectionState2;
}();
var DOMObserver = /* @__PURE__ */ function() {
  function DOMObserver2(view, handleDOMChange) {
    var _this31 = this;
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
      for (var _i174 = 0; _i174 < mutations.length; _i174++)
        _this31.queue.push(mutations[_i174]);
      if (ie$1 && ie_version <= 11 && mutations.some(function(m) {
        return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
      }))
        _this31.flushSoon();
      else
        _this31.flush();
    });
    if (useCharData) {
      this.onCharData = function(e) {
        _this31.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        _this31.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  var _proto56 = DOMObserver2.prototype;
  _proto56.flushSoon = function flushSoon() {
    var _this32 = this;
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(function() {
        _this32.flushingSoon = -1;
        _this32.flush();
      }, 20);
  };
  _proto56.forceFlush = function forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  };
  _proto56.start = function start2() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  };
  _proto56.stop = function stop() {
    var _this33 = this;
    if (this.observer) {
      var take = this.observer.takeRecords();
      if (take.length) {
        for (var _i175 = 0; _i175 < take.length; _i175++)
          this.queue.push(take[_i175]);
        window.setTimeout(function() {
          return _this33.flush();
        }, 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  };
  _proto56.connectSelection = function connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  };
  _proto56.disconnectSelection = function disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  };
  _proto56.suppressSelectionUpdates = function suppressSelectionUpdates() {
    var _this34 = this;
    this.suppressingSelectionUpdates = true;
    setTimeout(function() {
      return _this34.suppressingSelectionUpdates = false;
    }, 50);
  };
  _proto56.onSelectionChange = function onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      var sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  };
  _proto56.setCurSelection = function setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  };
  _proto56.ignoreSelectionChange = function ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    var ancestors = /* @__PURE__ */ new Set(), container;
    for (var scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (var _scan = sel.anchorNode; _scan; _scan = parentNode(_scan))
      if (ancestors.has(_scan)) {
        container = _scan;
        break;
      }
    var desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
      this.setCurSelection();
      return true;
    }
  };
  _proto56.pendingRecords = function pendingRecords() {
    if (this.observer) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(this.observer.takeRecords()), _step3; !(_step3 = _iterator2()).done; ) {
        var mut = _step3.value;
        this.queue.push(mut);
      }
    }
    return this.queue;
  };
  _proto56.flush = function flush() {
    var view = this.view;
    if (!view.docView || this.flushingSoon > -1)
      return;
    var mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    var sel = view.domSelectionRange();
    var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    var from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (var _i176 = 0; _i176 < mutations.length; _i176++) {
        var result = this.registerMutation(mutations[_i176], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length > 1) {
      var brs = added.filter(function(n) {
        return n.nodeName == "BR";
      });
      if (brs.length == 2) {
        var a = brs[0], b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      }
    }
    var readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  };
  _proto56.registerMutation = function registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    var desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (var _i177 = 0; _i177 < mut.addedNodes.length; _i177++)
        added.push(mut.addedNodes[_i177]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      var prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (var _i178 = 0; _i178 < mut.addedNodes.length; _i178++) {
          var _mut$addedNodes$_i = mut.addedNodes[_i178], previousSibling = _mut$addedNodes$_i.previousSibling, nextSibling = _mut$addedNodes$_i.nextSibling;
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      var _from8 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      var to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: _from8, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  };
  return DOMObserver2;
}();
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function safariShadowSelectionRange(view) {
  var found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  var anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
  var focusNode = found2.endContainer, focusOffset = found2.endOffset;
  var currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) {
    var _ref10 = [focusNode, focusOffset, anchorNode, anchorOffset];
    anchorNode = _ref10[0];
    anchorOffset = _ref10[1];
    focusNode = _ref10[2];
    focusOffset = _ref10[3];
  }
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function parseBetween(view, from_, to_) {
  var _view$docView$parseRa = view.docView.parseRange(from_, to_), parent = _view$docView$parseRa.node, fromOffset = _view$docView$parseRa.fromOffset, toOffset = _view$docView$parseRa.toOffset, from2 = _view$docView$parseRa.from, to = _view$docView$parseRa.to;
  var domSel = view.domSelectionRange();
  var find2;
  var anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from2);
  var sel = null, doc2 = parser.parse(parent, { topNode: $from.parent, topMatch: $from.parent.contentMatchAt($from.index()), topOpen: true, from: fromOffset, to: toOffset, preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true, findPositions: find2, ruleFromNode, context: $from });
  if (find2 && find2[0].pos != null) {
    var _anchor = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = _anchor;
    sel = { anchor: _anchor + from2, head: head + from2 };
  }
  return { doc: doc2, sel, from: from2, to };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  var compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      }))
        return;
      var _tr3 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        _tr3.setMeta("pointer", true);
      else if (origin == "key")
        _tr3.scrollIntoView();
      if (compositionID)
        _tr3.setMeta("composition", compositionID);
      view.dispatch(_tr3);
    }
    return;
  }
  var $before = view.state.doc.resolve(from2);
  var shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse = parseBetween(view, from2, to);
  var doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
  var preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function(n) {
    return n.nodeType == 1 && !isInline.test(n.nodeName);
  }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        var _sel = resolveSelection(view, view.state.doc, parse.sel);
        if (_sel && !_sel.eq(view.state.selection)) {
          var _tr4 = view.state.tr.setSelection(_sel);
          if (compositionID)
            _tr4.setMeta("composition", compositionID);
          view.dispatch(_tr4);
        }
      }
      return;
    }
  }
  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
    var size = change.endB - change.start;
    parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var $fromA = doc2.resolve(change.start);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  var nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent(8, "Backspace"));
  })) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr4, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM(view);
        }, 20);
      }
      tr4 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr4 = view.state.tr;
      if (markChange.type == "add")
        tr4.addMark(chFrom, chTo, markChange.mark);
      else
        tr4.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f) {
        return f(view, chFrom, chTo, text);
      }))
        return;
      tr4 = view.state.tr.insertText(text, chFrom, chTo);
    }
  }
  if (!tr4)
    tr4 = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    var _sel2 = resolveSelection(view, tr4.doc, parse.sel);
    if (_sel2 && !(chrome && android && view.composing && _sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel2.head == chFrom || _sel2.head == tr4.mapping.map(chTo) - 1) || ie$1 && _sel2.empty && _sel2.head == chFrom))
      tr4.setSelection(_sel2);
  }
  if (storedMarks)
    tr4.ensureMarks(storedMarks);
  if (compositionID)
    tr4.setMeta("composition", compositionID);
  view.dispatch(tr4.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark, update2;
  for (var _i179 = 0; _i179 < prevMarks.length; _i179++)
    added = prevMarks[_i179].removeFromSet(added);
  for (var _i180 = 0; _i180 < curMarks.length; _i180++)
    removed = curMarks[_i180].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update2 = function update3(node) {
      return node.mark(mark.addToSet(node.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update2 = function update3(node) {
      return node.mark(mark.removeFromSet(node.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var _i181 = 0; _i181 < prev.childCount; _i181++)
    updated.push(update2(prev.child(_i181)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeJoin(old, start2, end2, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || // The content must have shrunk
  end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
  skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false;
  var $start = old.resolve(start2);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size), endA = _a$findDiffEnd.a, endB = _a$findDiffEnd.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    var move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    var _move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= _move;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += _move ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  var a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = /* @__PURE__ */ function() {
  function EditorView2(place, props) {
    var _this35 = this;
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, function(from2, to, typeOver, added) {
      return readDOMChange(_this35, from2, to, typeOver, added);
    });
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  var _proto57 = EditorView2.prototype;
  _proto57.update = function update2(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    var prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  };
  _proto57.setProps = function setProps(props) {
    var updated = {};
    for (var name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (var _name4 in props)
      updated[_name4] = props[_name4];
    this.update(updated);
  };
  _proto57.updateState = function updateState(state) {
    this.updateStateInner(state, this._props);
  };
  _proto57.updateStateInner = function updateStateInner(state, prevProps) {
    var _a;
    var prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    var pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      var nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    var scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      var forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        var chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  };
  _proto57.scrollToSelection = function scrollToSelection() {
    var _this36 = this;
    var startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", function(f) {
      return f(_this36);
    }))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      var target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  };
  _proto57.destroyPluginViews = function destroyPluginViews() {
    var view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  };
  _proto57.updatePluginViews = function updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (var _i182 = 0; _i182 < this.directPlugins.length; _i182++) {
        var plugin = this.directPlugins[_i182];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (var _i183 = 0; _i183 < this.state.plugins.length; _i183++) {
        var _plugin = this.state.plugins[_i183];
        if (_plugin.spec.view)
          this.pluginViews.push(_plugin.spec.view(this));
      }
    } else {
      for (var _i184 = 0; _i184 < this.pluginViews.length; _i184++) {
        var pluginView = this.pluginViews[_i184];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  };
  _proto57.updateDraggedNode = function updateDraggedNode(dragging, prev) {
    var sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      var movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      var moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  };
  _proto57.someProp = function someProp(propName, f) {
    var prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (var _i185 = 0; _i185 < this.directPlugins.length; _i185++) {
      var _prop3 = this.directPlugins[_i185].props[propName];
      if (_prop3 != null && (value = f ? f(_prop3) : _prop3))
        return value;
    }
    var plugins = this.state.plugins;
    if (plugins)
      for (var _i186 = 0; _i186 < plugins.length; _i186++) {
        var _prop4 = plugins[_i186].props[propName];
        if (_prop4 != null && (value = f ? f(_prop4) : _prop4))
          return value;
      }
  };
  _proto57.hasFocus = function hasFocus() {
    if (ie$1) {
      var node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  };
  _proto57.focus = function focus3() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  };
  _proto57.updateRoot = function updateRoot() {
    this._root = null;
  };
  _proto57.posAtCoords = function posAtCoords(coords) {
    return _posAtCoords(this, coords);
  };
  _proto57.coordsAtPos = function coordsAtPos(pos, side) {
    if (side === void 0) {
      side = 1;
    }
    return _coordsAtPos(this, pos, side);
  };
  _proto57.domAtPos = function domAtPos(pos, side) {
    if (side === void 0) {
      side = 0;
    }
    return this.docView.domFromPos(pos, side);
  };
  _proto57.nodeDOM = function nodeDOM(pos) {
    var desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  };
  _proto57.posAtDOM = function posAtDOM(node, offset2, bias) {
    if (bias === void 0) {
      bias = -1;
    }
    var pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  };
  _proto57.endOfTextblock = function endOfTextblock(dir, state) {
    return _endOfTextblock(this, state || this.state, dir);
  };
  _proto57.pasteHTML = function pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  };
  _proto57.pasteText = function pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  };
  _proto57.destroy = function destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  };
  _proto57.dispatchEvent = function dispatchEvent(event) {
    return _dispatchEvent(this, event);
  };
  _proto57.dispatch = function dispatch(tr4) {
    var dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr4);
    else
      this.updateState(this.state.apply(tr4));
  };
  _proto57.domSelectionRange = function domSelectionRange() {
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
  };
  _proto57.domSelection = function domSelection() {
    return this.root.getSelection();
  };
  _createClass(EditorView2, [{
    key: "composing",
    get: function get5() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
  }, { key: "props", get: function get5() {
    if (this._props.state != this.state) {
      var prev = this._props;
      this._props = {};
      for (var name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  } }, { key: "root", get: function get5() {
    var _this37 = this;
    var cached = this._root;
    if (cached == null) {
      var _loop11 = function _loop112(search2) {
        if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
          if (!search2.getSelection)
            Object.getPrototypeOf(search2).getSelection = function() {
              return search2.ownerDocument.getSelection();
            };
          return { v: _this37._root = search2 };
        }
      }, _ret6;
      for (var search = this.dom.parentNode; search; search = search.parentNode) {
        _ret6 = _loop11(search);
        if (_ret6)
          return _ret6.v;
      }
    }
    return cached || document;
  } }, { key: "isDestroyed", get: function get5() {
    return this.docView == null;
  } }]);
  return EditorView2;
}();
function computeDocDeco(view) {
  var attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", function(value) {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (var attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (var _prop5 in obj)
      if (!Object.prototype.hasOwnProperty.call(result, _prop5))
        result[_prop5] = obj[_prop5];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  var nA = 0, nB = 0;
  for (var _prop6 in a) {
    if (a[_prop6] != b[_prop6])
      return true;
    nA++;
  }
  for (var _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" };
var shift = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' };
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName$1(name) {
  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  var alt, ctrl, shift2, meta;
  for (var _i187 = 0; _i187 < parts.length - 1; _i187++) {
    var mod = parts[_i187];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map3) {
  var copy2 = /* @__PURE__ */ Object.create(null);
  for (var _prop7 in map3)
    copy2[normalizeKeyName$1(_prop7)] = map3[_prop7];
  return copy2;
}
function modifiers(name, event, shift2) {
  if (shift2 === void 0) {
    shift2 = true;
  }
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  var map3 = normalize(bindings);
  return function(view, event) {
    var name = keyName(event), baseName, direct = map3[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        var noShift = map3[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        var fromCode = map3[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
var deleteSelection$1 = function deleteSelection$12(state, dispatch) {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward$1 = function joinBackward$12(state, dispatch, view) {
  var $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  var $cut = findCutBefore($cursor);
  if (!$cut) {
    var range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  var before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var _tr5 = state.tr.step(delStep);
        _tr5.setSelection(textblockAt(before, "end") ? Selection.findFrom(_tr5.doc.resolve(_tr5.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(_tr5.doc, $cut.pos - before.nodeSize));
        dispatch(_tr5.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node, side, only) {
  if (only === void 0) {
    only = false;
  }
  for (var scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward$1 = function selectNodeBackward$12(state, dispatch, view) {
  var _state$selection2 = state.selection, $head = _state$selection2.$head, empty2 = _state$selection2.empty, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  var node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (var _i188 = $pos.depth - 1; _i188 >= 0; _i188--) {
      if ($pos.index(_i188) > 0)
        return $pos.doc.resolve($pos.before(_i188 + 1));
      if ($pos.node(_i188).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward$1 = function joinForward$12(state, dispatch, view) {
  var $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  var $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  var after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var _tr6 = state.tr.step(delStep);
        _tr6.setSelection(textblockAt(after, "start") ? Selection.findFrom(_tr6.doc.resolve(_tr6.mapping.map($cut.pos)), 1) : NodeSelection.create(_tr6.doc, _tr6.mapping.map($cut.pos)));
        dispatch(_tr6.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward$1 = function selectNodeForward$12(state, dispatch, view) {
  var _state$selection3 = state.selection, $head = _state$selection3.$head, empty2 = _state$selection3.empty, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  var node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (var _i189 = $pos.depth - 1; _i189 >= 0; _i189--) {
      var parent = $pos.node(_i189);
      if ($pos.index(_i189) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(_i189 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp$1 = function joinUp$12(state, dispatch) {
  var sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    var _tr7 = state.tr.join(point);
    if (nodeSel)
      _tr7.setSelection(NodeSelection.create(_tr7.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(_tr7.scrollIntoView());
  }
  return true;
};
var joinDown$1 = function joinDown$12(state, dispatch) {
  var sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift$1 = function lift$12(state, dispatch) {
  var _state$selection4 = state.selection, $from = _state$selection4.$from, $to = _state$selection4.$to;
  var range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode$1 = function newlineInCode$12(state, dispatch) {
  var _state$selection5 = state.selection, $head = _state$selection5.$head, $anchor = _state$selection5.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt$1(match) {
  for (var _i190 = 0; _i190 < match.edgeCount; _i190++) {
    var _match$edge2 = match.edge(_i190), type = _match$edge2.type;
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode$1 = function exitCode$12(state, dispatch) {
  var _state$selection6 = state.selection, $head = _state$selection6.$head, $anchor = _state$selection6.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt$1(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    var pos = $head.after(), _tr8 = state.tr.replaceWith(pos, pos, type.createAndFill());
    _tr8.setSelection(Selection.near(_tr8.doc.resolve(pos), 1));
    dispatch(_tr8.scrollIntoView());
  }
  return true;
};
var createParagraphNear$1 = function createParagraphNear$12(state, dispatch) {
  var sel = state.selection, $from = sel.$from, $to = sel.$to;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  var type = defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var _tr9 = state.tr.insert(side, type.createAndFill());
    _tr9.setSelection(TextSelection.create(_tr9.doc, side + 1));
    dispatch(_tr9.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock$1 = function liftEmptyBlock$12(state, dispatch) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  var range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var selectParentNode$1 = function selectParentNode$12(state, dispatch) {
  var _state$selection7 = state.selection, $from = _state$selection7.$from, to = _state$selection7.to, pos;
  var same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state, $cut, dispatch))
    return true;
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var _end20 = $cut.pos + after.nodeSize, wrap = Fragment.empty;
      for (var _i191 = conn.length - 1; _i191 >= 0; _i191--)
        wrap = Fragment.from(conn[_i191].create(null, wrap));
      wrap = Fragment.from(before.copy(wrap));
      var _tr10 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, _end20, $cut.pos, _end20, new Slice(wrap, 1, 0), conn.length, true));
      var joinAt = _end20 + 2 * conn.length;
      if (canJoin(_tr10.doc, joinAt))
        _tr10.join(joinAt);
      dispatch(_tr10.scrollIntoView());
    }
    return true;
  }
  var selAfter = Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before, _wrap5 = [];
    for (; ; ) {
      _wrap5.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    var afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var _end21 = Fragment.empty;
        for (var _i192 = _wrap5.length - 1; _i192 >= 0; _i192--)
          _end21 = Fragment.from(_wrap5[_i192].copy(_end21));
        var _tr11 = state.tr.step(new ReplaceAroundStep($cut.pos - _wrap5.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(_end21, _wrap5.length, 0), 0, true));
        dispatch(_tr11.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart$1 = selectTextblockSide(-1);
var selectTextblockEnd$1 = selectTextblockSide(1);
function wrapIn$1(nodeType, attrs) {
  if (attrs === void 0) {
    attrs = null;
  }
  return function(state, dispatch) {
    var _state$selection8 = state.selection, $from = _state$selection8.$from, $to = _state$selection8.$to;
    var range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType(nodeType, attrs) {
  if (attrs === void 0) {
    attrs = null;
  }
  return function(state, dispatch) {
    var applicable = false;
    for (var _i193 = 0; _i193 < state.selection.ranges.length && !applicable; _i193++) {
      var _state$selection$rang = state.selection.ranges[_i193], _from9 = _state$selection$rang.$from.pos, to = _state$selection$rang.$to.pos;
      state.doc.nodesBetween(_from9, to, function(node, pos) {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          var $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      var _tr12 = state.tr;
      for (var _i194 = 0; _i194 < state.selection.ranges.length; _i194++) {
        var _state$selection$rang2 = state.selection.ranges[_i194], _from10 = _state$selection$rang2.$from.pos, _to2 = _state$selection$rang2.$to.pos;
        _tr12.setBlockType(_from10, _to2, nodeType, attrs);
      }
      dispatch(_tr12.scrollIntoView());
    }
    return true;
  };
}
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
function wrapInList$1(listType, attrs) {
  if (attrs === void 0) {
    attrs = null;
  }
  return function(state, dispatch) {
    var _state$selection9 = state.selection, $from = _state$selection9.$from, $to = _state$selection9.$to;
    var range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range)
      return false;
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0)
        return false;
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }
    var wrap = findWrapping(outerRange, listType, attrs, range);
    if (!wrap)
      return false;
    if (dispatch)
      dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr4, range, wrappers, joinBefore, listType) {
  var content5 = Fragment.empty;
  for (var _i195 = wrappers.length - 1; _i195 >= 0; _i195--)
    content5 = Fragment.from(wrappers[_i195].type.create(wrappers[_i195].attrs, content5));
  tr4.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content5, 0, 0), wrappers.length, true));
  var found2 = 0;
  for (var _i196 = 0; _i196 < wrappers.length; _i196++)
    if (wrappers[_i196].type == listType)
      found2 = _i196 + 1;
  var splitDepth = wrappers.length - found2;
  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (var _i197 = range.startIndex, e = range.endIndex, _first5 = true; _i197 < e; _i197++, _first5 = false) {
    if (!_first5 && canSplit(tr4.doc, splitPos, splitDepth)) {
      tr4.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(_i197).nodeSize;
  }
  return tr4;
}
function liftListItem$1(itemType) {
  return function(state, dispatch) {
    var _state$selection10 = state.selection, $from = _state$selection10.$from, $to = _state$selection10.$to;
    var range = $from.blockRange($to, function(node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  var tr4 = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
  if (end2 < endOfList) {
    tr4.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr4.doc.resolve(range.$from.pos), tr4.doc.resolve(endOfList), range.depth);
  }
  var target = liftTarget(range);
  if (target == null)
    return false;
  tr4.lift(range, target);
  var after = tr4.mapping.map(end2, -1) - 1;
  if (canJoin(tr4.doc, after))
    tr4.join(after);
  dispatch(tr4.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  var tr4 = state.tr, list = range.parent;
  for (var pos = range.end, _i198 = range.endIndex - 1, e = range.startIndex; _i198 > e; _i198--) {
    pos -= list.child(_i198).nodeSize;
    tr4.delete(pos - 1, pos + 1);
  }
  var $start = tr4.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr4.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  var start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr4.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr4.scrollIntoView());
  return true;
}
function sinkListItem$1(itemType) {
  return function(state, dispatch) {
    var _state$selection11 = state.selection, $from = _state$selection11.$from, $to = _state$selection11.$to;
    var range = $from.blockRange($to, function(node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range)
      return false;
    var startIndex2 = range.startIndex;
    if (startIndex2 == 0)
      return false;
    var parent = range.parent, nodeBefore = parent.child(startIndex2 - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = Fragment.from(nestedBefore ? itemType.create() : null);
      var slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
function createChainableState(config) {
  var state = config.state, transaction = config.transaction;
  var selection = transaction.selection;
  var doc2 = transaction.doc;
  var storedMarks = transaction.storedMarks;
  return _extends({}, state, { apply: state.apply.bind(state), applyTransaction: state.applyTransaction.bind(state), filterTransaction: state.filterTransaction, plugins: state.plugins, schema: state.schema, reconfigure: state.reconfigure.bind(state), toJSON: state.toJSON.bind(state), get storedMarks() {
    return storedMarks;
  }, get selection() {
    return selection;
  }, get doc() {
    return doc2;
  }, get tr() {
    selection = transaction.selection;
    doc2 = transaction.doc;
    storedMarks = transaction.storedMarks;
    return transaction;
  } });
}
var CommandManager = /* @__PURE__ */ function() {
  function CommandManager2(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  var _proto58 = CommandManager2.prototype;
  _proto58.createChain = function createChain(startTr, shouldDispatch) {
    var _this38 = this;
    if (shouldDispatch === void 0) {
      shouldDispatch = true;
    }
    var rawCommands = this.rawCommands, editor = this.editor, state = this.state;
    var view = editor.view;
    var callbacks = [];
    var hasStartTransaction = !!startTr;
    var tr4 = startTr || state.tr;
    var run2 = function run3() {
      if (!hasStartTransaction && shouldDispatch && !tr4.getMeta("preventDispatch") && !_this38.hasCustomState) {
        view.dispatch(tr4);
      }
      return callbacks.every(function(callback) {
        return callback === true;
      });
    };
    var chain = _extends({}, Object.fromEntries(Object.entries(rawCommands).map(function(_ref11) {
      var name = _ref11[0], command3 = _ref11[1];
      var chainedCommand = function chainedCommand2() {
        var props = _this38.buildProps(tr4, shouldDispatch);
        var callback = command3.apply(void 0, arguments)(props);
        callbacks.push(callback);
        return chain;
      };
      return [name, chainedCommand];
    })), { run: run2 });
    return chain;
  };
  _proto58.createCan = function createCan(startTr) {
    var _this39 = this;
    var rawCommands = this.rawCommands, state = this.state;
    var dispatch = false;
    var tr4 = startTr || state.tr;
    var props = this.buildProps(tr4, dispatch);
    var formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(function(_ref12) {
      var name = _ref12[0], command3 = _ref12[1];
      return [name, function() {
        return command3.apply(void 0, arguments)(_extends({}, props, { dispatch: void 0 }));
      }];
    }));
    return _extends({}, formattedCommands, { chain: function chain() {
      return _this39.createChain(tr4, dispatch);
    } });
  };
  _proto58.buildProps = function buildProps(tr4, shouldDispatch) {
    var _this40 = this;
    if (shouldDispatch === void 0) {
      shouldDispatch = true;
    }
    var rawCommands = this.rawCommands, editor = this.editor, state = this.state;
    var view = editor.view;
    var props = { tr: tr4, editor, view, state: createChainableState({ state, transaction: tr4 }), dispatch: shouldDispatch ? function() {
      return void 0;
    } : void 0, chain: function chain() {
      return _this40.createChain(tr4, shouldDispatch);
    }, can: function can() {
      return _this40.createCan(tr4);
    }, get commands() {
      return Object.fromEntries(Object.entries(rawCommands).map(function(_ref13) {
        var name = _ref13[0], command3 = _ref13[1];
        return [name, function() {
          return command3.apply(void 0, arguments)(props);
        }];
      }));
    } };
    return props;
  };
  _createClass(CommandManager2, [{ key: "hasCustomState", get: function get5() {
    return !!this.customState;
  } }, { key: "state", get: function get5() {
    return this.customState || this.editor.state;
  } }, { key: "commands", get: function get5() {
    var _this41 = this;
    var rawCommands = this.rawCommands, editor = this.editor, state = this.state;
    var view = editor.view;
    var tr4 = state.tr;
    var props = this.buildProps(tr4);
    return Object.fromEntries(Object.entries(rawCommands).map(function(_ref14) {
      var name = _ref14[0], command3 = _ref14[1];
      var method = function method2() {
        var callback = command3.apply(void 0, arguments)(props);
        if (!tr4.getMeta("preventDispatch") && !_this41.hasCustomState) {
          view.dispatch(tr4);
        }
        return callback;
      };
      return [name, method];
    }));
  } }, { key: "chain", get: function get5() {
    var _this42 = this;
    return function() {
      return _this42.createChain();
    };
  } }, { key: "can", get: function get5() {
    var _this43 = this;
    return function() {
      return _this43.createCan();
    };
  } }]);
  return CommandManager2;
}();
var EventEmitter = /* @__PURE__ */ function() {
  function EventEmitter2() {
    this.callbacks = {};
  }
  var _proto59 = EventEmitter2.prototype;
  _proto59.on = function on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  };
  _proto59.emit = function emit(event) {
    var _this44 = this;
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach(function(callback) {
        return callback.apply(_this44, args);
      });
    }
    return this;
  };
  _proto59.off = function off(event, fn2) {
    var callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter(function(callback) {
          return callback !== fn2;
        });
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  };
  _proto59.removeAllListeners = function removeAllListeners() {
    this.callbacks = {};
  };
  return EventEmitter2;
}();
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    var value = extension.config[field].bind(_extends({}, context, { parent: extension.parent ? getExtensionField(extension.parent, field, context) : null }));
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions2) {
  var baseExtensions = extensions2.filter(function(extension) {
    return extension.type === "extension";
  });
  var nodeExtensions = extensions2.filter(function(extension) {
    return extension.type === "node";
  });
  var markExtensions = extensions2.filter(function(extension) {
    return extension.type === "mark";
  });
  return { baseExtensions, nodeExtensions, markExtensions };
}
function getAttributesFromExtensions(extensions2) {
  var extensionAttributes = [];
  var _splitExtensions = splitExtensions(extensions2), nodeExtensions = _splitExtensions.nodeExtensions, markExtensions = _splitExtensions.markExtensions;
  var nodeAndMarkExtensions = [].concat(nodeExtensions, markExtensions);
  var defaultAttribute = { default: null, rendered: true, renderHTML: null, parseHTML: null, keepOnSplit: true, isRequired: false };
  extensions2.forEach(function(extension) {
    var context = { name: extension.name, options: extension.options, storage: extension.storage };
    var addGlobalAttributes3 = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes3) {
      return;
    }
    var globalAttributes = addGlobalAttributes3();
    globalAttributes.forEach(function(globalAttribute) {
      globalAttribute.types.forEach(function(type) {
        Object.entries(globalAttribute.attributes).forEach(function(_ref15) {
          var name = _ref15[0], attribute = _ref15[1];
          extensionAttributes.push({ type, name, attribute: _extends({}, defaultAttribute, attribute) });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach(function(extension) {
    var context = { name: extension.name, options: extension.options, storage: extension.storage };
    var addAttributes10 = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes10) {
      return;
    }
    var attributes = addAttributes10();
    Object.entries(attributes).forEach(function(_ref16) {
      var name = _ref16[0], attribute = _ref16[1];
      var mergedAttr = _extends({}, defaultAttribute, attribute);
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({ type: extension.name, name, attribute: mergedAttr });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error("There is no node type named '" + nameOrType + "'. Maybe you forgot to add the extension?");
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes() {
  for (var _len3 = arguments.length, objects = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    objects[_key3] = arguments[_key3];
  }
  return objects.filter(function(item) {
    return !!item;
  }).reduce(function(items, item) {
    var mergedAttributes = _extends({}, items);
    Object.entries(item).forEach(function(_ref17) {
      var key = _ref17[0], value = _ref17[1];
      var exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        var valueClasses = value ? value.split(" ") : [];
        var existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        var insertClasses = valueClasses.filter(function(valueClass) {
          return !existingClasses.includes(valueClass);
        });
        mergedAttributes[key] = [].concat(existingClasses, insertClasses).join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter(function(item) {
    return item.attribute.rendered;
  }).map(function(item) {
    if (!item.attribute.renderHTML) {
      var _ref18;
      return _ref18 = {}, _ref18[item.name] = nodeOrMark.attrs[item.name], _ref18;
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce(function(attributes, attribute) {
    return mergeAttributes(attributes, attribute);
  }, {});
}
function isFunction$1(value) {
  return typeof value === "function";
}
function callOrReturn(value, context) {
  if (context === void 0) {
    context = void 0;
  }
  if (isFunction$1(value)) {
    for (var _len4 = arguments.length, props = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
      props[_key4 - 2] = arguments[_key4];
    }
    if (context) {
      return value.bind(context).apply(void 0, props);
    }
    return value.apply(void 0, props);
  }
  return value;
}
function isEmptyObject(value) {
  if (value === void 0) {
    value = {};
  }
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if (parseRule.style) {
    return parseRule;
  }
  return _extends({}, parseRule, { getAttrs: function getAttrs(node) {
    var oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
    if (oldAttributes === false) {
      return false;
    }
    var newAttributes = extensionAttributes.reduce(function(items, item) {
      var _extends2;
      var value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
      if (value === null || value === void 0) {
        return items;
      }
      return _extends({}, items, (_extends2 = {}, _extends2[item.name] = value, _extends2));
    }, {});
    return _extends({}, oldAttributes, newAttributes);
  } });
}
function cleanUpSchemaItem(data2) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data2).filter(function(_ref19) {
      var key = _ref19[0], value = _ref19[1];
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions2, editor) {
  var _a;
  var allAttributes = getAttributesFromExtensions(extensions2);
  var _splitExtensions2 = splitExtensions(extensions2), nodeExtensions = _splitExtensions2.nodeExtensions, markExtensions = _splitExtensions2.markExtensions;
  var topNode = (_a = nodeExtensions.find(function(extension) {
    return getExtensionField(extension, "topNode");
  })) === null || _a === void 0 ? void 0 : _a.name;
  var nodes = Object.fromEntries(nodeExtensions.map(function(extension) {
    var extensionAttributes = allAttributes.filter(function(attribute) {
      return attribute.type === extension.name;
    });
    var context = { name: extension.name, options: extension.options, storage: extension.storage, editor };
    var extraNodeFields = extensions2.reduce(function(fields, e) {
      var extendNodeSchema3 = getExtensionField(e, "extendNodeSchema", context);
      return _extends({}, fields, extendNodeSchema3 ? extendNodeSchema3(extension) : {});
    }, {});
    var schema = cleanUpSchemaItem(_extends({}, extraNodeFields, { content: callOrReturn(getExtensionField(extension, "content", context)), marks: callOrReturn(getExtensionField(extension, "marks", context)), group: callOrReturn(getExtensionField(extension, "group", context)), inline: callOrReturn(getExtensionField(extension, "inline", context)), atom: callOrReturn(getExtensionField(extension, "atom", context)), selectable: callOrReturn(getExtensionField(extension, "selectable", context)), draggable: callOrReturn(getExtensionField(extension, "draggable", context)), code: callOrReturn(getExtensionField(extension, "code", context)), defining: callOrReturn(getExtensionField(extension, "defining", context)), isolating: callOrReturn(getExtensionField(extension, "isolating", context)), attrs: Object.fromEntries(extensionAttributes.map(function(extensionAttribute) {
      var _a2;
      return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
    })) }));
    var parseHTML31 = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML31) {
      schema.parseDOM = parseHTML31.map(function(parseRule) {
        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);
      });
    }
    var renderHTML31 = getExtensionField(extension, "renderHTML", context);
    if (renderHTML31) {
      schema.toDOM = function(node) {
        return renderHTML31({ node, HTMLAttributes: getRenderedAttributes(node, extensionAttributes) });
      };
    }
    var renderText2 = getExtensionField(extension, "renderText", context);
    if (renderText2) {
      schema.toText = renderText2;
    }
    return [extension.name, schema];
  }));
  var marks = Object.fromEntries(markExtensions.map(function(extension) {
    var extensionAttributes = allAttributes.filter(function(attribute) {
      return attribute.type === extension.name;
    });
    var context = { name: extension.name, options: extension.options, storage: extension.storage, editor };
    var extraMarkFields = extensions2.reduce(function(fields, e) {
      var extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return _extends({}, fields, extendMarkSchema ? extendMarkSchema(extension) : {});
    }, {});
    var schema = cleanUpSchemaItem(_extends({}, extraMarkFields, { inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)), excludes: callOrReturn(getExtensionField(extension, "excludes", context)), group: callOrReturn(getExtensionField(extension, "group", context)), spanning: callOrReturn(getExtensionField(extension, "spanning", context)), code: callOrReturn(getExtensionField(extension, "code", context)), attrs: Object.fromEntries(extensionAttributes.map(function(extensionAttribute) {
      var _a2;
      return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
    })) }));
    var parseHTML31 = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML31) {
      schema.parseDOM = parseHTML31.map(function(parseRule) {
        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);
      });
    }
    var renderHTML31 = getExtensionField(extension, "renderHTML", context);
    if (renderHTML31) {
      schema.toDOM = function(mark) {
        return renderHTML31({ mark, HTMLAttributes: getRenderedAttributes(mark, extensionAttributes) });
      };
    }
    return [extension.name, schema];
  }));
  return new Schema({ topNode, nodes, marks });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some(function(enabledExtension) {
      var name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
var getTextContentFromNodes = function getTextContentFromNodes2($from, maxMatch) {
  if (maxMatch === void 0) {
    maxMatch = 500;
  }
  var textBefore = "";
  var sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, function(node, pos, parent, index) {
    var _a, _b;
    var chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, { node, pos, parent, index })) || node.textContent || "%leaf%";
    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = function InputRule2(config) {
  this.find = config.find;
  this.handler = config.handler;
};
var inputRuleMatcherHandler = function inputRuleMatcherHandler2(text, find2) {
  if (isRegExp(find2)) {
    return find2.exec(text);
  }
  var inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  var result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1$1(config) {
  var _a;
  var editor = config.editor, from2 = config.from, to = config.to, text = config.text, rules = config.rules, plugin = config.plugin;
  var view = editor.view;
  if (view.composing) {
    return false;
  }
  var $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(function(mark) {
      return mark.type.spec.code;
    }))
  ) {
    return false;
  }
  var matched = false;
  var textBefore = getTextContentFromNodes($from) + text;
  rules.forEach(function(rule) {
    if (matched) {
      return;
    }
    var match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    var tr4 = view.state.tr;
    var state = createChainableState({ state: view.state, transaction: tr4 });
    var range = { from: from2 - (match[0].length - text.length), to };
    var _CommandManager = new CommandManager({ editor, state }), commands2 = _CommandManager.commands, chain = _CommandManager.chain, can = _CommandManager.can;
    var handler = rule.handler({ state, range, match, commands: commands2, chain, can });
    if (handler === null || !tr4.steps.length) {
      return;
    }
    tr4.setMeta(plugin, { transform: tr4, from: from2, to, text });
    view.dispatch(tr4);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  var editor = props.editor, rules = props.rules;
  var plugin = new Plugin({
    state: { init: function init6() {
      return null;
    }, apply: function apply6(tr4, prev) {
      var stored = tr4.getMeta(plugin);
      if (stored) {
        return stored;
      }
      return tr4.selectionSet || tr4.docChanged ? null : prev;
    } },
    props: {
      handleTextInput: function handleTextInput(view, from2, to, text) {
        return run$1$1({ editor, from: from2, to, text, rules, plugin });
      },
      handleDOMEvents: { compositionend: function compositionend(view) {
        setTimeout(function() {
          var $cursor = view.state.selection.$cursor;
          if ($cursor) {
            run$1$1({ editor, from: $cursor.pos, to: $cursor.pos, text: "", rules, plugin });
          }
        });
        return false;
      } },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown: function handleKeyDown2(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        var $cursor = view.state.selection.$cursor;
        if ($cursor) {
          return run$1$1({ editor, from: $cursor.pos, to: $cursor.pos, text: "\n", rules, plugin });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = function PasteRule2(config) {
  this.find = config.find;
  this.handler = config.handler;
};
var pasteRuleMatcherHandler = function pasteRuleMatcherHandler2(text, find2) {
  if (isRegExp(find2)) {
    return [].concat(text.matchAll(find2));
  }
  var matches2 = find2(text);
  if (!matches2) {
    return [];
  }
  return matches2.map(function(pasteRuleMatch) {
    var result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run$2(config) {
  var editor = config.editor, state = config.state, from2 = config.from, to = config.to, rule = config.rule, pasteEvent = config.pasteEvent, dropEvent = config.dropEvent;
  var _CommandManager2 = new CommandManager({ editor, state }), commands2 = _CommandManager2.commands, chain = _CommandManager2.chain, can = _CommandManager2.can;
  var handlers2 = [];
  state.doc.nodesBetween(from2, to, function(node, pos) {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    var resolvedFrom = Math.max(from2, pos);
    var resolvedTo = Math.min(to, pos + node.content.size);
    var textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "￼");
    var matches2 = pasteRuleMatcherHandler(textToMatch, rule.find);
    matches2.forEach(function(match) {
      if (match.index === void 0) {
        return;
      }
      var start2 = resolvedFrom + match.index + 1;
      var end2 = start2 + match[0].length;
      var range = { from: state.tr.mapping.map(start2), to: state.tr.mapping.map(end2) };
      var handler = rule.handler({ state, range, match, commands: commands2, chain, can, pasteEvent, dropEvent });
      handlers2.push(handler);
    });
  });
  var success = handlers2.every(function(handler) {
    return handler !== null;
  });
  return success;
}
function pasteRulesPlugin(props) {
  var editor = props.editor, rules = props.rules;
  var dragSourceElement = null;
  var isPastedFromProseMirror = false;
  var isDroppedFromProseMirror = false;
  var pasteEvent = new ClipboardEvent("paste");
  var dropEvent = new DragEvent("drop");
  var plugins = rules.map(function(rule) {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view: function view(_view2) {
        var handleDragstart = function handleDragstart2(event) {
          var _a;
          dragSourceElement = ((_a = _view2.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? _view2.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return { destroy: function destroy() {
          window.removeEventListener("dragstart", handleDragstart);
        } };
      },
      props: { handleDOMEvents: { drop: function drop(view, event) {
        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
        dropEvent = event;
        return false;
      }, paste: function paste(_view, event) {
        var _a;
        var html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
        pasteEvent = event;
        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
        return false;
      } } },
      appendTransaction: function appendTransaction(transactions, oldState, state) {
        var transaction = transactions[0];
        var isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        var isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        var from2 = oldState.doc.content.findDiffStart(state.doc.content);
        var to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        var tr4 = state.tr;
        var chainableState = createChainableState({ state, transaction: tr4 });
        var handler = run$2({ editor, state: chainableState, from: Math.max(from2 - 1, 0), to: to.b - 1, rule, pasteEvent, dropEvent });
        if (!handler || !tr4.steps.length) {
          return;
        }
        dropEvent = new DragEvent("drop");
        pasteEvent = new ClipboardEvent("paste");
        return tr4;
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  var filtered = items.filter(function(el, index) {
    return items.indexOf(el) !== index;
  });
  return [].concat(new Set(filtered));
}
var ExtensionManager = /* @__PURE__ */ function() {
  function ExtensionManager2(extensions2, editor) {
    var _this45 = this;
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager2.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.extensions.forEach(function(extension) {
      var _a;
      _this45.editor.extensionStorage[extension.name] = extension.storage;
      var context = { name: extension.name, options: extension.options, storage: extension.storage, editor: _this45.editor, type: getSchemaTypeByName(extension.name, _this45.schema) };
      if (extension.type === "mark") {
        var keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          _this45.splittableMarks.push(extension.name);
        }
      }
      var onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        _this45.editor.on("beforeCreate", onBeforeCreate);
      }
      var onCreate3 = getExtensionField(extension, "onCreate", context);
      if (onCreate3) {
        _this45.editor.on("create", onCreate3);
      }
      var onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        _this45.editor.on("update", onUpdate);
      }
      var onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        _this45.editor.on("selectionUpdate", onSelectionUpdate);
      }
      var onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        _this45.editor.on("transaction", onTransaction);
      }
      var onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        _this45.editor.on("focus", onFocus);
      }
      var onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        _this45.editor.on("blur", onBlur);
      }
      var onDestroy3 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy3) {
        _this45.editor.on("destroy", onDestroy3);
      }
    });
  }
  ExtensionManager2.resolve = function resolve2(extensions2) {
    var resolvedExtensions = ExtensionManager2.sort(ExtensionManager2.flatten(extensions2));
    var duplicatedNames = findDuplicates(resolvedExtensions.map(function(extension) {
      return extension.name;
    }));
    if (duplicatedNames.length) {
      console.warn("[tiptap warn]: Duplicate extension names found: [" + duplicatedNames.map(function(item) {
        return "'" + item + "'";
      }).join(", ") + "]. This can lead to issues.");
    }
    return resolvedExtensions;
  };
  ExtensionManager2.flatten = function flatten(extensions2) {
    var _this46 = this;
    return extensions2.map(function(extension) {
      var context = { name: extension.name, options: extension.options, storage: extension.storage };
      var addExtensions2 = getExtensionField(extension, "addExtensions", context);
      if (addExtensions2) {
        return [extension].concat(_this46.flatten(addExtensions2()));
      }
      return extension;
    }).flat(10);
  };
  ExtensionManager2.sort = function sort(extensions2) {
    var defaultPriority = 100;
    return extensions2.sort(function(a, b) {
      var priorityA = getExtensionField(a, "priority") || defaultPriority;
      var priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  };
  _createClass(ExtensionManager2, [{ key: "commands", get: function get5() {
    var _this47 = this;
    return this.extensions.reduce(function(commands2, extension) {
      var context = { name: extension.name, options: extension.options, storage: extension.storage, editor: _this47.editor, type: getSchemaTypeByName(extension.name, _this47.schema) };
      var addCommands28 = getExtensionField(extension, "addCommands", context);
      if (!addCommands28) {
        return commands2;
      }
      return _extends({}, commands2, addCommands28());
    }, {});
  } }, { key: "plugins", get: function get5() {
    var _this48 = this;
    var editor = this.editor;
    var extensions2 = ExtensionManager2.sort([].concat(this.extensions).reverse());
    var inputRules = [];
    var pasteRules = [];
    var allPlugins = extensions2.map(function(extension) {
      var context = { name: extension.name, options: extension.options, storage: extension.storage, editor, type: getSchemaTypeByName(extension.name, _this48.schema) };
      var plugins = [];
      var addKeyboardShortcuts25 = getExtensionField(extension, "addKeyboardShortcuts", context);
      var defaultBindings = {};
      if (extension.type === "mark" && extension.config.exitable) {
        defaultBindings.ArrowRight = function() {
          return Mark.handleExit({ editor, mark: extension });
        };
      }
      if (addKeyboardShortcuts25) {
        var bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts25()).map(function(_ref20) {
          var shortcut = _ref20[0], method = _ref20[1];
          return [shortcut, function() {
            return method({ editor });
          }];
        }));
        defaultBindings = _extends({}, defaultBindings, bindings);
      }
      var keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      var addInputRules14 = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules14) {
        inputRules.push.apply(inputRules, addInputRules14());
      }
      var addPasteRules7 = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules7) {
        pasteRules.push.apply(pasteRules, addPasteRules7());
      }
      var addProseMirrorPlugins16 = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins16) {
        var proseMirrorPlugins = addProseMirrorPlugins16();
        plugins.push.apply(plugins, proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [inputRulesPlugin({ editor, rules: inputRules })].concat(pasteRulesPlugin({ editor, rules: pasteRules }), allPlugins);
  } }, { key: "attributes", get: function get5() {
    return getAttributesFromExtensions(this.extensions);
  } }, { key: "nodeViews", get: function get5() {
    var _this49 = this;
    var editor = this.editor;
    var _splitExtensions3 = splitExtensions(this.extensions), nodeExtensions = _splitExtensions3.nodeExtensions;
    return Object.fromEntries(nodeExtensions.filter(function(extension) {
      return !!getExtensionField(extension, "addNodeView");
    }).map(function(extension) {
      var extensionAttributes = _this49.attributes.filter(function(attribute) {
        return attribute.type === extension.name;
      });
      var context = { name: extension.name, options: extension.options, storage: extension.storage, editor, type: getNodeType(extension.name, _this49.schema) };
      var addNodeView2 = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView2) {
        return [];
      }
      var nodeview = function nodeview2(node, view, getPos, decorations) {
        var HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView2()({ editor, node, getPos, decorations, HTMLAttributes, extension });
      };
      return [extension.name, nodeview];
    }));
  } }]);
  return ExtensionManager2;
}();
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source2) {
  var output = _extends({}, target);
  if (isPlainObject(target) && isPlainObject(source2)) {
    Object.keys(source2).forEach(function(key) {
      if (isPlainObject(source2[key])) {
        if (!(key in target)) {
          var _Object$assign3;
          Object.assign(output, (_Object$assign3 = {}, _Object$assign3[key] = source2[key], _Object$assign3));
        } else {
          output[key] = mergeDeep(target[key], source2[key]);
        }
      } else {
        var _Object$assign4;
        Object.assign(output, (_Object$assign4 = {}, _Object$assign4[key] = source2[key], _Object$assign4));
      }
    });
  }
  return output;
}
var Extension = /* @__PURE__ */ function() {
  function Extension2(config) {
    if (config === void 0) {
      config = {};
    }
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = { name: this.name, defaultOptions: {} };
    this.config = _extends({}, this.config, config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn('[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "' + this.name + '".');
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", { name: this.name }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", { name: this.name, options: this.options })) || {};
  }
  Extension2.create = function create2(config) {
    if (config === void 0) {
      config = {};
    }
    return new Extension2(config);
  };
  var _proto60 = Extension2.prototype;
  _proto60.configure = function configure(options) {
    if (options === void 0) {
      options = {};
    }
    var extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", { name: extension.name, options: extension.options }));
    return extension;
  };
  _proto60.extend = function extend(extendedConfig) {
    if (extendedConfig === void 0) {
      extendedConfig = {};
    }
    var extension = new Extension2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn('[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "' + extension.name + '".');
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", { name: extension.name }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", { name: extension.name, options: extension.options }));
    return extension;
  };
  return Extension2;
}();
function getTextBetween(startNode, range, options) {
  var from2 = range.from, to = range.to;
  var _ref21 = options || {}, _ref21$blockSeparator = _ref21.blockSeparator, blockSeparator = _ref21$blockSeparator === void 0 ? "\n\n" : _ref21$blockSeparator, _ref21$textSerializer = _ref21.textSerializers, textSerializers = _ref21$textSerializer === void 0 ? {} : _ref21$textSerializer;
  var text = "";
  var separated = true;
  startNode.nodesBetween(from2, to, function(node, pos, parent, index) {
    var _a;
    var textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (node.isBlock && !separated) {
        text += blockSeparator;
        separated = true;
      }
      if (parent) {
        text += textSerializer({ node, pos, parent, index, range });
      }
    } else if (node.isText) {
      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
      separated = false;
    } else if (node.isBlock && !separated) {
      text += blockSeparator;
      separated = true;
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(function(_ref22) {
    var node = _ref22[1];
    return node.spec.toText;
  }).map(function(_ref23) {
    var name = _ref23[0], node = _ref23[1];
    return [name, node.spec.toText];
  }));
}
var ClipboardTextSerializer = Extension.create({ name: "clipboardTextSerializer", addProseMirrorPlugins: function addProseMirrorPlugins() {
  var _this50 = this;
  return [new Plugin({ key: new PluginKey("clipboardTextSerializer"), props: { clipboardTextSerializer: function clipboardTextSerializer() {
    var editor = _this50.editor;
    var state = editor.state, schema = editor.schema;
    var doc2 = state.doc, selection = state.selection;
    var ranges = selection.ranges;
    var from2 = Math.min.apply(Math, ranges.map(function(range2) {
      return range2.$from.pos;
    }));
    var to = Math.max.apply(Math, ranges.map(function(range2) {
      return range2.$to.pos;
    }));
    var textSerializers = getTextSerializersFromSchema(schema);
    var range = { from: from2, to };
    return getTextBetween(doc2, range, { textSerializers });
  } } })];
} });
var blur = function blur2() {
  return function(_ref24) {
    var editor = _ref24.editor, view = _ref24.view;
    requestAnimationFrame(function() {
      var _a;
      if (!editor.isDestroyed) {
        view.dom.blur();
        (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
      }
    });
    return true;
  };
};
var clearContent = function clearContent2(emitUpdate) {
  if (emitUpdate === void 0) {
    emitUpdate = false;
  }
  return function(_ref25) {
    var commands2 = _ref25.commands;
    return commands2.setContent("", emitUpdate);
  };
};
var clearNodes = function clearNodes2() {
  return function(_ref26) {
    var state = _ref26.state, tr4 = _ref26.tr, dispatch = _ref26.dispatch;
    var selection = tr4.selection;
    var ranges = selection.ranges;
    if (!dispatch) {
      return true;
    }
    ranges.forEach(function(_ref27) {
      var $from = _ref27.$from, $to = _ref27.$to;
      state.doc.nodesBetween($from.pos, $to.pos, function(node, pos) {
        if (node.type.isText) {
          return;
        }
        var doc2 = tr4.doc, mapping = tr4.mapping;
        var $mappedFrom = doc2.resolve(mapping.map(pos));
        var $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
        var nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        var targetLiftDepth = liftTarget(nodeRange);
        if (node.type.isTextblock) {
          var _$mappedFrom$parent$c = $mappedFrom.parent.contentMatchAt($mappedFrom.index()), defaultType = _$mappedFrom$parent$c.defaultType;
          tr4.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr4.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
};
var command = function command2(fn2) {
  return function(props) {
    return fn2(props);
  };
};
var createParagraphNear = function createParagraphNear2() {
  return function(_ref28) {
    var state = _ref28.state, dispatch = _ref28.dispatch;
    return createParagraphNear$1(state, dispatch);
  };
};
var cut = function cut2(originRange, targetPos) {
  return function(_ref29) {
    var editor = _ref29.editor, tr4 = _ref29.tr;
    var state = editor.state;
    var contentSlice = state.doc.slice(originRange.from, originRange.to);
    tr4.deleteRange(originRange.from, originRange.to);
    var newPos = tr4.mapping.map(targetPos);
    tr4.insert(newPos, contentSlice.content);
    tr4.setSelection(new TextSelection(tr4.doc.resolve(newPos - 1)));
    return true;
  };
};
var deleteCurrentNode = function deleteCurrentNode2() {
  return function(_ref30) {
    var tr4 = _ref30.tr, dispatch = _ref30.dispatch;
    var selection = tr4.selection;
    var currentNode = selection.$anchor.node();
    if (currentNode.content.size > 0) {
      return false;
    }
    var $pos = tr4.selection.$anchor;
    for (var depth = $pos.depth; depth > 0; depth -= 1) {
      var node = $pos.node(depth);
      if (node.type === currentNode.type) {
        if (dispatch) {
          var _from11 = $pos.before(depth);
          var to = $pos.after(depth);
          tr4.delete(_from11, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
};
var deleteNode = function deleteNode2(typeOrName) {
  return function(_ref31) {
    var tr4 = _ref31.tr, state = _ref31.state, dispatch = _ref31.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    var $pos = tr4.selection.$anchor;
    for (var depth = $pos.depth; depth > 0; depth -= 1) {
      var node = $pos.node(depth);
      if (node.type === type) {
        if (dispatch) {
          var _from12 = $pos.before(depth);
          var to = $pos.after(depth);
          tr4.delete(_from12, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
};
var deleteRange = function deleteRange2(range) {
  return function(_ref32) {
    var tr4 = _ref32.tr, dispatch = _ref32.dispatch;
    var from2 = range.from, to = range.to;
    if (dispatch) {
      tr4.delete(from2, to);
    }
    return true;
  };
};
var deleteSelection = function deleteSelection2() {
  return function(_ref33) {
    var state = _ref33.state, dispatch = _ref33.dispatch;
    return deleteSelection$1(state, dispatch);
  };
};
var enter = function enter2() {
  return function(_ref34) {
    var commands2 = _ref34.commands;
    return commands2.keyboardShortcut("Enter");
  };
};
var exitCode = function exitCode2() {
  return function(_ref35) {
    var state = _ref35.state, dispatch = _ref35.dispatch;
    return exitCode$1(state, dispatch);
  };
};
function objectIncludes(object1, object2, options) {
  if (options === void 0) {
    options = { strict: true };
  }
  var keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every(function(key) {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return marks.find(function(item) {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  if (!$pos || !type) {
    return;
  }
  var start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) {
    return;
  }
  var mark = findMarkInSet([].concat(start2.node.marks), type, attributes);
  if (!mark) {
    return;
  }
  var startIndex2 = start2.index;
  var startPos = $pos.start() + start2.offset;
  var endIndex2 = startIndex2 + 1;
  var endPos = startPos + start2.node.nodeSize;
  findMarkInSet([].concat(start2.node.marks), type, attributes);
  while (startIndex2 > 0 && mark.isInSet($pos.parent.child(startIndex2 - 1).marks)) {
    startIndex2 -= 1;
    startPos -= $pos.parent.child(startIndex2).nodeSize;
  }
  while (endIndex2 < $pos.parent.childCount && isMarkInSet([].concat($pos.parent.child(endIndex2).marks), type, attributes)) {
    endPos += $pos.parent.child(endIndex2).nodeSize;
    endIndex2 += 1;
  }
  return { from: startPos, to: endPos };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error("There is no mark type named '" + nameOrType + "'. Maybe you forgot to add the extension?");
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = function extendMarkRange2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref36) {
    var tr4 = _ref36.tr, state = _ref36.state, dispatch = _ref36.dispatch;
    var type = getMarkType(typeOrName, state.schema);
    var doc2 = tr4.doc, selection = tr4.selection;
    var $from = selection.$from, from2 = selection.from, to = selection.to;
    if (dispatch) {
      var range = getMarkRange($from, type, attributes);
      if (range && range.from <= from2 && range.to >= to) {
        var newSelection = TextSelection.create(doc2, range.from, range.to);
        tr4.setSelection(newSelection);
      }
    }
    return true;
  };
};
var first = function first2(commands2) {
  return function(props) {
    var items = typeof commands2 === "function" ? commands2(props) : commands2;
    for (var _i199 = 0; _i199 < items.length; _i199 += 1) {
      if (items[_i199](props)) {
        return true;
      }
    }
    return false;
  };
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value, min2, max2) {
  if (value === void 0) {
    value = 0;
  }
  if (min2 === void 0) {
    min2 = 0;
  }
  if (max2 === void 0) {
    max2 = 0;
  }
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc2, position) {
  if (position === void 0) {
    position = null;
  }
  if (!position) {
    return null;
  }
  var selectionAtStart = Selection.atStart(doc2);
  var selectionAtEnd = Selection.atEnd(doc2);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  var minPos = selectionAtStart.from;
  var maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = function focus2(position, options) {
  if (position === void 0) {
    position = null;
  }
  if (options === void 0) {
    options = {};
  }
  return function(_ref37) {
    var editor = _ref37.editor, view = _ref37.view, tr4 = _ref37.tr, dispatch = _ref37.dispatch;
    options = _extends({ scrollIntoView: true }, options);
    var delayedFocus = function delayedFocus2() {
      if (isiOS()) {
        view.dom.focus();
      }
      requestAnimationFrame(function() {
        if (!editor.isDestroyed) {
          view.focus();
          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
            editor.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position === null || position === false) {
      return true;
    }
    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
      delayedFocus();
      return true;
    }
    var selection = resolveFocusPosition(tr4.doc, position) || editor.state.selection;
    var isSameSelection = editor.state.selection.eq(selection);
    if (dispatch) {
      if (!isSameSelection) {
        tr4.setSelection(selection);
      }
      if (isSameSelection && tr4.storedMarks) {
        tr4.setStoredMarks(tr4.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
};
var forEach2 = function forEach3(items, fn2) {
  return function(props) {
    return items.every(function(item, index) {
      return fn2(item, _extends({}, props, { index }));
    });
  };
};
var insertContent = function insertContent2(value, options) {
  return function(_ref38) {
    var tr4 = _ref38.tr, commands2 = _ref38.commands;
    return commands2.insertContentAt({ from: tr4.selection.from, to: tr4.selection.to }, value, options);
  };
};
function elementFromString(value) {
  var wrappedValue = "<body>" + value + "</body>";
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function createNodeFromContent(content5, schema, options) {
  options = _extends({ slice: true, parseOptions: {} }, options);
  if (typeof content5 === "object" && content5 !== null) {
    try {
      if (Array.isArray(content5) && content5.length > 0) {
        return Fragment.fromArray(content5.map(function(item) {
          return schema.nodeFromJSON(item);
        }));
      }
      return schema.nodeFromJSON(content5);
    } catch (error3) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content5, "Error:", error3);
      return createNodeFromContent("", schema, options);
    }
  }
  if (typeof content5 === "string") {
    var parser = DOMParser.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content5), options.parseOptions).content : parser.parse(elementFromString(content5), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr4, startLen, bias) {
  var last = tr4.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step = tr4.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  var map3 = tr4.mapping.maps[last];
  var end2 = 0;
  map3.forEach(function(_from, _to, _newFrom, newTo) {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr4.setSelection(Selection.near(tr4.doc.resolve(end2), bias));
}
var isFragment = function isFragment2(nodeOrFragment) {
  return nodeOrFragment.toString().startsWith("<");
};
var insertContentAt = function insertContentAt2(position, value, options) {
  return function(_ref39) {
    var tr4 = _ref39.tr, dispatch = _ref39.dispatch, editor = _ref39.editor;
    if (dispatch) {
      options = _extends({ parseOptions: {}, updateSelection: true }, options);
      var content5 = createNodeFromContent(value, editor.schema, { parseOptions: _extends({ preserveWhitespace: "full" }, options.parseOptions) });
      if (content5.toString() === "<>") {
        return true;
      }
      var _ref40 = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to }, _from13 = _ref40.from, to = _ref40.to;
      var isOnlyTextContent = true;
      var isOnlyBlockContent = true;
      var nodes = isFragment(content5) ? content5 : [content5];
      nodes.forEach(function(node) {
        node.check();
        isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
      });
      if (_from13 === to && isOnlyBlockContent) {
        var _tr$doc$resolve = tr4.doc.resolve(_from13), parent = _tr$doc$resolve.parent;
        var isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          _from13 -= 1;
          to += 1;
        }
      }
      if (isOnlyTextContent) {
        if (Array.isArray(value)) {
          tr4.insertText(value.map(function(v) {
            return v.text || "";
          }).join(""), _from13, to);
        } else if (typeof value === "object" && !!value && !!value.text) {
          tr4.insertText(value.text, _from13, to);
        } else {
          tr4.insertText(value, _from13, to);
        }
      } else {
        tr4.replaceWith(_from13, to, content5);
      }
      if (options.updateSelection) {
        selectionToInsertionEnd(tr4, tr4.steps.length - 1, -1);
      }
    }
    return true;
  };
};
var joinUp = function joinUp2() {
  return function(_ref41) {
    var state = _ref41.state, dispatch = _ref41.dispatch;
    return joinUp$1(state, dispatch);
  };
};
var joinDown = function joinDown2() {
  return function(_ref42) {
    var state = _ref42.state, dispatch = _ref42.dispatch;
    return joinDown$1(state, dispatch);
  };
};
var joinBackward = function joinBackward2() {
  return function(_ref43) {
    var state = _ref43.state, dispatch = _ref43.dispatch;
    return joinBackward$1(state, dispatch);
  };
};
var joinForward = function joinForward2() {
  return function(_ref44) {
    var state = _ref44.state, dispatch = _ref44.dispatch;
    return joinForward$1(state, dispatch);
  };
};
var joinItemBackward = function joinItemBackward2() {
  return function(_ref45) {
    var tr4 = _ref45.tr, state = _ref45.state, dispatch = _ref45.dispatch;
    try {
      var point = joinPoint(state.doc, state.selection.$from.pos, -1);
      if (point === null || point === void 0) {
        return false;
      }
      tr4.join(point, 2);
      if (dispatch) {
        dispatch(tr4);
      }
      return true;
    } catch (_unused) {
      return false;
    }
  };
};
var joinItemForward = function joinItemForward2() {
  return function(_ref46) {
    var state = _ref46.state, dispatch = _ref46.dispatch, tr4 = _ref46.tr;
    try {
      var point = joinPoint(state.doc, state.selection.$from.pos, 1);
      if (point === null || point === void 0) {
        return false;
      }
      tr4.join(point, 2);
      if (dispatch) {
        dispatch(tr4);
      }
      return true;
    } catch (e) {
      return false;
    }
  };
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/);
  var result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  var alt;
  var ctrl;
  var shift2;
  var meta;
  for (var _i200 = 0; _i200 < parts.length - 1; _i200 += 1) {
    var mod = parts[_i200];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result = "Alt-" + result;
  }
  if (ctrl) {
    result = "Ctrl-" + result;
  }
  if (meta) {
    result = "Meta-" + result;
  }
  if (shift2) {
    result = "Shift-" + result;
  }
  return result;
}
var keyboardShortcut = function keyboardShortcut2(name) {
  return function(_ref47) {
    var editor = _ref47.editor, view = _ref47.view, tr4 = _ref47.tr, dispatch = _ref47.dispatch;
    var keys2 = normalizeKeyName(name).split(/-(?!$)/);
    var key = keys2.find(function(item) {
      return !["Alt", "Ctrl", "Meta", "Shift"].includes(item);
    });
    var event = new KeyboardEvent("keydown", { key: key === "Space" ? " " : key, altKey: keys2.includes("Alt"), ctrlKey: keys2.includes("Ctrl"), metaKey: keys2.includes("Meta"), shiftKey: keys2.includes("Shift"), bubbles: true, cancelable: true });
    var capturedTransaction = editor.captureTransaction(function() {
      view.someProp("handleKeyDown", function(f) {
        return f(view, event);
      });
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(function(step) {
      var newStep = step.map(tr4.mapping);
      if (newStep && dispatch) {
        tr4.maybeStep(newStep);
      }
    });
    return true;
  };
};
function isNodeActive(state, typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  var _state$selection12 = state.selection, from2 = _state$selection12.from, to = _state$selection12.to, empty2 = _state$selection12.empty;
  var type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  var nodeRanges = [];
  state.doc.nodesBetween(from2, to, function(node, pos) {
    if (node.isText) {
      return;
    }
    var relativeFrom = Math.max(from2, pos);
    var relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({ node, from: relativeFrom, to: relativeTo });
  });
  var selectionRange = to - from2;
  var matchedNodeRanges = nodeRanges.filter(function(nodeRange) {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter(function(nodeRange) {
    return objectIncludes(nodeRange.node.attrs, attributes, { strict: false });
  });
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  var range = matchedNodeRanges.reduce(function(sum, nodeRange) {
    return sum + nodeRange.to - nodeRange.from;
  }, 0);
  return range >= selectionRange;
}
var lift = function lift2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref48) {
    var state = _ref48.state, dispatch = _ref48.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    var isActive = isNodeActive(state, type, attributes);
    if (!isActive) {
      return false;
    }
    return lift$1(state, dispatch);
  };
};
var liftEmptyBlock = function liftEmptyBlock2() {
  return function(_ref49) {
    var state = _ref49.state, dispatch = _ref49.dispatch;
    return liftEmptyBlock$1(state, dispatch);
  };
};
var liftListItem = function liftListItem2(typeOrName) {
  return function(_ref50) {
    var state = _ref50.state, dispatch = _ref50.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return liftListItem$1(type)(state, dispatch);
  };
};
var newlineInCode = function newlineInCode2() {
  return function(_ref51) {
    var state = _ref51.state, dispatch = _ref51.dispatch;
    return newlineInCode$1(state, dispatch);
  };
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  var props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce(function(newObj, prop) {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = function resetAttributes2(typeOrName, attributes) {
  return function(_ref52) {
    var tr4 = _ref52.tr, state = _ref52.state, dispatch = _ref52.dispatch;
    var nodeType = null;
    var markType = null;
    var schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr4.selection.ranges.forEach(function(range) {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, function(node, pos) {
          if (nodeType && nodeType === node.type) {
            tr4.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
          }
          if (markType && node.marks.length) {
            node.marks.forEach(function(mark) {
              if (markType === mark.type) {
                tr4.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
};
var scrollIntoView = function scrollIntoView2() {
  return function(_ref53) {
    var tr4 = _ref53.tr, dispatch = _ref53.dispatch;
    if (dispatch) {
      tr4.scrollIntoView();
    }
    return true;
  };
};
var selectAll = function selectAll2() {
  return function(_ref54) {
    var tr4 = _ref54.tr, commands2 = _ref54.commands;
    return commands2.setTextSelection({ from: 0, to: tr4.doc.content.size });
  };
};
var selectNodeBackward = function selectNodeBackward2() {
  return function(_ref55) {
    var state = _ref55.state, dispatch = _ref55.dispatch;
    return selectNodeBackward$1(state, dispatch);
  };
};
var selectNodeForward = function selectNodeForward2() {
  return function(_ref56) {
    var state = _ref56.state, dispatch = _ref56.dispatch;
    return selectNodeForward$1(state, dispatch);
  };
};
var selectParentNode = function selectParentNode2() {
  return function(_ref57) {
    var state = _ref57.state, dispatch = _ref57.dispatch;
    return selectParentNode$1(state, dispatch);
  };
};
var selectTextblockEnd = function selectTextblockEnd2() {
  return function(_ref58) {
    var state = _ref58.state, dispatch = _ref58.dispatch;
    return selectTextblockEnd$1(state, dispatch);
  };
};
var selectTextblockStart = function selectTextblockStart2() {
  return function(_ref59) {
    var state = _ref59.state, dispatch = _ref59.dispatch;
    return selectTextblockStart$1(state, dispatch);
  };
};
function createDocument(content5, schema, parseOptions) {
  if (parseOptions === void 0) {
    parseOptions = {};
  }
  return createNodeFromContent(content5, schema, { slice: false, parseOptions });
}
var setContent$1 = function setContent$12(content5, emitUpdate, parseOptions) {
  if (emitUpdate === void 0) {
    emitUpdate = false;
  }
  if (parseOptions === void 0) {
    parseOptions = {};
  }
  return function(_ref60) {
    var tr4 = _ref60.tr, editor = _ref60.editor, dispatch = _ref60.dispatch;
    var doc2 = tr4.doc;
    var document2 = createDocument(content5, editor.schema, parseOptions);
    if (dispatch) {
      tr4.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  };
};
function getMarkAttributes(state, typeOrName) {
  var type = getMarkType(typeOrName, state.schema);
  var _state$selection13 = state.selection, from2 = _state$selection13.from, to = _state$selection13.to, empty2 = _state$selection13.empty;
  var marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push.apply(marks, state.storedMarks);
    }
    marks.push.apply(marks, state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, function(node) {
      marks.push.apply(marks, node.marks);
    });
  }
  var mark = marks.find(function(markItem) {
    return markItem.type.name === type.name;
  });
  if (!mark) {
    return {};
  }
  return _extends({}, mark.attrs);
}
function combineTransactionSteps(oldDoc, transactions) {
  var transform = new Transform(oldDoc);
  transactions.forEach(function(transaction) {
    transaction.steps.forEach(function(step) {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt(match) {
  for (var _i201 = 0; _i201 < match.edgeCount; _i201 += 1) {
    var _match$edge3 = match.edge(_i201), type = _match$edge3.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildren(node, predicate) {
  var nodesWithPos = [];
  node.descendants(function(child, pos) {
    if (predicate(child)) {
      nodesWithPos.push({ node: child, pos });
    }
  });
  return nodesWithPos;
}
function findChildrenInRange(node, range, predicate) {
  var nodesWithPos = [];
  node.nodesBetween(range.from, range.to, function(child, pos) {
    if (predicate(child)) {
      nodesWithPos.push({ node: child, pos });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (var _i202 = $pos.depth; _i202 > 0; _i202 -= 1) {
    var node = $pos.node(_i202);
    if (predicate(node)) {
      return { pos: _i202 > 0 ? $pos.before(_i202) : 0, start: $pos.start(_i202), depth: _i202, node };
    }
  }
}
function findParentNode(predicate) {
  return function(selection) {
    return findParentNodeClosestToPos(selection.$from, predicate);
  };
}
function getHTMLFromFragment(fragment, schema) {
  var documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  var temporaryDocument = document.implementation.createHTMLDocument();
  var container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function _getText(node, options) {
  var range = { from: 0, to: node.content.size };
  return getTextBetween(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  var type = getNodeType(typeOrName, state.schema);
  var _state$selection14 = state.selection, from2 = _state$selection14.from, to = _state$selection14.to;
  var nodes = [];
  state.doc.nodesBetween(from2, to, function(node2) {
    nodes.push(node2);
  });
  var node = nodes.reverse().find(function(nodeItem) {
    return nodeItem.type.name === type.name;
  });
  if (!node) {
    return {};
  }
  return _extends({}, node.attrs);
}
function _getAttributes(state, typeOrName) {
  var schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by) {
  if (by === void 0) {
    by = JSON.stringify;
  }
  var seen = {};
  return array.filter(function(item) {
    var key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  var uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter(function(change, index) {
    var rest = uniqueChanges.filter(function(_, i) {
      return i !== index;
    });
    return !rest.some(function(otherChange) {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  var mapping = transform.mapping, steps = transform.steps;
  var changes = [];
  mapping.maps.forEach(function(stepMap, index) {
    var ranges = [];
    if (!stepMap.ranges.length) {
      var _steps$index = steps[index], _from14 = _steps$index.from, to = _steps$index.to;
      if (_from14 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: _from14, to });
    } else {
      stepMap.forEach(function(from2, to2) {
        ranges.push({ from: from2, to: to2 });
      });
    }
    ranges.forEach(function(_ref61) {
      var from2 = _ref61.from, to2 = _ref61.to;
      var newStart = mapping.slice(index).map(from2, -1);
      var newEnd = mapping.slice(index).map(to2);
      var oldStart = mapping.invert().map(newStart, -1);
      var oldEnd = mapping.invert().map(newEnd);
      changes.push({ oldRange: { from: oldStart, to: oldEnd }, newRange: { from: newStart, to: newEnd } });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc2) {
  var marks = [];
  if (from2 === to) {
    doc2.resolve(from2).marks().forEach(function(mark) {
      var $pos = doc2.resolve(from2 - 1);
      var range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push(_extends({ mark }, range));
    });
  } else {
    doc2.nodesBetween(from2, to, function(node, pos) {
      marks.push.apply(marks, node.marks.map(function(mark) {
        return { from: pos, to: pos + node.nodeSize, mark };
      }));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(function(_ref62) {
    var name = _ref62[0];
    var extensionAttribute = extensionAttributes.find(function(item) {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  var _state$selection15 = state.selection, empty2 = _state$selection15.empty, ranges = _state$selection15.ranges;
  var type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter(function(mark) {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find(function(mark) {
      return objectIncludes(mark.attrs, attributes, { strict: false });
    });
  }
  var selectionRange = 0;
  var markRanges = [];
  ranges.forEach(function(_ref63) {
    var $from = _ref63.$from, $to = _ref63.$to;
    var from2 = $from.pos;
    var to = $to.pos;
    state.doc.nodesBetween(from2, to, function(node, pos) {
      if (!node.isText && !node.marks.length) {
        return;
      }
      var relativeFrom = Math.max(from2, pos);
      var relativeTo = Math.min(to, pos + node.nodeSize);
      var range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push.apply(markRanges, node.marks.map(function(mark) {
        return { mark, from: relativeFrom, to: relativeTo };
      }));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  var matchedRange = markRanges.filter(function(markRange) {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter(function(markRange) {
    return objectIncludes(markRange.mark.attrs, attributes, { strict: false });
  }).reduce(function(sum, markRange) {
    return sum + markRange.to - markRange.from;
  }, 0);
  var excludedRange = markRanges.filter(function(markRange) {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce(function(sum, markRange) {
    return sum + markRange.to - markRange.from;
  }, 0);
  var range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function _isActive(state, name, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  var schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions2) {
  var _splitExtensions4 = splitExtensions(extensions2), nodeExtensions = _splitExtensions4.nodeExtensions;
  var extension = nodeExtensions.find(function(item) {
    return item.name === name;
  });
  if (!extension) {
    return false;
  }
  var context = { name: extension.name, options: extension.options, storage: extension.storage };
  var group2 = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group2 !== "string") {
    return false;
  }
  return group2.split(" ").includes("list");
}
function isNodeEmpty(node) {
  var _a;
  var defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  var content5 = node.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content5);
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  var minPos = 0;
  var maxPos = view.state.doc.content.size;
  var resolvedFrom = minMax(from2, minPos, maxPos);
  var resolvedEnd = minMax(to, minPos, maxPos);
  var start2 = view.coordsAtPos(resolvedFrom);
  var end2 = view.coordsAtPos(resolvedEnd, -1);
  var top2 = Math.min(start2.top, end2.top);
  var bottom2 = Math.max(start2.bottom, end2.bottom);
  var left2 = Math.min(start2.left, end2.left);
  var right2 = Math.max(start2.right, end2.right);
  var width = right2 - left2;
  var height = bottom2 - top2;
  var x = left2;
  var y = top2;
  var data2 = { top: top2, bottom: bottom2, left: left2, right: right2, width, height, x, y };
  return _extends({}, data2, { toJSON: function toJSON() {
    return data2;
  } });
}
function canSetMark(state, tr4, newMarkType) {
  var _a;
  var selection = tr4.selection;
  var cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    var currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(function(mark) {
      return mark.type.excludes(newMarkType);
    });
  }
  var ranges = selection.ranges;
  return ranges.some(function(_ref64) {
    var $from = _ref64.$from, $to = _ref64.$to;
    var someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, function(node, _pos, parent) {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        var parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        var currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(function(otherMark) {
          return otherMark.type.excludes(newMarkType);
        });
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = function setMark2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref65) {
    var tr4 = _ref65.tr, state = _ref65.state, dispatch = _ref65.dispatch;
    var selection = tr4.selection;
    var empty2 = selection.empty, ranges = selection.ranges;
    var type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
      if (empty2) {
        var oldAttributes = getMarkAttributes(state, type);
        tr4.addStoredMark(type.create(_extends({}, oldAttributes, attributes)));
      } else {
        ranges.forEach(function(range) {
          var from2 = range.$from.pos;
          var to = range.$to.pos;
          state.doc.nodesBetween(from2, to, function(node, pos) {
            var trimmedFrom = Math.max(pos, from2);
            var trimmedTo = Math.min(pos + node.nodeSize, to);
            var someHasMark = node.marks.find(function(mark) {
              return mark.type === type;
            });
            if (someHasMark) {
              node.marks.forEach(function(mark) {
                if (type === mark.type) {
                  tr4.addMark(trimmedFrom, trimmedTo, type.create(_extends({}, mark.attrs, attributes)));
                }
              });
            } else {
              tr4.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(state, tr4, type);
  };
};
var setMeta = function setMeta2(key, value) {
  return function(_ref66) {
    var tr4 = _ref66.tr;
    tr4.setMeta(key, value);
    return true;
  };
};
var setNode = function setNode2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref67) {
    var state = _ref67.state, dispatch = _ref67.dispatch, chain = _ref67.chain;
    var type = getNodeType(typeOrName, state.schema);
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain().command(function(_ref68) {
      var commands2 = _ref68.commands;
      var canSetBlock = setBlockType(type, attributes)(state);
      if (canSetBlock) {
        return true;
      }
      return commands2.clearNodes();
    }).command(function(_ref69) {
      var updatedState = _ref69.state;
      return setBlockType(type, attributes)(updatedState, dispatch);
    }).run();
  };
};
var setNodeSelection = function setNodeSelection2(position) {
  return function(_ref70) {
    var tr4 = _ref70.tr, dispatch = _ref70.dispatch;
    if (dispatch) {
      var _doc = tr4.doc;
      var _from15 = minMax(position, 0, _doc.content.size);
      var selection = NodeSelection.create(_doc, _from15);
      tr4.setSelection(selection);
    }
    return true;
  };
};
var setTextSelection = function setTextSelection2(position) {
  return function(_ref71) {
    var tr4 = _ref71.tr, dispatch = _ref71.dispatch;
    if (dispatch) {
      var _doc2 = tr4.doc;
      var _ref72 = typeof position === "number" ? { from: position, to: position } : position, _from16 = _ref72.from, to = _ref72.to;
      var minPos = TextSelection.atStart(_doc2).from;
      var maxPos = TextSelection.atEnd(_doc2).to;
      var resolvedFrom = minMax(_from16, minPos, maxPos);
      var resolvedEnd = minMax(to, minPos, maxPos);
      var selection = TextSelection.create(_doc2, resolvedFrom, resolvedEnd);
      tr4.setSelection(selection);
    }
    return true;
  };
};
var sinkListItem = function sinkListItem2(typeOrName) {
  return function(_ref73) {
    var state = _ref73.state, dispatch = _ref73.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return sinkListItem$1(type)(state, dispatch);
  };
};
function ensureMarks(state, splittableMarks) {
  var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    var filteredMarks = marks.filter(function(mark) {
      return splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name);
    });
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock = function splitBlock2(_temp) {
  var _ref74 = _temp === void 0 ? {} : _temp, _ref74$keepMarks = _ref74.keepMarks, keepMarks = _ref74$keepMarks === void 0 ? true : _ref74$keepMarks;
  return function(_ref75) {
    var tr4 = _ref75.tr, state = _ref75.state, dispatch = _ref75.dispatch, editor = _ref75.editor;
    var selection = tr4.selection, doc2 = tr4.doc;
    var $from = selection.$from, $to = selection.$to;
    var extensionAttributes = editor.extensionManager.attributes;
    var newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
        return false;
      }
      if (dispatch) {
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr4.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    if (dispatch) {
      var atEnd = $to.parentOffset === $to.parent.content.size;
      if (selection instanceof TextSelection) {
        tr4.deleteSelection();
      }
      var deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      var types = atEnd && deflt ? [{ type: deflt, attrs: newAttributes }] : void 0;
      var can = canSplit(tr4.doc, tr4.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr4.doc, tr4.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types = deflt ? [{ type: deflt, attrs: newAttributes }] : void 0;
      }
      if (can) {
        tr4.split(tr4.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          var _first6 = tr4.mapping.map($from.before());
          var $first = tr4.doc.resolve(_first6);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr4.setNodeMarkup(tr4.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr4.scrollIntoView();
    }
    return true;
  };
};
var splitListItem = function splitListItem2(typeOrName) {
  return function(_ref76) {
    var tr4 = _ref76.tr, state = _ref76.state, dispatch = _ref76.dispatch, editor = _ref76.editor;
    var _a;
    var type = getNodeType(typeOrName, state.schema);
    var _state$selection16 = state.selection, $from = _state$selection16.$from, $to = _state$selection16.$to;
    var node = state.selection.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    var grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    var extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch) {
        var wrap = Fragment.empty;
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap = Fragment.from($from.node(d).copy(wrap));
        }
        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        var _newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        var _nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(_newNextTypeAttributes)) || void 0;
        wrap = wrap.append(Fragment.from(type.createAndFill(null, _nextType) || void 0));
        var _start12 = $from.before($from.depth - (depthBefore - 1));
        tr4.replace(_start12, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));
        var sel = -1;
        tr4.doc.nodesBetween(_start12, tr4.doc.content.size, function(n, pos) {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr4.setSelection(TextSelection.near(tr4.doc.resolve(sel)));
        }
        tr4.scrollIntoView();
      }
      return true;
    }
    var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
    var newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    tr4.delete($from.pos, $to.pos);
    var types = nextType ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }] : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr4.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch) {
      var selection = state.selection, storedMarks = state.storedMarks;
      var splittableMarks = editor.extensionManager.splittableMarks;
      var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      tr4.split($from.pos, 2, types).scrollIntoView();
      if (!marks || !dispatch) {
        return true;
      }
      var filteredMarks = marks.filter(function(mark) {
        return splittableMarks.includes(mark.type.name);
      });
      tr4.ensureMarks(filteredMarks);
    }
    return true;
  };
};
var joinListBackwards = function joinListBackwards2(tr4, listType) {
  var list = findParentNode(function(node) {
    return node.type === listType;
  })(tr4.selection);
  if (!list) {
    return true;
  }
  var before = tr4.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  var nodeBefore = tr4.doc.nodeAt(before);
  var canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr4.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr4.join(list.pos);
  return true;
};
var joinListForwards = function joinListForwards2(tr4, listType) {
  var list = findParentNode(function(node) {
    return node.type === listType;
  })(tr4.selection);
  if (!list) {
    return true;
  }
  var after = tr4.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  var nodeAfter = tr4.doc.nodeAt(after);
  var canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr4.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr4.join(after);
  return true;
};
var toggleList = function toggleList2(listTypeOrName, itemTypeOrName, keepMarks, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref77) {
    var editor = _ref77.editor, tr4 = _ref77.tr, state = _ref77.state, dispatch = _ref77.dispatch, chain = _ref77.chain, commands2 = _ref77.commands, can = _ref77.can;
    var _editor$extensionMana = editor.extensionManager, extensions2 = _editor$extensionMana.extensions, splittableMarks = _editor$extensionMana.splittableMarks;
    var listType = getNodeType(listTypeOrName, state.schema);
    var itemType = getNodeType(itemTypeOrName, state.schema);
    var selection = state.selection, storedMarks = state.storedMarks;
    var $from = selection.$from, $to = selection.$to;
    var range = $from.blockRange($to);
    var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    if (!range) {
      return false;
    }
    var parentList = findParentNode(function(node) {
      return isList(node.type.name, extensions2);
    })(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      if (parentList.node.type === listType) {
        return commands2.liftListItem(itemType);
      }
      if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
        return chain().command(function() {
          tr4.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(function() {
          return joinListBackwards(tr4, listType);
        }).command(function() {
          return joinListForwards(tr4, listType);
        }).run();
      }
    }
    if (!keepMarks || !marks || !dispatch) {
      return chain().command(function() {
        var canWrapInList = can().wrapInList(listType, attributes);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(function() {
        return joinListBackwards(tr4, listType);
      }).command(function() {
        return joinListForwards(tr4, listType);
      }).run();
    }
    return chain().command(function() {
      var canWrapInList = can().wrapInList(listType, attributes);
      var filteredMarks = marks.filter(function(mark) {
        return splittableMarks.includes(mark.type.name);
      });
      tr4.ensureMarks(filteredMarks);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(function() {
      return joinListBackwards(tr4, listType);
    }).command(function() {
      return joinListForwards(tr4, listType);
    }).run();
  };
};
var toggleMark = function toggleMark2(typeOrName, attributes, options) {
  if (attributes === void 0) {
    attributes = {};
  }
  if (options === void 0) {
    options = {};
  }
  return function(_ref78) {
    var state = _ref78.state, commands2 = _ref78.commands;
    var _options2 = options, _options2$extendEmpty = _options2.extendEmptyMarkRange, extendEmptyMarkRange = _options2$extendEmpty === void 0 ? false : _options2$extendEmpty;
    var type = getMarkType(typeOrName, state.schema);
    var isActive = isMarkActive(state, type, attributes);
    if (isActive) {
      return commands2.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands2.setMark(type, attributes);
  };
};
var toggleNode = function toggleNode2(typeOrName, toggleTypeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref79) {
    var state = _ref79.state, commands2 = _ref79.commands;
    var type = getNodeType(typeOrName, state.schema);
    var toggleType = getNodeType(toggleTypeOrName, state.schema);
    var isActive = isNodeActive(state, type, attributes);
    if (isActive) {
      return commands2.setNode(toggleType);
    }
    return commands2.setNode(type, attributes);
  };
};
var toggleWrap = function toggleWrap2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref80) {
    var state = _ref80.state, commands2 = _ref80.commands;
    var type = getNodeType(typeOrName, state.schema);
    var isActive = isNodeActive(state, type, attributes);
    if (isActive) {
      return commands2.lift(type);
    }
    return commands2.wrapIn(type, attributes);
  };
};
var undoInputRule = function undoInputRule2() {
  return function(_ref81) {
    var state = _ref81.state, dispatch = _ref81.dispatch;
    var plugins = state.plugins;
    for (var _i203 = 0; _i203 < plugins.length; _i203 += 1) {
      var plugin = plugins[_i203];
      var undoable = void 0;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch) {
          var _tr13 = state.tr;
          var toUndo = undoable.transform;
          for (var j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            _tr13.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            var marks = _tr13.doc.resolve(undoable.from).marks();
            _tr13.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            _tr13.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
};
var unsetAllMarks = function unsetAllMarks2() {
  return function(_ref82) {
    var tr4 = _ref82.tr, dispatch = _ref82.dispatch;
    var selection = tr4.selection;
    var empty2 = selection.empty, ranges = selection.ranges;
    if (empty2) {
      return true;
    }
    if (dispatch) {
      ranges.forEach(function(range) {
        tr4.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
};
var unsetMark = function unsetMark2(typeOrName, options) {
  if (options === void 0) {
    options = {};
  }
  return function(_ref83) {
    var tr4 = _ref83.tr, state = _ref83.state, dispatch = _ref83.dispatch;
    var _a;
    var _options3 = options, _options3$extendEmpty = _options3.extendEmptyMarkRange, extendEmptyMarkRange = _options3$extendEmpty === void 0 ? false : _options3$extendEmpty;
    var selection = tr4.selection;
    var type = getMarkType(typeOrName, state.schema);
    var $from = selection.$from, empty2 = selection.empty, ranges = selection.ranges;
    if (!dispatch) {
      return true;
    }
    if (empty2 && extendEmptyMarkRange) {
      var _from17 = selection.from, to = selection.to;
      var attrs = (_a = $from.marks().find(function(mark) {
        return mark.type === type;
      })) === null || _a === void 0 ? void 0 : _a.attrs;
      var range = getMarkRange($from, type, attrs);
      if (range) {
        _from17 = range.from;
        to = range.to;
      }
      tr4.removeMark(_from17, to, type);
    } else {
      ranges.forEach(function(range2) {
        tr4.removeMark(range2.$from.pos, range2.$to.pos, type);
      });
    }
    tr4.removeStoredMark(type);
    return true;
  };
};
var updateAttributes = function updateAttributes2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref84) {
    var tr4 = _ref84.tr, state = _ref84.state, dispatch = _ref84.dispatch;
    var nodeType = null;
    var markType = null;
    var schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr4.selection.ranges.forEach(function(range) {
        var from2 = range.$from.pos;
        var to = range.$to.pos;
        state.doc.nodesBetween(from2, to, function(node, pos) {
          if (nodeType && nodeType === node.type) {
            tr4.setNodeMarkup(pos, void 0, _extends({}, node.attrs, attributes));
          }
          if (markType && node.marks.length) {
            node.marks.forEach(function(mark) {
              if (markType === mark.type) {
                var trimmedFrom = Math.max(pos, from2);
                var trimmedTo = Math.min(pos + node.nodeSize, to);
                tr4.addMark(trimmedFrom, trimmedTo, markType.create(_extends({}, mark.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
};
var wrapIn = function wrapIn2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref85) {
    var state = _ref85.state, dispatch = _ref85.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return wrapIn$1(type, attributes)(state, dispatch);
  };
};
var wrapInList = function wrapInList2(typeOrName, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  return function(_ref86) {
    var state = _ref86.state, dispatch = _ref86.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return wrapInList$1(type, attributes)(state, dispatch);
  };
};
var commands = /* @__PURE__ */ Object.freeze({ __proto__: null, blur, clearContent, clearNodes, command, createParagraphNear, cut, deleteCurrentNode, deleteNode, deleteRange, deleteSelection, enter, exitCode, extendMarkRange, first, focus, forEach: forEach2, insertContent, insertContentAt, joinUp, joinDown, joinBackward, joinForward, joinItemBackward, joinItemForward, keyboardShortcut, lift, liftEmptyBlock, liftListItem, newlineInCode, resetAttributes, scrollIntoView, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, selectTextblockEnd, selectTextblockStart, setContent: setContent$1, setMark, setMeta, setNode, setNodeSelection, setTextSelection, sinkListItem, splitBlock, splitListItem, toggleList, toggleMark, toggleNode, toggleWrap, undoInputRule, unsetAllMarks, unsetMark, updateAttributes, wrapIn, wrapInList });
var Commands = Extension.create({ name: "commands", addCommands: function addCommands() {
  return _extends({}, commands);
} });
var Editable = Extension.create({ name: "editable", addProseMirrorPlugins: function addProseMirrorPlugins2() {
  var _this51 = this;
  return [new Plugin({ key: new PluginKey("editable"), props: { editable: function editable() {
    return _this51.editor.options.editable;
  } } })];
} });
var FocusEvents = Extension.create({ name: "focusEvents", addProseMirrorPlugins: function addProseMirrorPlugins3() {
  var editor = this.editor;
  return [new Plugin({ key: new PluginKey("focusEvents"), props: { handleDOMEvents: { focus: function focus3(view, event) {
    editor.isFocused = true;
    var transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
    view.dispatch(transaction);
    return false;
  }, blur: function blur3(view, event) {
    editor.isFocused = false;
    var transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
    view.dispatch(transaction);
    return false;
  } } } })];
} });
var Keymap = Extension.create({ name: "keymap", addKeyboardShortcuts: function addKeyboardShortcuts() {
  var _this52 = this;
  var handleBackspace = function handleBackspace2() {
    return _this52.editor.commands.first(function(_ref87) {
      var commands2 = _ref87.commands;
      return [
        function() {
          return commands2.undoInputRule();
        },
        // maybe convert first text block node to default node
        function() {
          return commands2.command(function(_ref88) {
            var tr4 = _ref88.tr;
            var selection = tr4.selection, doc2 = tr4.doc;
            var empty2 = selection.empty, $anchor = selection.$anchor;
            var pos = $anchor.pos, parent = $anchor.parent;
            var $parentPos = $anchor.parent.isTextblock ? tr4.doc.resolve(pos - 1) : $anchor;
            var parentIsIsolating = $parentPos.parent.type.spec.isolating;
            var parentPos = $anchor.pos - $anchor.parentOffset;
            var isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
            if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
              return false;
            }
            return commands2.clearNodes();
          });
        },
        function() {
          return commands2.deleteSelection();
        },
        function() {
          return commands2.joinBackward();
        },
        function() {
          return commands2.selectNodeBackward();
        }
      ];
    });
  };
  var handleDelete = function handleDelete2() {
    return _this52.editor.commands.first(function(_ref89) {
      var commands2 = _ref89.commands;
      return [function() {
        return commands2.deleteSelection();
      }, function() {
        return commands2.deleteCurrentNode();
      }, function() {
        return commands2.joinForward();
      }, function() {
        return commands2.selectNodeForward();
      }];
    });
  };
  var handleEnter = function handleEnter2() {
    return _this52.editor.commands.first(function(_ref90) {
      var commands2 = _ref90.commands;
      return [function() {
        return commands2.newlineInCode();
      }, function() {
        return commands2.createParagraphNear();
      }, function() {
        return commands2.liftEmptyBlock();
      }, function() {
        return commands2.splitBlock();
      }];
    });
  };
  var baseKeymap = { Enter: handleEnter, "Mod-Enter": function ModEnter() {
    return _this52.editor.commands.exitCode();
  }, Backspace: handleBackspace, "Mod-Backspace": handleBackspace, "Shift-Backspace": handleBackspace, Delete: handleDelete, "Mod-Delete": handleDelete, "Mod-a": function ModA() {
    return _this52.editor.commands.selectAll();
  } };
  var pcKeymap = _extends({}, baseKeymap);
  var macKeymap = _extends({}, baseKeymap, { "Ctrl-h": handleBackspace, "Alt-Backspace": handleBackspace, "Ctrl-d": handleDelete, "Ctrl-Alt-Backspace": handleDelete, "Alt-Delete": handleDelete, "Alt-d": handleDelete, "Ctrl-a": function CtrlA() {
    return _this52.editor.commands.selectTextblockStart();
  }, "Ctrl-e": function CtrlE() {
    return _this52.editor.commands.selectTextblockEnd();
  } });
  if (isiOS() || isMacOS()) {
    return macKeymap;
  }
  return pcKeymap;
}, addProseMirrorPlugins: function addProseMirrorPlugins4() {
  var _this53 = this;
  return [
    // With this plugin we check if the whole document was selected and deleted.
    // In this case we will additionally call `clearNodes()` to convert e.g. a heading
    // to a paragraph if necessary.
    // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
    // with many other commands.
    new Plugin({ key: new PluginKey("clearDocument"), appendTransaction: function appendTransaction(transactions, oldState, newState) {
      var docChanges = transactions.some(function(transaction) {
        return transaction.docChanged;
      }) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      var _oldState$selection = oldState.selection, empty2 = _oldState$selection.empty, from2 = _oldState$selection.from, to = _oldState$selection.to;
      var allFrom = Selection.atStart(oldState.doc).from;
      var allEnd = Selection.atEnd(oldState.doc).to;
      var allWasSelected = from2 === allFrom && to === allEnd;
      if (empty2 || !allWasSelected) {
        return;
      }
      var isEmpty2 = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
      if (!isEmpty2) {
        return;
      }
      var tr4 = newState.tr;
      var state = createChainableState({ state: newState, transaction: tr4 });
      var _CommandManager3 = new CommandManager({ editor: _this53.editor, state }), commands2 = _CommandManager3.commands;
      commands2.clearNodes();
      if (!tr4.steps.length) {
        return;
      }
      return tr4;
    } })
  ];
} });
var Tabindex = Extension.create({ name: "tabindex", addProseMirrorPlugins: function addProseMirrorPlugins5() {
  return [new Plugin({ key: new PluginKey("tabindex"), props: { attributes: this.editor.isEditable ? { tabindex: "0" } : {} } })];
} });
var extensions = /* @__PURE__ */ Object.freeze({ __proto__: null, ClipboardTextSerializer, Commands, Editable, FocusEvents, Keymap, Tabindex });
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  var tiptapStyleTag = document.querySelector("style[data-tiptap-style" + (suffix ? "-" + suffix : "") + "]");
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  var styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute("data-tiptap-style" + (suffix ? "-" + suffix : ""), "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor$1 = /* @__PURE__ */ function(_EventEmitter) {
  _inheritsLoose(Editor2, _EventEmitter);
  function Editor2(options) {
    var _this54;
    if (options === void 0) {
      options = {};
    }
    _this54 = _EventEmitter.call(this) || this;
    _this54.isFocused = false;
    _this54.extensionStorage = {};
    _this54.options = { element: document.createElement("div"), content: "", injectCSS: true, injectNonce: void 0, extensions: [], autofocus: false, editable: true, editorProps: {}, parseOptions: {}, enableInputRules: true, enablePasteRules: true, enableCoreExtensions: true, onBeforeCreate: function onBeforeCreate() {
      return null;
    }, onCreate: function onCreate3() {
      return null;
    }, onUpdate: function onUpdate() {
      return null;
    }, onSelectionUpdate: function onSelectionUpdate() {
      return null;
    }, onTransaction: function onTransaction() {
      return null;
    }, onFocus: function onFocus() {
      return null;
    }, onBlur: function onBlur() {
      return null;
    }, onDestroy: function onDestroy3() {
      return null;
    } };
    _this54.isCapturingTransaction = false;
    _this54.capturedTransaction = null;
    _this54.setOptions(options);
    _this54.createExtensionManager();
    _this54.createCommandManager();
    _this54.createSchema();
    _this54.on("beforeCreate", _this54.options.onBeforeCreate);
    _this54.emit("beforeCreate", { editor: _assertThisInitialized(_this54) });
    _this54.createView();
    _this54.injectCSS();
    _this54.on("create", _this54.options.onCreate);
    _this54.on("update", _this54.options.onUpdate);
    _this54.on("selectionUpdate", _this54.options.onSelectionUpdate);
    _this54.on("transaction", _this54.options.onTransaction);
    _this54.on("focus", _this54.options.onFocus);
    _this54.on("blur", _this54.options.onBlur);
    _this54.on("destroy", _this54.options.onDestroy);
    window.setTimeout(function() {
      if (_this54.isDestroyed) {
        return;
      }
      _this54.commands.focus(_this54.options.autofocus);
      _this54.emit("create", { editor: _assertThisInitialized(_this54) });
    }, 0);
    return _this54;
  }
  var _proto61 = Editor2.prototype;
  _proto61.chain = function chain() {
    return this.commandManager.chain();
  };
  _proto61.can = function can() {
    return this.commandManager.can();
  };
  _proto61.injectCSS = function injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  };
  _proto61.setOptions = function setOptions(options) {
    if (options === void 0) {
      options = {};
    }
    this.options = _extends({}, this.options, options);
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  };
  _proto61.setEditable = function setEditable2(editable, emitUpdate) {
    if (emitUpdate === void 0) {
      emitUpdate = true;
    }
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  };
  _proto61.registerPlugin = function registerPlugin(plugin, handlePlugins) {
    var plugins = isFunction$1(handlePlugins) ? handlePlugins(plugin, [].concat(this.state.plugins)) : [].concat(this.state.plugins, [plugin]);
    var state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  };
  _proto61.unregisterPlugin = function unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    var name = typeof nameOrPluginKey === "string" ? nameOrPluginKey + "$" : nameOrPluginKey.key;
    var state = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter(function(plugin) {
        return !plugin.key.startsWith(name);
      })
    });
    this.view.updateState(state);
  };
  _proto61.createExtensionManager = function createExtensionManager() {
    var coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    var allExtensions = [].concat(coreExtensions, this.options.extensions).filter(function(extension) {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  };
  _proto61.createCommandManager = function createCommandManager() {
    this.commandManager = new CommandManager({ editor: this });
  };
  _proto61.createSchema = function createSchema() {
    this.schema = this.extensionManager.schema;
  };
  _proto61.createView = function createView() {
    var doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    var selection = resolveFocusPosition(doc2, this.options.autofocus);
    this.view = new EditorView(this.options.element, _extends({}, this.options.editorProps, { dispatchTransaction: this.dispatchTransaction.bind(this), state: EditorState.create({ doc: doc2, selection: selection || void 0 }) }));
    var newState = this.state.reconfigure({ plugins: this.extensionManager.plugins });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    var dom = this.view.dom;
    dom.editor = this;
  };
  _proto61.createNodeViews = function createNodeViews() {
    this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
  };
  _proto61.prependClass = function prependClass() {
    this.view.dom.className = "tiptap " + this.view.dom.className;
  };
  _proto61.captureTransaction = function captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    var tr4 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr4;
  };
  _proto61.dispatchTransaction = function dispatchTransaction(transaction) {
    var _this55 = this;
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach(function(step) {
        var _a;
        return (_a = _this55.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    var state = this.state.apply(transaction);
    var selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", { editor: this, transaction });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", { editor: this, transaction });
    }
    var focus3 = transaction.getMeta("focus");
    var blur3 = transaction.getMeta("blur");
    if (focus3) {
      this.emit("focus", { editor: this, event: focus3.event, transaction });
    }
    if (blur3) {
      this.emit("blur", { editor: this, event: blur3.event, transaction });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", { editor: this, transaction });
  };
  _proto61.getAttributes = function getAttributes(nameOrType) {
    return _getAttributes(this.state, nameOrType);
  };
  _proto61.isActive = function isActive(nameOrAttributes, attributesOrUndefined) {
    var name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    var attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return _isActive(this.state, name, attributes);
  };
  _proto61.getJSON = function getJSON() {
    return this.state.doc.toJSON();
  };
  _proto61.getHTML = function getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  };
  _proto61.getText = function getText(options) {
    var _ref91 = options || {}, _ref91$blockSeparator = _ref91.blockSeparator, blockSeparator = _ref91$blockSeparator === void 0 ? "\n\n" : _ref91$blockSeparator, _ref91$textSerializer = _ref91.textSerializers, textSerializers = _ref91$textSerializer === void 0 ? {} : _ref91$textSerializer;
    return _getText(this.state.doc, { blockSeparator, textSerializers: _extends({}, getTextSerializersFromSchema(this.schema), textSerializers) });
  };
  _proto61.getCharacterCount = function getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  };
  _proto61.destroy = function destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  };
  _createClass(Editor2, [{
    key: "storage",
    get: function get5() {
      return this.extensionStorage;
    }
    /**
    * An object of all registered commands.
    */
  }, { key: "commands", get: function get5() {
    return this.commandManager.commands;
  } }, {
    key: "isEditable",
    get: function get5() {
      return this.options.editable && this.view && this.view.editable;
    }
    /**
    * Returns the editor state.
    */
  }, { key: "state", get: function get5() {
    return this.view.state;
  } }, { key: "isEmpty", get: function get5() {
    return isNodeEmpty(this.state.doc);
  } }, { key: "isDestroyed", get: function get5() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  } }]);
  return Editor2;
}(EventEmitter);
function markInputRule(config) {
  return new InputRule({ find: config.find, handler: function handler(_ref92) {
    var state = _ref92.state, range = _ref92.range, match = _ref92.match;
    var attributes = callOrReturn(config.getAttributes, void 0, match);
    if (attributes === false || attributes === null) {
      return null;
    }
    var tr4 = state.tr;
    var captureGroup = match[match.length - 1];
    var fullMatch = match[0];
    if (captureGroup) {
      var startSpaces = fullMatch.search(/\S/);
      var textStart = range.from + fullMatch.indexOf(captureGroup);
      var textEnd = textStart + captureGroup.length;
      var excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(function(item) {
        var excluded = item.mark.type.excluded;
        return excluded.find(function(type) {
          return type === config.type && type !== item.mark.type;
        });
      }).filter(function(item) {
        return item.to > textStart;
      });
      if (excludedMarks.length) {
        return null;
      }
      if (textEnd < range.to) {
        tr4.delete(textEnd, range.to);
      }
      if (textStart > range.from) {
        tr4.delete(range.from + startSpaces, textStart);
      }
      var markEnd = range.from + startSpaces + captureGroup.length;
      tr4.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
      tr4.removeStoredMark(config.type);
    }
  } });
}
function nodeInputRule(config) {
  return new InputRule({ find: config.find, handler: function handler(_ref93) {
    var state = _ref93.state, range = _ref93.range, match = _ref93.match;
    var attributes = callOrReturn(config.getAttributes, void 0, match) || {};
    var tr4 = state.tr;
    var start2 = range.from;
    var end2 = range.to;
    var newNode3 = config.type.create(attributes);
    if (match[1]) {
      var _offset10 = match[0].lastIndexOf(match[1]);
      var matchStart = start2 + _offset10;
      if (matchStart > end2) {
        matchStart = end2;
      } else {
        end2 = matchStart + match[1].length;
      }
      var lastChar = match[0][match[0].length - 1];
      tr4.insertText(lastChar, start2 + match[0].length - 1);
      tr4.replaceWith(matchStart, end2, newNode3);
    } else if (match[0]) {
      tr4.insert(start2 - 1, config.type.create(attributes)).delete(tr4.mapping.map(start2), tr4.mapping.map(end2));
    }
    tr4.scrollIntoView();
  } });
}
function textblockTypeInputRule(config) {
  return new InputRule({ find: config.find, handler: function handler(_ref94) {
    var state = _ref94.state, range = _ref94.range, match = _ref94.match;
    var $start = state.doc.resolve(range.from);
    var attributes = callOrReturn(config.getAttributes, void 0, match) || {};
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
      return null;
    }
    state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
  } });
}
function wrappingInputRule(config) {
  return new InputRule({ find: config.find, handler: function handler(_ref95) {
    var state = _ref95.state, range = _ref95.range, match = _ref95.match, chain = _ref95.chain;
    var attributes = callOrReturn(config.getAttributes, void 0, match) || {};
    var tr4 = state.tr.delete(range.from, range.to);
    var $start = tr4.doc.resolve(range.from);
    var blockRange = $start.blockRange();
    var wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
    if (!wrapping) {
      return null;
    }
    tr4.wrap(blockRange, wrapping);
    if (config.keepMarks && config.editor) {
      var selection = state.selection, storedMarks = state.storedMarks;
      var splittableMarks = config.editor.extensionManager.splittableMarks;
      var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      if (marks) {
        var filteredMarks = marks.filter(function(mark) {
          return splittableMarks.includes(mark.type.name);
        });
        tr4.ensureMarks(filteredMarks);
      }
    }
    if (config.keepAttributes) {
      var nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
      chain().updateAttributes(nodeType, attributes).run();
    }
    var before = tr4.doc.resolve(range.from - 1).nodeBefore;
    if (before && before.type === config.type && canJoin(tr4.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
      tr4.join(range.from - 1);
    }
  } });
}
var Mark = /* @__PURE__ */ function() {
  function Mark2(config) {
    if (config === void 0) {
      config = {};
    }
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = { name: this.name, defaultOptions: {} };
    this.config = _extends({}, this.config, config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn('[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "' + this.name + '".');
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", { name: this.name }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", { name: this.name, options: this.options })) || {};
  }
  Mark2.create = function create2(config) {
    if (config === void 0) {
      config = {};
    }
    return new Mark2(config);
  };
  var _proto62 = Mark2.prototype;
  _proto62.configure = function configure(options) {
    if (options === void 0) {
      options = {};
    }
    var extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", { name: extension.name, options: extension.options }));
    return extension;
  };
  _proto62.extend = function extend(extendedConfig) {
    if (extendedConfig === void 0) {
      extendedConfig = {};
    }
    var extension = new Mark2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn('[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "' + extension.name + '".');
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", { name: extension.name }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", { name: extension.name, options: extension.options }));
    return extension;
  };
  Mark2.handleExit = function handleExit(_ref96) {
    var editor = _ref96.editor, mark = _ref96.mark;
    var tr4 = editor.state.tr;
    var currentPos = editor.state.selection.$from;
    var isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      var currentMarks = currentPos.marks();
      var isInMark = !!currentMarks.find(function(m) {
        return (m === null || m === void 0 ? void 0 : m.type.name) === mark.name;
      });
      if (!isInMark) {
        return false;
      }
      var removeMark = currentMarks.find(function(m) {
        return (m === null || m === void 0 ? void 0 : m.type.name) === mark.name;
      });
      if (removeMark) {
        tr4.removeStoredMark(removeMark);
      }
      tr4.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr4);
      return true;
    }
    return false;
  };
  return Mark2;
}();
var Node = /* @__PURE__ */ function() {
  function Node2(config) {
    if (config === void 0) {
      config = {};
    }
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = { name: this.name, defaultOptions: {} };
    this.config = _extends({}, this.config, config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn('[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "' + this.name + '".');
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", { name: this.name }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", { name: this.name, options: this.options })) || {};
  }
  Node2.create = function create2(config) {
    if (config === void 0) {
      config = {};
    }
    return new Node2(config);
  };
  var _proto63 = Node2.prototype;
  _proto63.configure = function configure(options) {
    if (options === void 0) {
      options = {};
    }
    var extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", { name: extension.name, options: extension.options }));
    return extension;
  };
  _proto63.extend = function extend(extendedConfig) {
    if (extendedConfig === void 0) {
      extendedConfig = {};
    }
    var extension = new Node2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn('[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "' + extension.name + '".');
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", { name: extension.name }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", { name: extension.name, options: extension.options }));
    return extension;
  };
  return Node2;
}();
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
var NodeView = /* @__PURE__ */ function() {
  function NodeView2(component, props, options) {
    this.isDragging = false;
    this.component = component;
    this.editor = props.editor;
    this.options = _extends({ stopEvent: null, ignoreMutation: null }, options);
    this.extension = props.extension;
    this.node = props.node;
    this.decorations = props.decorations;
    this.getPos = props.getPos;
    this.mount();
  }
  var _proto64 = NodeView2.prototype;
  _proto64.mount = function mount() {
    return;
  };
  _proto64.onDragStart = function onDragStart(event) {
    var _a, _b, _c, _d, _e, _f, _g;
    var view = this.editor.view;
    var target = event.target;
    var dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
      return;
    }
    var x = 0;
    var y = 0;
    if (this.dom !== dragHandle) {
      var domBox = this.dom.getBoundingClientRect();
      var handleBox = dragHandle.getBoundingClientRect();
      var offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
      var offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
      x = handleBox.x - domBox.x + offsetX;
      y = handleBox.y - domBox.y + offsetY;
    }
    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);
    var selection = NodeSelection.create(view.state.doc, this.getPos());
    var transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  };
  _proto64.stopEvent = function stopEvent(event) {
    var _this56 = this;
    var _a;
    if (!this.dom) {
      return false;
    }
    if (typeof this.options.stopEvent === "function") {
      return this.options.stopEvent({ event });
    }
    var target = event.target;
    var isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
    if (!isInElement) {
      return false;
    }
    var isDragEvent = event.type.startsWith("drag");
    var isDropEvent = event.type === "drop";
    var isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent && !isDragEvent) {
      return true;
    }
    var isEditable = this.editor.isEditable;
    var isDragging = this.isDragging;
    var isDraggable = !!this.node.type.spec.draggable;
    var isSelectable = NodeSelection.isSelectable(this.node);
    var isCopyEvent = event.type === "copy";
    var isPasteEvent = event.type === "paste";
    var isCutEvent = event.type === "cut";
    var isClickEvent = event.type === "mousedown";
    if (!isDraggable && isSelectable && isDragEvent) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      var dragHandle = target.closest("[data-drag-handle]");
      var isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener("dragend", function() {
          _this56.isDragging = false;
        }, { once: true });
        document.addEventListener("drop", function() {
          _this56.isDragging = false;
        }, { once: true });
        document.addEventListener("mouseup", function() {
          _this56.isDragging = false;
        }, { once: true });
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  };
  _proto64.ignoreMutation = function ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (this.node.isLeaf || this.node.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
      var changedNodes = [].concat(Array.from(mutation.addedNodes), Array.from(mutation.removedNodes));
      if (changedNodes.every(function(node) {
        return node.isContentEditable;
      })) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  };
  _proto64.updateAttributes = function updateAttributes3(attributes) {
    var _this57 = this;
    this.editor.commands.command(function(_ref97) {
      var tr4 = _ref97.tr;
      var pos = _this57.getPos();
      tr4.setNodeMarkup(pos, void 0, _extends({}, _this57.node.attrs, attributes));
      return true;
    });
  };
  _proto64.deleteNode = function deleteNode3() {
    var from2 = this.getPos();
    var to = from2 + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: from2, to });
  };
  _createClass(NodeView2, [{ key: "dom", get: function get5() {
    return this.editor.view.dom;
  } }, { key: "contentDOM", get: function get5() {
    return null;
  } }]);
  return NodeView2;
}();
function markPasteRule(config) {
  return new PasteRule({ find: config.find, handler: function handler(_ref98) {
    var state = _ref98.state, range = _ref98.range, match = _ref98.match, pasteEvent = _ref98.pasteEvent;
    var attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
    if (attributes === false || attributes === null) {
      return null;
    }
    var tr4 = state.tr;
    var captureGroup = match[match.length - 1];
    var fullMatch = match[0];
    var markEnd = range.to;
    if (captureGroup) {
      var startSpaces = fullMatch.search(/\S/);
      var textStart = range.from + fullMatch.indexOf(captureGroup);
      var textEnd = textStart + captureGroup.length;
      var excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(function(item) {
        var excluded = item.mark.type.excluded;
        return excluded.find(function(type) {
          return type === config.type && type !== item.mark.type;
        });
      }).filter(function(item) {
        return item.to > textStart;
      });
      if (excludedMarks.length) {
        return null;
      }
      if (textEnd < range.to) {
        tr4.delete(textEnd, range.to);
      }
      if (textStart > range.from) {
        tr4.delete(range.from + startSpaces, textStart);
      }
      markEnd = range.from + startSpaces + captureGroup.length;
      tr4.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
      tr4.removeStoredMark(config.type);
    }
  } });
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = { popper: { position: state.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = { name: "applyStyles", enabled: true, phase: "write", fn: applyStyles, effect: effect$2, requires: ["computeStyles"] };
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return { width, height, top: y, right: x + width, bottom: y + height, left: x, x, y };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return { x: element.offsetLeft, y: element.offsetTop, width, height };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, { placement: state.placement })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$2(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$3 = { name: "arrow", enabled: true, phase: "main", fn: arrow$2, effect: effect$1, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return { x: round(x * dpr) / dpr || 0, y: round(y * dpr) / dpr || 0 };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({ x, y }) : { x, y };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({ position }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({ x, y }, getWindow(popper2)) : { x, y };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = { placement: getBasePlacement$1(state.placement), variation: getVariation(state.placement), popper: state.elements.popper, popperRect: state.rects.popper, gpuAcceleration, isFixed: state.options.strategy === "fixed" };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, { offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive, roundOffsets })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, { offsets: state.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, { "data-popper-placement": state.placement });
}
var computeStyles$1 = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: computeStyles, data: {} };
var passive = { passive: true };
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = { name: "eventListeners", enabled: true, phase: "write", fn: function fn() {
}, effect, data: {} };
var hash$1 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = { start: "end", end: "start" };
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return { scrollLeft, scrollTop };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return { width, height, x: x + getWindowScrollBarX(element), y };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return { width, height, x, y };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, { left: rect.x, top: rect.y, right: rect.x + rect.width, bottom: rect.y + rect.height });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = { x: commonX, y: reference2.y - element.height };
      break;
    case bottom:
      offsets = { x: commonX, y: reference2.y + reference2.height };
      break;
    case right:
      offsets = { x: reference2.x + reference2.width, y: commonY };
      break;
    case left:
      offsets = { x: reference2.x - element.width, y: commonY };
      break;
    default:
      offsets = { x: reference2.x, y: reference2.y };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({ reference: referenceClientRect, element: popperRect, strategy: "absolute", placement });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = { top: clippingClientRect.top - elementClientRect.top + paddingObject.top, bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom, left: clippingClientRect.left - elementClientRect.left + paddingObject.left, right: elementClientRect.right - clippingClientRect.right + paddingObject.right };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, { placement: placement2, boundary, rootBoundary, padding })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, { placement: placement2, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, { placement, boundary, rootBoundary, altBoundary, padding });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = { name: "flip", enabled: true, phase: "main", fn: flip, requiresIfExists: ["offset"], data: { _skip: false } };
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = { x: 0, y: 0 };
  }
  return { top: overflow.top - rect.height - preventedOffsets.y, right: overflow.right - rect.width + preventedOffsets.x, bottom: overflow.bottom - rect.height + preventedOffsets.y, left: overflow.left - rect.width - preventedOffsets.x };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, { elementContext: "reference" });
  var popperAltOverflow = detectOverflow(state, { altBoundary: true });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = { referenceClippingOffsets, popperEscapeOffsets, isReferenceHidden, hasPopperEscaped };
  state.attributes.popper = Object.assign({}, state.attributes.popper, { "data-popper-reference-hidden": isReferenceHidden, "data-popper-escaped": hasPopperEscaped });
}
var hide$1 = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: hide };
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, { placement })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? { x: distance, y: skidding } : { x: skidding, y: distance };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data2;
}
var offset$1 = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: offset };
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({ reference: state.rects.reference, element: state.rects.popper, strategy: "absolute", placement: state.placement });
}
var popperOffsets$1 = { name: "popperOffsets", enabled: true, phase: "read", fn: popperOffsets, data: {} };
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, { boundary, rootBoundary, padding, altBoundary });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, { placement: state.placement })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? { mainAxis: tetherOffsetValue, altAxis: tetherOffsetValue } : Object.assign({ mainAxis: 0, altAxis: 0 }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data2 = { x: 0, y: 0 };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data2;
}
var preventOverflow$1 = { name: "preventOverflow", enabled: true, phase: "main", fn: preventOverflow, requiresIfExists: ["offset"] };
function getHTMLElementScroll(element) {
  return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = { scrollLeft: 0, scrollTop: 0 };
  var offsets = { x: 0, y: 0 };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return { x: rect.left + scroll.scrollLeft - offsets.x, y: rect.top + scroll.scrollTop - offsets.y, width: rect.width, height: rect.height };
}
function order(modifiers2) {
  var map3 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map3.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map3.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, { options: Object.assign({}, existing.options, current.options), data: Object.assign({}, existing.data, current.data) }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = { placement: "bottom", modifiers: [], strategy: "absolute" };
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions), modifiersData: {}, elements: { reference: reference2, popper: popper2 }, attributes: {}, styles: {} };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = { reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [], popper: listScrollParents(popper2) };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = { reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"), popper: getLayoutRect(popper3) };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({ state, options: _options, name, instance }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect3 = _ref.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({ state, name, instance, options: options2 });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$3, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({ defaultModifiers });
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = { passive: true, capture: true };
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = { isTouch: false };
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c👷‍ This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (process.env.NODE_ENV !== "production") {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = { animateFill: false, followCursor: false, inlinePositioning: false, sticky: false };
var renderProps = { allowHTML: false, animation: "fade", arrow: true, content: "", inertia: false, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 };
var defaultProps = Object.assign({ appendTo: TIPPY_DEFAULT_APPEND_TO, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: true, ignoreAttributes: false, interactive: false, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function onAfterUpdate() {
}, onBeforeUpdate: function onBeforeUpdate() {
}, onCreate: function onCreate() {
}, onDestroy: function onDestroy() {
}, onHidden: function onHidden() {
}, onHide: function onHide() {
}, onMount: function onMount() {
}, onShow: function onShow() {
}, onShown: function onShown() {
}, onTrigger: function onTrigger() {
}, onUntrigger: function onUntrigger() {
}, onClickOutside: function onClickOutside() {
}, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: false, touch: true, trigger: "mouseenter focus", triggerTarget: null }, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (process.env.NODE_ENV !== "production") {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, { plugins }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, { content: invokeWithArgsOrReturn(props.content, [reference2]) }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = { expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded, content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content5, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content5, "");
    content5.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content5, props.content);
    } else {
      content5.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return { box, content: boxChildren.find(function(node) {
    return node.classList.contains(CONTENT_CLASS);
  }), arrow: boxChildren.find(function(node) {
    return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
  }), backdrop: boxChildren.find(function(node) {
    return node.classList.contains(BACKDROP_CLASS);
  }) };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content5 = div();
  content5.className = CONTENT_CLASS;
  content5.setAttribute("data-state", "hidden");
  setContent(content5, instance.props);
  popper2.appendChild(box);
  box.appendChild(content5);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content6 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content6, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return { popper: popper2, onUpdate };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (process.env.NODE_ENV !== "production") {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({ node, eventType, handler, options });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, { passive: true });
      on("touchend", onMouseLeave, { passive: true });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return { popperRect: popper3.getBoundingClientRect(), popperState: state2, props };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? { getBoundingClientRect: getReferenceClientRect, contextElement: getReferenceClientRect.contextElement || getCurrentTarget() } : reference2;
    var tippyModifier = { name: "$$tippy", enabled: true, phase: "beforeWrite", requires: ["computeStyles"], fn: function fn2(_ref2) {
      var state2 = _ref2.state;
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
        ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
          if (attr === "placement") {
            box.setAttribute("data-placement", state2.placement);
          } else {
            if (state2.attributes.popper["data-popper-" + attr]) {
              box.setAttribute("data-" + attr, "");
            } else {
              box.removeAttribute("data-" + attr);
            }
          }
        });
        state2.attributes.popper = {};
      }
    } };
    var modifiers2 = [{ name: "offset", options: { offset: offset2 } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !moveTransition } }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({ name: "arrow", options: { element: arrow2, padding: 3 } });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, { placement, onFirstUpdate, modifiers: modifiers2 }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode3;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode3 = node.parentNode;
    } else {
      parentNode3 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode3.contains(popper2)) {
      parentNode3.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), { ignoreAttributes: true }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content5) {
    instance.setProps({ content: content5 });
  }
  function show() {
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content5 = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content5], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content5 = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content5], duration);
        setVisibilityState([box, content5], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (process.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (process.env.NODE_ENV !== "production") {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, { plugins });
  var elements = getArrayOfElements(targets);
  if (process.env.NODE_ENV !== "production") {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, { effect: function effect2(_ref) {
  var state = _ref.state;
  var initialStyles = { popper: { position: state.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
} });
tippy.setDefaultProps({ render });
var BubbleMenuView = /* @__PURE__ */ function() {
  function BubbleMenuView2(_ref99) {
    var _this58 = this;
    var editor = _ref99.editor, element = _ref99.element, view = _ref99.view, _ref99$tippyOptions = _ref99.tippyOptions, tippyOptions = _ref99$tippyOptions === void 0 ? {} : _ref99$tippyOptions, _ref99$updateDelay = _ref99.updateDelay, updateDelay = _ref99$updateDelay === void 0 ? 250 : _ref99$updateDelay, shouldShow = _ref99.shouldShow;
    this.preventHide = false;
    this.shouldShow = function(_ref100) {
      var view2 = _ref100.view, state = _ref100.state, from2 = _ref100.from, to = _ref100.to;
      var doc2 = state.doc, selection = state.selection;
      var empty2 = selection.empty;
      var isEmptyTextBlock = !doc2.textBetween(from2, to).length && isTextSelection(state.selection);
      var isChildOfMenu = _this58.element.contains(document.activeElement);
      var hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty2 || isEmptyTextBlock || !_this58.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = function() {
      _this58.preventHide = true;
    };
    this.dragstartHandler = function() {
      _this58.hide();
    };
    this.focusHandler = function() {
      setTimeout(function() {
        return _this58.update(_this58.editor.view);
      });
    };
    this.blurHandler = function(_ref101) {
      var event = _ref101.event;
      var _a;
      if (_this58.preventHide) {
        _this58.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = _this58.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      _this58.hide();
    };
    this.tippyBlurHandler = function(event) {
      _this58.blurHandler({ event });
    };
    this.handleDebouncedUpdate = function(view2, oldState) {
      var selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      var docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (_this58.updateDebounceTimer) {
        clearTimeout(_this58.updateDebounceTimer);
      }
      _this58.updateDebounceTimer = window.setTimeout(function() {
        _this58.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, _this58.updateDelay);
    };
    this.updateHandler = function(view2, selectionChanged, docChanged, oldState) {
      var _a, _b, _c;
      var state = view2.state, composing = view2.composing;
      var selection = state.selection;
      var isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      _this58.createTooltip();
      var ranges = selection.ranges;
      var from2 = Math.min.apply(Math, ranges.map(function(range) {
        return range.$from.pos;
      }));
      var to = Math.max.apply(Math, ranges.map(function(range) {
        return range.$to.pos;
      }));
      var shouldShow2 = (_a = _this58.shouldShow) === null || _a === void 0 ? void 0 : _a.call(_this58, { editor: _this58.editor, view: view2, state, oldState, from: from2, to });
      if (!shouldShow2) {
        _this58.hide();
        return;
      }
      (_b = _this58.tippy) === null || _b === void 0 ? void 0 : _b.setProps({ getReferenceClientRect: ((_c = _this58.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || function() {
        if (isNodeSelection(state.selection)) {
          var node = view2.nodeDOM(from2);
          var nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
          if (nodeViewWrapper) {
            node = nodeViewWrapper.firstChild;
          }
          if (node) {
            return node.getBoundingClientRect();
          }
        }
        return posToDOMRect(view2, from2, to);
      } });
      _this58.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  var _proto65 = BubbleMenuView2.prototype;
  _proto65.createTooltip = function createTooltip() {
    var editorElement = this.editor.options.element;
    var editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, _extends({ duration: 0, getReferenceClientRect: null, content: this.element, interactive: true, trigger: "manual", placement: "top", hideOnClick: "toggle" }, this.tippyOptions));
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  };
  _proto65.update = function update2(view, oldState) {
    var state = view.state;
    var hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    var selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    var docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  };
  _proto65.show = function show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  };
  _proto65.hide = function hide2() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  };
  _proto65.destroy = function destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  };
  return BubbleMenuView2;
}();
var BubbleMenuPlugin = function BubbleMenuPlugin2(options) {
  return new Plugin({ key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey, view: function view(_view3) {
    return new BubbleMenuView(_extends({ view: _view3 }, options));
  } });
};
Extension.create({ name: "bubbleMenu", addOptions: function addOptions() {
  return { element: null, tippyOptions: {}, pluginKey: "bubbleMenu", updateDelay: void 0, shouldShow: null };
}, addProseMirrorPlugins: function addProseMirrorPlugins6() {
  if (!this.options.element) {
    return [];
  }
  return [BubbleMenuPlugin({ pluginKey: this.options.pluginKey, editor: this.editor, element: this.options.element, tippyOptions: this.options.tippyOptions, updateDelay: this.options.updateDelay, shouldShow: this.options.shouldShow })];
} });
var FloatingMenuView = /* @__PURE__ */ function() {
  function FloatingMenuView2(_ref102) {
    var _this59 = this;
    var editor = _ref102.editor, element = _ref102.element, view = _ref102.view, _ref102$tippyOptions = _ref102.tippyOptions, tippyOptions = _ref102$tippyOptions === void 0 ? {} : _ref102$tippyOptions, shouldShow = _ref102.shouldShow;
    this.preventHide = false;
    this.shouldShow = function(_ref103) {
      var view2 = _ref103.view, state = _ref103.state;
      var selection = state.selection;
      var $anchor = selection.$anchor, empty2 = selection.empty;
      var isRootDepth = $anchor.depth === 1;
      var isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;
      if (!view2.hasFocus() || !empty2 || !isRootDepth || !isEmptyTextBlock || !_this59.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = function() {
      _this59.preventHide = true;
    };
    this.focusHandler = function() {
      setTimeout(function() {
        return _this59.update(_this59.editor.view);
      });
    };
    this.blurHandler = function(_ref104) {
      var event = _ref104.event;
      var _a;
      if (_this59.preventHide) {
        _this59.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = _this59.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      _this59.hide();
    };
    this.tippyBlurHandler = function(event) {
      _this59.blurHandler({ event });
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  var _proto66 = FloatingMenuView2.prototype;
  _proto66.createTooltip = function createTooltip() {
    var editorElement = this.editor.options.element;
    var editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, _extends({ duration: 0, getReferenceClientRect: null, content: this.element, interactive: true, trigger: "manual", placement: "right", hideOnClick: "toggle" }, this.tippyOptions));
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  };
  _proto66.update = function update2(view, oldState) {
    var _a, _b, _c;
    var state = view.state;
    var doc2 = state.doc, selection = state.selection;
    var from2 = selection.from, to = selection.to;
    var isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    var shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, { editor: this.editor, view, state, oldState });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({ getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || function() {
      return posToDOMRect(view, from2, to);
    } });
    this.show();
  };
  _proto66.show = function show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  };
  _proto66.hide = function hide2() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  };
  _proto66.destroy = function destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  };
  return FloatingMenuView2;
}();
var FloatingMenuPlugin = function FloatingMenuPlugin2(options) {
  return new Plugin({ key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey, view: function view(_view4) {
    return new FloatingMenuView(_extends({ view: _view4 }, options));
  } });
};
Extension.create({ name: "floatingMenu", addOptions: function addOptions2() {
  return { element: null, tippyOptions: {}, pluginKey: "floatingMenu", shouldShow: null };
}, addProseMirrorPlugins: function addProseMirrorPlugins7() {
  if (!this.options.element) {
    return [];
  }
  return [FloatingMenuPlugin({ pluginKey: this.options.pluginKey, editor: this.editor, element: this.options.element, tippyOptions: this.options.tippyOptions, shouldShow: this.options.shouldShow })];
} });
var BubbleMenu = defineComponent({ name: "BubbleMenu", props: { pluginKey: { type: [String, Object], default: "bubbleMenu" }, editor: { type: Object, required: true }, updateDelay: { type: Number, default: void 0 }, tippyOptions: { type: Object, default: function _default() {
  return {};
} }, shouldShow: { type: Function, default: null } }, setup: function setup(props, _ref105) {
  var slots = _ref105.slots;
  var root = ref(null);
  onMounted(function() {
    var updateDelay = props.updateDelay, editor = props.editor, pluginKey = props.pluginKey, shouldShow = props.shouldShow, tippyOptions = props.tippyOptions;
    editor.registerPlugin(BubbleMenuPlugin({ updateDelay, editor, element: root.value, pluginKey, shouldShow, tippyOptions }));
  });
  onBeforeUnmount(function() {
    var pluginKey = props.pluginKey, editor = props.editor;
    editor.unregisterPlugin(pluginKey);
  });
  return function() {
    var _a;
    return h("div", { ref: root }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
  };
} });
function useDebouncedRef(value) {
  return customRef(function(track, trigger) {
    return { get: function get5() {
      track();
      return value;
    }, set: function set2(newValue) {
      value = newValue;
      requestAnimationFrame(function() {
        requestAnimationFrame(function() {
          trigger();
        });
      });
    } };
  });
}
var Editor = /* @__PURE__ */ function(_Editor$) {
  _inheritsLoose(Editor2, _Editor$);
  function Editor2(options) {
    var _this60;
    if (options === void 0) {
      options = {};
    }
    _this60 = _Editor$.call(this, options) || this;
    _this60.vueRenderers = reactive(/* @__PURE__ */ new Map());
    _this60.contentComponent = null;
    _this60.reactiveState = useDebouncedRef(_this60.view.state);
    _this60.reactiveExtensionStorage = useDebouncedRef(_this60.extensionStorage);
    _this60.on("transaction", function() {
      _this60.reactiveState.value = _this60.view.state;
      _this60.reactiveExtensionStorage.value = _this60.extensionStorage;
    });
    return markRaw(_assertThisInitialized(_this60)) || _assertThisInitialized(_this60);
  }
  var _proto67 = Editor2.prototype;
  _proto67.registerPlugin = function registerPlugin(plugin, handlePlugins) {
    _Editor$.prototype.registerPlugin.call(this, plugin, handlePlugins);
    this.reactiveState.value = this.view.state;
  };
  _proto67.unregisterPlugin = function unregisterPlugin(nameOrPluginKey) {
    _Editor$.prototype.unregisterPlugin.call(this, nameOrPluginKey);
    this.reactiveState.value = this.view.state;
  };
  _createClass(Editor2, [{ key: "state", get: function get5() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  } }, { key: "storage", get: function get5() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : _Editor$.prototype.storage;
  } }]);
  return Editor2;
}(Editor$1);
var EditorContent = defineComponent({ name: "EditorContent", props: { editor: { default: null, type: Object } }, setup: function setup2(props) {
  var rootEl = ref();
  var instance = getCurrentInstance();
  watchEffect(function() {
    var editor = props.editor;
    if (editor && editor.options.element && rootEl.value) {
      nextTick(function() {
        var _rootEl$value;
        if (!rootEl.value || !editor.options.element.firstChild) {
          return;
        }
        var element = unref(rootEl.value);
        (_rootEl$value = rootEl.value).append.apply(_rootEl$value, editor.options.element.childNodes);
        editor.contentComponent = instance.ctx._;
        editor.setOptions({ element });
        editor.createNodeViews();
      });
    }
  });
  onBeforeUnmount(function() {
    var editor = props.editor;
    if (!editor) {
      return;
    }
    if (!editor.isDestroyed) {
      editor.view.setProps({ nodeViews: {} });
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    var newElement = document.createElement("div");
    newElement.append.apply(newElement, editor.options.element.childNodes);
    editor.setOptions({ element: newElement });
  });
  return { rootEl };
}, render: function render2() {
  var _this61 = this;
  var vueRenderers = [];
  if (this.editor) {
    this.editor.vueRenderers.forEach(function(vueRenderer) {
      var node = h(Teleport, { to: vueRenderer.teleportElement, key: vueRenderer.id }, h(vueRenderer.component, _extends({ ref: vueRenderer.id }, vueRenderer.props)));
      vueRenderers.push(node);
    });
  }
  return h.apply(void 0, ["div", { ref: function ref2(el) {
    _this61.rootEl = el;
  } }].concat(vueRenderers));
} });
defineComponent({ name: "FloatingMenu", props: { pluginKey: {
  // TODO: TypeScript breaks :(
  // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
  type: null,
  default: "floatingMenu"
}, editor: { type: Object, required: true }, tippyOptions: { type: Object, default: function _default2() {
  return {};
} }, shouldShow: { type: Function, default: null } }, setup: function setup3(props, _ref106) {
  var slots = _ref106.slots;
  var root = ref(null);
  onMounted(function() {
    var pluginKey = props.pluginKey, editor = props.editor, tippyOptions = props.tippyOptions, shouldShow = props.shouldShow;
    editor.registerPlugin(FloatingMenuPlugin({ pluginKey, editor, element: root.value, tippyOptions, shouldShow }));
  });
  onBeforeUnmount(function() {
    var pluginKey = props.pluginKey, editor = props.editor;
    editor.unregisterPlugin(pluginKey);
  });
  return function() {
    var _a;
    return h("div", { ref: root }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
  };
} });
var NodeViewContent = defineComponent({ name: "NodeViewContent", props: { as: { type: String, default: "div" } }, render: function render3() {
  return h(this.as, { style: { whiteSpace: "pre-wrap" }, "data-node-view-content": "" });
} });
var NodeViewWrapper = defineComponent({ name: "NodeViewWrapper", props: { as: { type: String, default: "div" } }, inject: ["onDragStart", "decorationClasses"], render: function render4() {
  var _a, _b;
  return h(this.as, {
    // @ts-ignore
    class: this.decorationClasses,
    style: { whiteSpace: "normal" },
    "data-node-view-wrapper": "",
    // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
    onDragstart: this.onDragStart
  }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));
} });
var VueRenderer = /* @__PURE__ */ function() {
  function VueRenderer2(component, _ref107) {
    var _ref107$props = _ref107.props, props = _ref107$props === void 0 ? {} : _ref107$props, editor = _ref107.editor;
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.editor = editor;
    this.component = markRaw(component);
    this.teleportElement = document.createElement("div");
    this.element = this.teleportElement;
    this.props = reactive(props);
    this.editor.vueRenderers.set(this.id, this);
    if (this.editor.contentComponent) {
      this.editor.contentComponent.update();
      if (this.teleportElement.children.length !== 1) {
        throw Error("VueRenderer doesn’t support multiple child elements.");
      }
      this.element = this.teleportElement.firstElementChild;
    }
  }
  var _proto68 = VueRenderer2.prototype;
  _proto68.updateProps = function updateProps(props) {
    var _this62 = this;
    if (props === void 0) {
      props = {};
    }
    Object.entries(props).forEach(function(_ref108) {
      var key = _ref108[0], value = _ref108[1];
      _this62.props[key] = value;
    });
  };
  _proto68.destroy = function destroy() {
    this.editor.vueRenderers.delete(this.id);
  };
  _createClass(VueRenderer2, [{ key: "ref", get: function get5() {
    var _a;
    return (_a = this.editor.contentComponent) === null || _a === void 0 ? void 0 : _a.refs[this.id];
  } }]);
  return VueRenderer2;
}();
var nodeViewProps = { editor: { type: Object, required: true }, node: { type: Object, required: true }, decorations: { type: Object, required: true }, selected: { type: Boolean, required: true }, extension: { type: Object, required: true }, getPos: { type: Function, required: true }, updateAttributes: { type: Function, required: true }, deleteNode: { type: Function, required: true } };
var VueNodeView = /* @__PURE__ */ function(_NodeView) {
  _inheritsLoose(VueNodeView2, _NodeView);
  function VueNodeView2() {
    return _NodeView.apply(this, arguments) || this;
  }
  var _proto69 = VueNodeView2.prototype;
  _proto69.mount = function mount() {
    var _this63 = this;
    var props = { editor: this.editor, node: this.node, decorations: this.decorations, selected: false, extension: this.extension, getPos: function getPos() {
      return _this63.getPos();
    }, updateAttributes: function updateAttributes3(attributes) {
      if (attributes === void 0) {
        attributes = {};
      }
      return _this63.updateAttributes(attributes);
    }, deleteNode: function deleteNode3() {
      return _this63.deleteNode();
    } };
    var onDragStart = this.onDragStart.bind(this);
    this.decorationClasses = ref(this.getDecorationClasses());
    var extendedComponent = defineComponent({
      extends: _extends({}, this.component),
      props: Object.keys(props),
      template: this.component.template,
      setup: function setup5(reactiveProps) {
        var _a, _b;
        provide("onDragStart", onDragStart);
        provide("decorationClasses", _this63.decorationClasses);
        return (_b = (_a = _this63.component).setup) === null || _b === void 0 ? void 0 : _b.call(_a, reactiveProps, { expose: function expose() {
          return void 0;
        } });
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file
    });
    this.renderer = new VueRenderer(extendedComponent, { editor: this.editor, props });
  };
  _proto69.update = function update2(node, decorations) {
    var _this64 = this;
    var _updateProps = function updateProps(props) {
      _this64.decorationClasses.value = _this64.getDecorationClasses();
      _this64.renderer.updateProps(props);
    };
    if (typeof this.options.update === "function") {
      var oldNode = this.node;
      var oldDecorations = this.decorations;
      this.node = node;
      this.decorations = decorations;
      return this.options.update({ oldNode, oldDecorations, newNode: node, newDecorations: decorations, updateProps: function updateProps() {
        return _updateProps({ node, decorations });
      } });
    }
    if (node.type !== this.node.type) {
      return false;
    }
    if (node === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    _updateProps({ node, decorations });
    return true;
  };
  _proto69.selectNode = function selectNode() {
    this.renderer.updateProps({ selected: true });
    this.renderer.element.classList.add("ProseMirror-selectednode");
  };
  _proto69.deselectNode = function deselectNode() {
    this.renderer.updateProps({ selected: false });
    this.renderer.element.classList.remove("ProseMirror-selectednode");
  };
  _proto69.getDecorationClasses = function getDecorationClasses() {
    return this.decorations.map(function(item) {
      return item.type.attrs.class;
    }).flat().join(" ");
  };
  _proto69.destroy = function destroy() {
    this.renderer.destroy();
  };
  _createClass(VueNodeView2, [{ key: "dom", get: function get5() {
    if (!this.renderer.element.hasAttribute("data-node-view-wrapper")) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.element;
  } }, { key: "contentDOM", get: function get5() {
    if (this.node.isLeaf) {
      return null;
    }
    var contentElement = this.dom.querySelector("[data-node-view-content]");
    return contentElement || this.dom;
  } }]);
  return VueNodeView2;
}(NodeView);
function VueNodeViewRenderer(component, options) {
  return function(props) {
    if (!props.editor.contentComponent) {
      return {};
    }
    return new VueNodeView(component, props, options);
  };
}
var _sfc_main$1 = defineComponent$1({ name: "CodeHighlight", components: { NodeViewWrapper, NodeViewContent }, props: nodeViewProps, data: function data() {
  return { languages: this.extension.options.lowlight.listLanguages() };
}, computed: { selectedLanguage: { get: function get2() {
  return this.node.attrs.language;
}, set: function set(language) {
  this.updateAttributes({ language });
} } } });
var _hoisted_1$1 = /* @__PURE__ */ createElementVNode(
  "option",
  { value: "null" },
  "auto",
  -1
  /* HOISTED */
);
var _hoisted_2$1 = /* @__PURE__ */ createElementVNode(
  "option",
  { disabled: "" },
  "—",
  -1
  /* HOISTED */
);
var _hoisted_3$1 = ["value"];
function _sfc_render$1(_ctx, _cache, $props2, $setup, $data, $options) {
  var _component_NodeViewContent = resolveComponent("NodeViewContent");
  var _component_NodeViewWrapper = resolveComponent("NodeViewWrapper");
  return openBlock(), createBlock(_component_NodeViewWrapper, { class: "code-block" }, {
    default: withCtx(function() {
      return [withDirectives(createElementVNode(
        "select",
        { contenteditable: "false", "onUpdate:modelValue": _cache[0] || (_cache[0] = function($event) {
          return _ctx.selectedLanguage = $event;
        }) },
        [_hoisted_1$1, _hoisted_2$1, (openBlock(true), createElementBlock(
          Fragment$1,
          null,
          renderList(_ctx.languages, function(item, index) {
            return openBlock(), createElementBlock("option", { value: item, key: index }, toDisplayString(item), 9, _hoisted_3$1);
          }),
          128
          /* KEYED_FRAGMENT */
        ))],
        512
        /* NEED_PATCH */
      ), [[vModelSelect, _ctx.selectedLanguage]]), createElementVNode("pre", null, [createElementVNode("code", null, [createVNode(_component_NodeViewContent)])])];
    }),
    _: 1
    /* STABLE */
  });
}
var codeHighlight = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var inputRegex$7 = /^\s*>\s$/;
var Blockquote = Node.create({ name: "blockquote", addOptions: function addOptions3() {
  return { HTMLAttributes: {} };
}, content: "block+", group: "block", defining: true, parseHTML: function parseHTML() {
  return [{ tag: "blockquote" }];
}, renderHTML: function renderHTML(_ref109) {
  var HTMLAttributes = _ref109.HTMLAttributes;
  return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands2() {
  var _this65 = this;
  return { setBlockquote: function setBlockquote() {
    return function(_ref110) {
      var commands2 = _ref110.commands;
      return commands2.wrapIn(_this65.name);
    };
  }, toggleBlockquote: function toggleBlockquote() {
    return function(_ref111) {
      var commands2 = _ref111.commands;
      return commands2.toggleWrap(_this65.name);
    };
  }, unsetBlockquote: function unsetBlockquote() {
    return function(_ref112) {
      var commands2 = _ref112.commands;
      return commands2.lift(_this65.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts2() {
  var _this66 = this;
  return { "Mod-Shift-b": function ModShiftB() {
    return _this66.editor.commands.toggleBlockquote();
  } };
}, addInputRules: function addInputRules() {
  return [wrappingInputRule({ find: inputRegex$7, type: this.type })];
} });
var starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
var starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
var underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
var underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
var Bold = Mark.create({ name: "bold", addOptions: function addOptions4() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML2() {
  return [{ tag: "strong" }, { tag: "b", getAttrs: function getAttrs(node) {
    return node.style.fontWeight !== "normal" && null;
  } }, { style: "font-weight", getAttrs: function getAttrs(value) {
    return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
  } }];
}, renderHTML: function renderHTML2(_ref113) {
  var HTMLAttributes = _ref113.HTMLAttributes;
  return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands3() {
  var _this67 = this;
  return { setBold: function setBold() {
    return function(_ref114) {
      var commands2 = _ref114.commands;
      return commands2.setMark(_this67.name);
    };
  }, toggleBold: function toggleBold() {
    return function(_ref115) {
      var commands2 = _ref115.commands;
      return commands2.toggleMark(_this67.name);
    };
  }, unsetBold: function unsetBold() {
    return function(_ref116) {
      var commands2 = _ref116.commands;
      return commands2.unsetMark(_this67.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts3() {
  var _this68 = this;
  return { "Mod-b": function ModB() {
    return _this68.editor.commands.toggleBold();
  }, "Mod-B": function ModB() {
    return _this68.editor.commands.toggleBold();
  } };
}, addInputRules: function addInputRules2() {
  return [markInputRule({ find: starInputRegex$1, type: this.type }), markInputRule({ find: underscoreInputRegex$1, type: this.type })];
}, addPasteRules: function addPasteRules() {
  return [markPasteRule({ find: starPasteRegex$1, type: this.type }), markPasteRule({ find: underscorePasteRegex$1, type: this.type })];
} });
var ListItem$2 = Node.create({ name: "listItem", addOptions: function addOptions5() {
  return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" };
}, content: "paragraph block*", defining: true, parseHTML: function parseHTML3() {
  return [{ tag: "li" }];
}, renderHTML: function renderHTML3(_ref117) {
  var HTMLAttributes = _ref117.HTMLAttributes;
  return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addKeyboardShortcuts: function addKeyboardShortcuts4() {
  var _this69 = this;
  return { Enter: function Enter() {
    return _this69.editor.commands.splitListItem(_this69.name);
  }, Tab: function Tab() {
    return _this69.editor.commands.sinkListItem(_this69.name);
  }, "Shift-Tab": function ShiftTab() {
    return _this69.editor.commands.liftListItem(_this69.name);
  } };
} });
var TextStyle$2 = Mark.create({ name: "textStyle", addOptions: function addOptions6() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML4() {
  return [{ tag: "span", getAttrs: function getAttrs(element) {
    var hasStyles = element.hasAttribute("style");
    if (!hasStyles) {
      return false;
    }
    return {};
  } }];
}, renderHTML: function renderHTML4(_ref118) {
  var HTMLAttributes = _ref118.HTMLAttributes;
  return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands4() {
  var _this70 = this;
  return { removeEmptyTextStyle: function removeEmptyTextStyle() {
    return function(_ref119) {
      var state = _ref119.state, commands2 = _ref119.commands;
      var attributes = getMarkAttributes(state, _this70.type);
      var hasStyles = Object.entries(attributes).some(function(_ref120) {
        var value = _ref120[1];
        return !!value;
      });
      if (hasStyles) {
        return true;
      }
      return commands2.unsetMark(_this70.name);
    };
  } };
} });
var inputRegex$6 = /^\s*([-+*])\s$/;
var BulletList = Node.create({ name: "bulletList", addOptions: function addOptions7() {
  return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: false, keepAttributes: false };
}, group: "block list", content: function content() {
  return this.options.itemTypeName + "+";
}, parseHTML: function parseHTML5() {
  return [{ tag: "ul" }];
}, renderHTML: function renderHTML5(_ref121) {
  var HTMLAttributes = _ref121.HTMLAttributes;
  return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands5() {
  var _this71 = this;
  return { toggleBulletList: function toggleBulletList() {
    return function(_ref122) {
      var commands2 = _ref122.commands, chain = _ref122.chain;
      if (_this71.options.keepAttributes) {
        return chain().toggleList(_this71.name, _this71.options.itemTypeName, _this71.options.keepMarks).updateAttributes(ListItem$2.name, _this71.editor.getAttributes(TextStyle$2.name)).run();
      }
      return commands2.toggleList(_this71.name, _this71.options.itemTypeName, _this71.options.keepMarks);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts5() {
  var _this72 = this;
  return { "Mod-Shift-8": function ModShift8() {
    return _this72.editor.commands.toggleBulletList();
  } };
}, addInputRules: function addInputRules3() {
  var _this73 = this;
  var inputRule = wrappingInputRule({ find: inputRegex$6, type: this.type });
  if (this.options.keepMarks || this.options.keepAttributes) {
    inputRule = wrappingInputRule({ find: inputRegex$6, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: function getAttributes() {
      return _this73.editor.getAttributes(TextStyle$2.name);
    }, editor: this.editor });
  }
  return [inputRule];
} });
var inputRegex$5 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
var pasteRegex$2 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
var Code = Mark.create({ name: "code", addOptions: function addOptions8() {
  return { HTMLAttributes: {} };
}, excludes: "_", code: true, exitable: true, parseHTML: function parseHTML6() {
  return [{ tag: "code" }];
}, renderHTML: function renderHTML6(_ref123) {
  var HTMLAttributes = _ref123.HTMLAttributes;
  return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands6() {
  var _this74 = this;
  return { setCode: function setCode() {
    return function(_ref124) {
      var commands2 = _ref124.commands;
      return commands2.setMark(_this74.name);
    };
  }, toggleCode: function toggleCode() {
    return function(_ref125) {
      var commands2 = _ref125.commands;
      return commands2.toggleMark(_this74.name);
    };
  }, unsetCode: function unsetCode() {
    return function(_ref126) {
      var commands2 = _ref126.commands;
      return commands2.unsetMark(_this74.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts6() {
  var _this75 = this;
  return { "Mod-e": function ModE() {
    return _this75.editor.commands.toggleCode();
  } };
}, addInputRules: function addInputRules4() {
  return [markInputRule({ find: inputRegex$5, type: this.type })];
}, addPasteRules: function addPasteRules2() {
  return [markPasteRule({ find: pasteRegex$2, type: this.type })];
} });
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node.create({ name: "codeBlock", addOptions: function addOptions9() {
  return { languageClassPrefix: "language-", exitOnTripleEnter: true, exitOnArrowDown: true, HTMLAttributes: {} };
}, content: "text*", marks: "", group: "block", code: true, defining: true, addAttributes: function addAttributes() {
  var _this76 = this;
  return { language: { default: null, parseHTML: function parseHTML31(element) {
    var _a;
    var languageClassPrefix = _this76.options.languageClassPrefix;
    var classNames = [].concat(((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []);
    var languages = classNames.filter(function(className) {
      return className.startsWith(languageClassPrefix);
    }).map(function(className) {
      return className.replace(languageClassPrefix, "");
    });
    var language = languages[0];
    if (!language) {
      return null;
    }
    return language;
  }, rendered: false } };
}, parseHTML: function parseHTML7() {
  return [{ tag: "pre", preserveWhitespace: "full" }];
}, renderHTML: function renderHTML7(_ref127) {
  var node = _ref127.node, HTMLAttributes = _ref127.HTMLAttributes;
  return ["pre", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ["code", { class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null }, 0]];
}, addCommands: function addCommands7() {
  var _this77 = this;
  return { setCodeBlock: function setCodeBlock(attributes) {
    return function(_ref128) {
      var commands2 = _ref128.commands;
      return commands2.setNode(_this77.name, attributes);
    };
  }, toggleCodeBlock: function toggleCodeBlock(attributes) {
    return function(_ref129) {
      var commands2 = _ref129.commands;
      return commands2.toggleNode(_this77.name, "paragraph", attributes);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts7() {
  var _this78 = this;
  return {
    "Mod-Alt-c": function ModAltC() {
      return _this78.editor.commands.toggleCodeBlock();
    },
    // remove code block when at start of document or code block is empty
    Backspace: function Backspace() {
      var _this78$editor$state$ = _this78.editor.state.selection, empty2 = _this78$editor$state$.empty, $anchor = _this78$editor$state$.$anchor;
      var isAtStart = $anchor.pos === 1;
      if (!empty2 || $anchor.parent.type.name !== _this78.name) {
        return false;
      }
      if (isAtStart || !$anchor.parent.textContent.length) {
        return _this78.editor.commands.clearNodes();
      }
      return false;
    },
    // exit node on triple enter
    Enter: function Enter(_ref130) {
      var editor = _ref130.editor;
      if (!_this78.options.exitOnTripleEnter) {
        return false;
      }
      var state = editor.state;
      var selection = state.selection;
      var $from = selection.$from, empty2 = selection.empty;
      if (!empty2 || $from.parent.type !== _this78.type) {
        return false;
      }
      var isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
      var endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
      if (!isAtEnd || !endsWithDoubleNewline) {
        return false;
      }
      return editor.chain().command(function(_ref131) {
        var tr4 = _ref131.tr;
        tr4.delete($from.pos - 2, $from.pos);
        return true;
      }).exitCode().run();
    },
    // exit node on arrow down
    ArrowDown: function ArrowDown(_ref132) {
      var editor = _ref132.editor;
      if (!_this78.options.exitOnArrowDown) {
        return false;
      }
      var state = editor.state;
      var selection = state.selection, doc2 = state.doc;
      var $from = selection.$from, empty2 = selection.empty;
      if (!empty2 || $from.parent.type !== _this78.type) {
        return false;
      }
      var isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
      if (!isAtEnd) {
        return false;
      }
      var after = $from.after();
      if (after === void 0) {
        return false;
      }
      var nodeAfter = doc2.nodeAt(after);
      if (nodeAfter) {
        return false;
      }
      return editor.commands.exitCode();
    }
  };
}, addInputRules: function addInputRules5() {
  return [textblockTypeInputRule({ find: backtickInputRegex, type: this.type, getAttributes: function getAttributes(match) {
    return { language: match[1] };
  } }), textblockTypeInputRule({ find: tildeInputRegex, type: this.type, getAttributes: function getAttributes(match) {
    return { language: match[1] };
  } })];
}, addProseMirrorPlugins: function addProseMirrorPlugins8() {
  var _this79 = this;
  return [
    // this plugin creates a code block for pasted content from VS Code
    // we can also detect the copied code language
    new Plugin({ key: new PluginKey("codeBlockVSCodeHandler"), props: { handlePaste: function handlePaste2(view, event) {
      if (!event.clipboardData) {
        return false;
      }
      if (_this79.editor.isActive(_this79.type.name)) {
        return false;
      }
      var text = event.clipboardData.getData("text/plain");
      var vscode = event.clipboardData.getData("vscode-editor-data");
      var vscodeData = vscode ? JSON.parse(vscode) : void 0;
      var language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
      if (!text || !language) {
        return false;
      }
      var tr4 = view.state.tr;
      tr4.replaceSelectionWith(_this79.type.create({ language }));
      tr4.setSelection(TextSelection.near(tr4.doc.resolve(Math.max(0, tr4.selection.from - 2))));
      tr4.insertText(text.replace(/\r\n?/g, "\n"));
      tr4.setMeta("paste", true);
      view.dispatch(tr4);
      return true;
    } } })
  ];
} });
var Document = Node.create({ name: "doc", topNode: true, content: "block+" });
function dropCursor(options) {
  if (options === void 0) {
    options = {};
  }
  return new Plugin({ view: function view(editorView) {
    return new DropCursorView(editorView, options);
  } });
}
var DropCursorView = /* @__PURE__ */ function() {
  function DropCursorView2(editorView, options) {
    var _this80 = this;
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function(name) {
      var handler = function handler2(e) {
        _this80[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  var _proto70 = DropCursorView2.prototype;
  _proto70.destroy = function destroy() {
    var _this81 = this;
    this.handlers.forEach(function(_ref133) {
      var name = _ref133.name, handler = _ref133.handler;
      return _this81.editorView.dom.removeEventListener(name, handler);
    });
  };
  _proto70.update = function update2(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  };
  _proto70.setCursor = function setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  };
  _proto70.updateOverlay = function updateOverlay() {
    var $pos = this.editorView.state.doc.resolve(this.cursorPos);
    var isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      var before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        var node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          var nodeRect = node.getBoundingClientRect();
          var _top4 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            _top4 = (_top4 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: _top4 - this.width / 2, bottom: _top4 + this.width / 2 };
        }
      }
    }
    if (!rect) {
      var coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    var parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    var parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      var _rect = parent.getBoundingClientRect();
      parentLeft = _rect.left - parent.scrollLeft;
      parentTop = _rect.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  };
  _proto70.scheduleRemoval = function scheduleRemoval(timeout) {
    var _this82 = this;
    clearTimeout(this.timeout);
    this.timeout = setTimeout(function() {
      return _this82.setCursor(null);
    }, timeout);
  };
  _proto70.dragover = function dragover(event) {
    if (!this.editorView.editable)
      return;
    var pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    var node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    var disableDropCursor = node && node.type.spec.disableDropCursor;
    var disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      var target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        var point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  };
  _proto70.dragend = function dragend() {
    this.scheduleRemoval(20);
  };
  _proto70.drop = function drop() {
    this.scheduleRemoval(20);
  };
  _proto70.dragleave = function dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  };
  return DropCursorView2;
}();
var Dropcursor = Extension.create({ name: "dropCursor", addOptions: function addOptions10() {
  return { color: "currentColor", width: 1, class: void 0 };
}, addProseMirrorPlugins: function addProseMirrorPlugins9() {
  return [dropCursor(this.options)];
} });
var GapCursor = /* @__PURE__ */ function(_Selection4) {
  _inheritsLoose(GapCursor2, _Selection4);
  function GapCursor2($pos) {
    return _Selection4.call(this, $pos, $pos) || this;
  }
  var _proto71 = GapCursor2.prototype;
  _proto71.map = function map3(doc2, mapping) {
    var $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor2.valid($pos) ? new GapCursor2($pos) : Selection.near($pos);
  };
  _proto71.content = function content5() {
    return Slice.empty;
  };
  _proto71.eq = function eq(other) {
    return other instanceof GapCursor2 && other.head == this.head;
  };
  _proto71.toJSON = function toJSON() {
    return { type: "gapcursor", pos: this.head };
  };
  GapCursor2.fromJSON = function fromJSON(doc2, json2) {
    if (typeof json2.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor2(doc2.resolve(json2.pos));
  };
  _proto71.getBookmark = function getBookmark() {
    return new GapBookmark(this.anchor);
  };
  GapCursor2.valid = function valid($pos) {
    var parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    var override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    var deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  };
  GapCursor2.findGapCursorFrom = function findGapCursorFrom($pos, dir, mustMove) {
    if (mustMove === void 0) {
      mustMove = false;
    }
    search:
      for (; ; ) {
        if (!mustMove && GapCursor2.valid($pos))
          return $pos;
        var pos = $pos.pos, next = null;
        for (var d = $pos.depth; ; d--) {
          var parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          var $cur = $pos.doc.resolve(pos);
          if (GapCursor2.valid($cur))
            return $cur;
        }
        for (; ; ) {
          var inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          var _$cur = $pos.doc.resolve(pos);
          if (GapCursor2.valid(_$cur))
            return _$cur;
        }
        return null;
      }
  };
  return GapCursor2;
}(Selection);
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = /* @__PURE__ */ function() {
  function GapBookmark2(pos) {
    this.pos = pos;
  }
  var _proto72 = GapBookmark2.prototype;
  _proto72.map = function map3(mapping) {
    return new GapBookmark2(mapping.map(this.pos));
  };
  _proto72.resolve = function resolve2(doc2) {
    var $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  };
  return GapBookmark2;
}();
function closedBefore($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (var before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (var after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({ props: { decorations: drawGapCursor, createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
    return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
  }, handleClick, handleKeyDown: handleKeyDown$1, handleDOMEvents: { beforeinput } } });
}
var handleKeyDown$1 = keydownHandler({ "ArrowLeft": arrow$1("horiz", -1), "ArrowRight": arrow$1("horiz", 1), "ArrowUp": arrow$1("vert", -1), "ArrowDown": arrow$1("vert", 1) });
function arrow$1(axis, dir) {
  var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  var $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  var clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  var $from = view.state.selection.$from;
  var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  var frag = Fragment.empty;
  for (var _i204 = insert.length - 1; _i204 >= 0; _i204--)
    frag = Fragment.from(insert[_i204].createAndFill(null, frag));
  var tr4 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr4.setSelection(TextSelection.near(tr4.doc.resolve($from.pos + 1)));
  view.dispatch(tr4);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  var node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
var Gapcursor = Extension.create({ name: "gapCursor", addProseMirrorPlugins: function addProseMirrorPlugins10() {
  return [gapCursor()];
}, extendNodeSchema: function extendNodeSchema(extension) {
  var _a;
  var context = { name: extension.name, options: extension.options, storage: extension.storage };
  return { allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null };
} });
var HardBreak = Node.create({ name: "hardBreak", addOptions: function addOptions11() {
  return { keepMarks: true, HTMLAttributes: {} };
}, inline: true, group: "inline", selectable: false, parseHTML: function parseHTML8() {
  return [{ tag: "br" }];
}, renderHTML: function renderHTML8(_ref134) {
  var HTMLAttributes = _ref134.HTMLAttributes;
  return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
}, renderText: function renderText() {
  return "\n";
}, addCommands: function addCommands8() {
  var _this83 = this;
  return { setHardBreak: function setHardBreak() {
    return function(_ref135) {
      var commands2 = _ref135.commands, chain = _ref135.chain, state = _ref135.state, editor = _ref135.editor;
      return commands2.first([function() {
        return commands2.exitCode();
      }, function() {
        return commands2.command(function() {
          var selection = state.selection, storedMarks = state.storedMarks;
          if (selection.$from.parent.type.spec.isolating) {
            return false;
          }
          var keepMarks = _this83.options.keepMarks;
          var splittableMarks = editor.extensionManager.splittableMarks;
          var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
          return chain().insertContent({ type: _this83.name }).command(function(_ref136) {
            var tr4 = _ref136.tr, dispatch = _ref136.dispatch;
            if (dispatch && marks && keepMarks) {
              var filteredMarks = marks.filter(function(mark) {
                return splittableMarks.includes(mark.type.name);
              });
              tr4.ensureMarks(filteredMarks);
            }
            return true;
          }).run();
        });
      }]);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts8() {
  var _this84 = this;
  return { "Mod-Enter": function ModEnter() {
    return _this84.editor.commands.setHardBreak();
  }, "Shift-Enter": function ShiftEnter() {
    return _this84.editor.commands.setHardBreak();
  } };
} });
var Heading = Node.create({ name: "heading", addOptions: function addOptions12() {
  return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
}, content: "inline*", group: "block", defining: true, addAttributes: function addAttributes2() {
  return { level: { default: 1, rendered: false } };
}, parseHTML: function parseHTML9() {
  return this.options.levels.map(function(level) {
    return { tag: "h" + level, attrs: { level } };
  });
}, renderHTML: function renderHTML9(_ref137) {
  var node = _ref137.node, HTMLAttributes = _ref137.HTMLAttributes;
  var hasLevel = this.options.levels.includes(node.attrs.level);
  var level = hasLevel ? node.attrs.level : this.options.levels[0];
  return ["h" + level, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands9() {
  var _this85 = this;
  return { setHeading: function setHeading(attributes) {
    return function(_ref138) {
      var commands2 = _ref138.commands;
      if (!_this85.options.levels.includes(attributes.level)) {
        return false;
      }
      return commands2.setNode(_this85.name, attributes);
    };
  }, toggleHeading: function toggleHeading(attributes) {
    return function(_ref139) {
      var commands2 = _ref139.commands;
      if (!_this85.options.levels.includes(attributes.level)) {
        return false;
      }
      return commands2.toggleNode(_this85.name, "paragraph", attributes);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts9() {
  var _this86 = this;
  return this.options.levels.reduce(function(items, level) {
    var _extends3;
    return _extends({}, items, (_extends3 = {}, _extends3["Mod-Alt-" + level] = function ModAlt() {
      return _this86.editor.commands.toggleHeading({ level });
    }, _extends3));
  }, {});
}, addInputRules: function addInputRules6() {
  var _this87 = this;
  return this.options.levels.map(function(level) {
    return textblockTypeInputRule({ find: new RegExp("^(#{1," + level + "})\\s$"), type: _this87.type, getAttributes: { level } });
  });
} });
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend2(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get3(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach4(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var max_empty_items = 500;
var Branch = /* @__PURE__ */ function() {
  function Branch2(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  var _proto73 = Branch2.prototype;
  _proto73.popEvent = function popEvent(state, preserveItems) {
    var _this88 = this;
    if (this.eventCount == 0)
      return null;
    var end2 = this.items.length;
    for (; ; end2--) {
      var next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    var remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    var transform = state.tr;
    var selection, remaining;
    var addAfter = [], addBefore2 = [];
    this.items.forEach(function(item, i) {
      if (!item.step) {
        if (!remap) {
          remap = _this88.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore2.push(item);
        return;
      }
      if (remap) {
        addBefore2.push(new Item(item.map));
        var step = item.step.map(remap.slice(mapFrom)), map3;
        if (step && transform.maybeStep(step).doc) {
          map3 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map3, void 0, void 0, addAfter.length + addBefore2.length));
        }
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch2(_this88.items.slice(0, end2).append(addBefore2.reverse().concat(addAfter)), _this88.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  };
  _proto73.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
    var newItems = [], eventCount = this.eventCount;
    var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (var _i205 = 0; _i205 < transform.steps.length; _i205++) {
      var step = transform.steps[_i205].invert(transform.docs[_i205]);
      var item = new Item(transform.mapping.maps[_i205], step, selection), merged = void 0;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (_i205)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    var overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch2(oldItems.append(newItems), eventCount);
  };
  _proto73.remapping = function remapping(from2, to) {
    var maps = new Mapping();
    this.items.forEach(function(item, i) {
      var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  };
  _proto73.addMaps = function addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch2(this.items.append(array.map(function(map3) {
      return new Item(map3);
    })), this.eventCount);
  };
  _proto73.rebased = function rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    var rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    var mapping = rebasedTransform.mapping;
    var newUntil = rebasedTransform.steps.length;
    var eventCount = this.eventCount;
    this.items.forEach(function(item) {
      if (item.selection)
        eventCount--;
    }, start2);
    var iRebased = rebasedCount;
    this.items.forEach(function(item) {
      var pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      var map3 = mapping.maps[pos];
      if (item.step) {
        var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map3, step, selection));
      } else {
        rebasedItems.push(new Item(map3));
      }
    }, start2);
    var newMaps = [];
    for (var _i206 = rebasedCount; _i206 < newUntil; _i206++)
      newMaps.push(new Item(mapping.maps[_i206]));
    var items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    var branch = new Branch2(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  };
  _proto73.emptyItemCount = function emptyItemCount() {
    var count = 0;
    this.items.forEach(function(item) {
      if (!item.step)
        count++;
    });
    return count;
  };
  _proto73.compress = function compress(upto) {
    if (upto === void 0) {
      upto = this.items.length;
    }
    var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    var items = [], events = 0;
    this.items.forEach(function(item, i) {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        var step = item.step.map(remap.slice(mapFrom)), map3 = step && step.getMap();
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
        if (step) {
          var selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          var newItem = new Item(map3.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch2(RopeSequence.from(items.reverse()), events);
  };
  return Branch2;
}();
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function(item, i) {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = /* @__PURE__ */ function() {
  function Item2(map3, step, selection, mirrorOffset) {
    this.map = map3;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  var _proto74 = Item2.prototype;
  _proto74.merge = function merge(other) {
    if (this.step && other.step && !other.selection) {
      var step = other.step.merge(this.step);
      if (step)
        return new Item2(step.getMap().invert(), step, this.selection);
    }
  };
  return Item2;
}();
var HistoryState = function HistoryState2(done, undone, prevRanges, prevTime, prevComposition) {
  this.done = done;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
  this.prevComposition = prevComposition;
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr4, options) {
  var historyTr = tr4.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr4.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  var appended = tr4.getMeta("appendedTransaction");
  if (tr4.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr4, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr4.mapping.maps[tr4.steps.length - 1]), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr4, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr4.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var composition = tr4.getMeta("composition");
    var newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr4.time || 0) - options.newGroupDelay || !isAdjacentTo(tr4, history2.prevRanges));
    var prevRanges = appended ? mapRanges(history2.prevRanges, tr4.mapping) : rangesFor(tr4.mapping.maps[tr4.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr4, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr4.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr4.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr4, rebased), history2.undone.rebased(tr4, rebased), mapRanges(history2.prevRanges, tr4.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr4.mapping.maps), history2.undone.addMaps(tr4.mapping.maps), mapRanges(history2.prevRanges, tr4.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  var adjacent = false;
  transform.mapping.maps[0].forEach(function(start2, end2) {
    for (var _i207 = 0; _i207 < prevRanges.length; _i207 += 2)
      if (start2 <= prevRanges[_i207 + 1] && end2 >= prevRanges[_i207])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map3) {
  var result = [];
  map3.forEach(function(_from, _to, from2, to) {
    return result.push(from2, to);
  });
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  var result = [];
  for (var _i208 = 0; _i208 < ranges.length; _i208 += 2) {
    var _from18 = mapping.map(ranges[_i208], 1), to = mapping.map(ranges[_i208 + 1], -1);
    if (_from18 <= to)
      result.push(_from18, to);
  }
  return result;
}
function histTransaction(history2, state, dispatch, redo2) {
  var preserveItems = mustPreserveItems(state);
  var histOptions = historyKey.get(state).spec.config;
  var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return;
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var _i209 = 0; _i209 < plugins.length; _i209++)
      if (plugins[_i209].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config) {
  if (config === void 0) {
    config = {};
  }
  config = { depth: config.depth || 100, newGroupDelay: config.newGroupDelay || 500 };
  return new Plugin({ key: historyKey, state: { init: function init6() {
    return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
  }, apply: function apply6(tr4, hist, state) {
    return applyTransaction(hist, state, tr4, config);
  } }, config, props: { handleDOMEvents: { beforeinput: function beforeinput2(view, e) {
    var inputType = e.inputType;
    var command3 = inputType == "historyUndo" ? _undo : inputType == "historyRedo" ? _redo : null;
    if (!command3)
      return false;
    e.preventDefault();
    return command3(view.state, view.dispatch);
  } } } });
}
var _undo = function undo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, false);
  return true;
};
var _redo = function redo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, true);
  return true;
};
var History = Extension.create({ name: "history", addOptions: function addOptions13() {
  return { depth: 100, newGroupDelay: 500 };
}, addCommands: function addCommands10() {
  return { undo: function undo2() {
    return function(_ref140) {
      var state = _ref140.state, dispatch = _ref140.dispatch;
      return _undo(state, dispatch);
    };
  }, redo: function redo2() {
    return function(_ref141) {
      var state = _ref141.state, dispatch = _ref141.dispatch;
      return _redo(state, dispatch);
    };
  } };
}, addProseMirrorPlugins: function addProseMirrorPlugins11() {
  return [history(this.options)];
}, addKeyboardShortcuts: function addKeyboardShortcuts10() {
  var _this89 = this;
  return {
    "Mod-z": function ModZ() {
      return _this89.editor.commands.undo();
    },
    "Mod-Z": function ModZ() {
      return _this89.editor.commands.undo();
    },
    "Mod-y": function ModY() {
      return _this89.editor.commands.redo();
    },
    "Mod-Y": function ModY() {
      return _this89.editor.commands.redo();
    },
    "Shift-Mod-z": function ShiftModZ() {
      return _this89.editor.commands.redo();
    },
    "Shift-Mod-Z": function ShiftModZ() {
      return _this89.editor.commands.redo();
    },
    // Russian keyboard layouts
    "Mod-я": function ModЯ() {
      return _this89.editor.commands.undo();
    },
    "Shift-Mod-я": function ShiftModЯ() {
      return _this89.editor.commands.redo();
    }
  };
} });
var HorizontalRule = Node.create({ name: "horizontalRule", addOptions: function addOptions14() {
  return { HTMLAttributes: {} };
}, group: "block", parseHTML: function parseHTML10() {
  return [{ tag: "hr" }];
}, renderHTML: function renderHTML10(_ref142) {
  var HTMLAttributes = _ref142.HTMLAttributes;
  return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
}, addCommands: function addCommands11() {
  var _this90 = this;
  return { setHorizontalRule: function setHorizontalRule() {
    return function(_ref143) {
      var chain = _ref143.chain, state = _ref143.state;
      var $originTo = state.selection.$to;
      var currentChain = chain();
      if ($originTo.parentOffset === 0) {
        currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: _this90.name });
      } else {
        currentChain.insertContent({ type: _this90.name });
      }
      return currentChain.command(function(_ref144) {
        var tr4 = _ref144.tr, dispatch = _ref144.dispatch;
        var _a;
        if (dispatch) {
          var $to = tr4.selection.$to;
          var posAfter = $to.end();
          if ($to.nodeAfter) {
            if ($to.nodeAfter.isTextblock) {
              tr4.setSelection(TextSelection.create(tr4.doc, $to.pos + 1));
            } else if ($to.nodeAfter.isBlock) {
              tr4.setSelection(NodeSelection.create(tr4.doc, $to.pos));
            } else {
              tr4.setSelection(TextSelection.create(tr4.doc, $to.pos));
            }
          } else {
            var node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
            if (node) {
              tr4.insert(posAfter, node);
              tr4.setSelection(TextSelection.create(tr4.doc, posAfter + 1));
            }
          }
          tr4.scrollIntoView();
        }
        return true;
      }).run();
    };
  } };
}, addInputRules: function addInputRules7() {
  return [nodeInputRule({ find: /^(?:---|—-|___\s|\*\*\*\s)$/, type: this.type })];
} });
var starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
var starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
var underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
var underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
var Italic = Mark.create({ name: "italic", addOptions: function addOptions15() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML11() {
  return [{ tag: "em" }, { tag: "i", getAttrs: function getAttrs(node) {
    return node.style.fontStyle !== "normal" && null;
  } }, { style: "font-style=italic" }];
}, renderHTML: function renderHTML11(_ref145) {
  var HTMLAttributes = _ref145.HTMLAttributes;
  return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands12() {
  var _this91 = this;
  return { setItalic: function setItalic() {
    return function(_ref146) {
      var commands2 = _ref146.commands;
      return commands2.setMark(_this91.name);
    };
  }, toggleItalic: function toggleItalic() {
    return function(_ref147) {
      var commands2 = _ref147.commands;
      return commands2.toggleMark(_this91.name);
    };
  }, unsetItalic: function unsetItalic() {
    return function(_ref148) {
      var commands2 = _ref148.commands;
      return commands2.unsetMark(_this91.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts11() {
  var _this92 = this;
  return { "Mod-i": function ModI() {
    return _this92.editor.commands.toggleItalic();
  }, "Mod-I": function ModI() {
    return _this92.editor.commands.toggleItalic();
  } };
}, addInputRules: function addInputRules8() {
  return [markInputRule({ find: starInputRegex, type: this.type }), markInputRule({ find: underscoreInputRegex, type: this.type })];
}, addPasteRules: function addPasteRules3() {
  return [markPasteRule({ find: starPasteRegex, type: this.type }), markPasteRule({ find: underscorePasteRegex, type: this.type })];
} });
var ListItem$1 = Node.create({ name: "listItem", addOptions: function addOptions16() {
  return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" };
}, content: "paragraph block*", defining: true, parseHTML: function parseHTML12() {
  return [{ tag: "li" }];
}, renderHTML: function renderHTML12(_ref149) {
  var HTMLAttributes = _ref149.HTMLAttributes;
  return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addKeyboardShortcuts: function addKeyboardShortcuts12() {
  var _this93 = this;
  return { Enter: function Enter() {
    return _this93.editor.commands.splitListItem(_this93.name);
  }, Tab: function Tab() {
    return _this93.editor.commands.sinkListItem(_this93.name);
  }, "Shift-Tab": function ShiftTab() {
    return _this93.editor.commands.liftListItem(_this93.name);
  } };
} });
var ListItem = Node.create({ name: "listItem", addOptions: function addOptions17() {
  return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" };
}, content: "paragraph block*", defining: true, parseHTML: function parseHTML13() {
  return [{ tag: "li" }];
}, renderHTML: function renderHTML13(_ref150) {
  var HTMLAttributes = _ref150.HTMLAttributes;
  return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addKeyboardShortcuts: function addKeyboardShortcuts13() {
  var _this94 = this;
  return { Enter: function Enter() {
    return _this94.editor.commands.splitListItem(_this94.name);
  }, Tab: function Tab() {
    return _this94.editor.commands.sinkListItem(_this94.name);
  }, "Shift-Tab": function ShiftTab() {
    return _this94.editor.commands.liftListItem(_this94.name);
  } };
} });
var TextStyle$1 = Mark.create({ name: "textStyle", addOptions: function addOptions18() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML14() {
  return [{ tag: "span", getAttrs: function getAttrs(element) {
    var hasStyles = element.hasAttribute("style");
    if (!hasStyles) {
      return false;
    }
    return {};
  } }];
}, renderHTML: function renderHTML14(_ref151) {
  var HTMLAttributes = _ref151.HTMLAttributes;
  return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands13() {
  var _this95 = this;
  return { removeEmptyTextStyle: function removeEmptyTextStyle() {
    return function(_ref152) {
      var state = _ref152.state, commands2 = _ref152.commands;
      var attributes = getMarkAttributes(state, _this95.type);
      var hasStyles = Object.entries(attributes).some(function(_ref153) {
        var value = _ref153[1];
        return !!value;
      });
      if (hasStyles) {
        return true;
      }
      return commands2.unsetMark(_this95.name);
    };
  } };
} });
var inputRegex$4 = /^(\d+)\.\s$/;
var OrderedList = Node.create({ name: "orderedList", addOptions: function addOptions19() {
  return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: false, keepAttributes: false };
}, group: "block list", content: function content2() {
  return this.options.itemTypeName + "+";
}, addAttributes: function addAttributes3() {
  return { start: { default: 1, parseHTML: function parseHTML31(element) {
    return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
  } } };
}, parseHTML: function parseHTML15() {
  return [{ tag: "ol" }];
}, renderHTML: function renderHTML15(_ref154) {
  var HTMLAttributes = _ref154.HTMLAttributes;
  var start2 = HTMLAttributes.start, attributesWithoutStart = _objectWithoutPropertiesLoose(HTMLAttributes, _excluded);
  return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands14() {
  var _this96 = this;
  return { toggleOrderedList: function toggleOrderedList() {
    return function(_ref155) {
      var commands2 = _ref155.commands, chain = _ref155.chain;
      if (_this96.options.keepAttributes) {
        return chain().toggleList(_this96.name, _this96.options.itemTypeName, _this96.options.keepMarks).updateAttributes(ListItem.name, _this96.editor.getAttributes(TextStyle$1.name)).run();
      }
      return commands2.toggleList(_this96.name, _this96.options.itemTypeName, _this96.options.keepMarks);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts14() {
  var _this97 = this;
  return { "Mod-Shift-7": function ModShift7() {
    return _this97.editor.commands.toggleOrderedList();
  } };
}, addInputRules: function addInputRules9() {
  var _this98 = this;
  var inputRule = wrappingInputRule({ find: inputRegex$4, type: this.type, getAttributes: function getAttributes(match) {
    return { start: +match[1] };
  }, joinPredicate: function joinPredicate(match, node) {
    return node.childCount + node.attrs.start === +match[1];
  } });
  if (this.options.keepMarks || this.options.keepAttributes) {
    inputRule = wrappingInputRule({ find: inputRegex$4, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: function getAttributes(match) {
      return _extends({ start: +match[1] }, _this98.editor.getAttributes(TextStyle$1.name));
    }, joinPredicate: function joinPredicate(match, node) {
      return node.childCount + node.attrs.start === +match[1];
    }, editor: this.editor });
  }
  return [inputRule];
} });
var Paragraph = Node.create({ name: "paragraph", priority: 1e3, addOptions: function addOptions20() {
  return { HTMLAttributes: {} };
}, group: "block", content: "inline*", parseHTML: function parseHTML16() {
  return [{ tag: "p" }];
}, renderHTML: function renderHTML16(_ref156) {
  var HTMLAttributes = _ref156.HTMLAttributes;
  return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands15() {
  var _this99 = this;
  return { setParagraph: function setParagraph() {
    return function(_ref157) {
      var commands2 = _ref157.commands;
      return commands2.setNode(_this99.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts15() {
  var _this100 = this;
  return { "Mod-Alt-0": function ModAlt0() {
    return _this100.editor.commands.setParagraph();
  } };
} });
var inputRegex$3 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
var pasteRegex$1 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
var Strike = Mark.create({ name: "strike", addOptions: function addOptions21() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML17() {
  return [{ tag: "s" }, { tag: "del" }, { tag: "strike" }, { style: "text-decoration", consuming: false, getAttrs: function getAttrs(style2) {
    return style2.includes("line-through") ? {} : false;
  } }];
}, renderHTML: function renderHTML17(_ref158) {
  var HTMLAttributes = _ref158.HTMLAttributes;
  return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands16() {
  var _this101 = this;
  return { setStrike: function setStrike() {
    return function(_ref159) {
      var commands2 = _ref159.commands;
      return commands2.setMark(_this101.name);
    };
  }, toggleStrike: function toggleStrike() {
    return function(_ref160) {
      var commands2 = _ref160.commands;
      return commands2.toggleMark(_this101.name);
    };
  }, unsetStrike: function unsetStrike() {
    return function(_ref161) {
      var commands2 = _ref161.commands;
      return commands2.unsetMark(_this101.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts16() {
  var _this102 = this;
  var shortcuts = {};
  if (isMacOS()) {
    shortcuts["Mod-Shift-s"] = function() {
      return _this102.editor.commands.toggleStrike();
    };
  } else {
    shortcuts["Ctrl-Shift-s"] = function() {
      return _this102.editor.commands.toggleStrike();
    };
  }
  return shortcuts;
}, addInputRules: function addInputRules10() {
  return [markInputRule({ find: inputRegex$3, type: this.type })];
}, addPasteRules: function addPasteRules4() {
  return [markPasteRule({ find: pasteRegex$1, type: this.type })];
} });
var Text$1 = Node.create({ name: "text", group: "inline" });
var StarterKit = Extension.create({ name: "starterKit", addExtensions: function addExtensions() {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  var extensions2 = [];
  if (this.options.blockquote !== false) {
    extensions2.push(Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
  }
  if (this.options.bold !== false) {
    extensions2.push(Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
  }
  if (this.options.bulletList !== false) {
    extensions2.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
  }
  if (this.options.code !== false) {
    extensions2.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
  }
  if (this.options.codeBlock !== false) {
    extensions2.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
  }
  if (this.options.document !== false) {
    extensions2.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
  }
  if (this.options.dropcursor !== false) {
    extensions2.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
  }
  if (this.options.gapcursor !== false) {
    extensions2.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
  }
  if (this.options.hardBreak !== false) {
    extensions2.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
  }
  if (this.options.heading !== false) {
    extensions2.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
  }
  if (this.options.history !== false) {
    extensions2.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
  }
  if (this.options.horizontalRule !== false) {
    extensions2.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
  }
  if (this.options.italic !== false) {
    extensions2.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
  }
  if (this.options.listItem !== false) {
    extensions2.push(ListItem$1.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
  }
  if (this.options.orderedList !== false) {
    extensions2.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
  }
  if (this.options.paragraph !== false) {
    extensions2.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
  }
  if (this.options.strike !== false) {
    extensions2.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
  }
  if (this.options.text !== false) {
    extensions2.push(Text$1.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
  }
  return extensions2;
} });
var inputRegex$2 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = Node.create({ name: "image", addOptions: function addOptions22() {
  return { inline: false, allowBase64: false, HTMLAttributes: {} };
}, inline: function inline() {
  return this.options.inline;
}, group: function group() {
  return this.options.inline ? "inline" : "block";
}, draggable: true, addAttributes: function addAttributes4() {
  return { src: { default: null }, alt: { default: null }, title: { default: null } };
}, parseHTML: function parseHTML18() {
  return [{ tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])' }];
}, renderHTML: function renderHTML18(_ref162) {
  var HTMLAttributes = _ref162.HTMLAttributes;
  return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
}, addCommands: function addCommands17() {
  var _this103 = this;
  return { setImage: function setImage(options) {
    return function(_ref163) {
      var commands2 = _ref163.commands;
      return commands2.insertContent({ type: _this103.name, attrs: options });
    };
  } };
}, addInputRules: function addInputRules11() {
  return [nodeInputRule({ find: inputRegex$2, type: this.type, getAttributes: function getAttributes(match) {
    var alt = match[2], src = match[3], title = match[4];
    return { src, alt, title };
  } })];
} });
var inputRegex$1 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/;
var pasteRegex = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
var Highlight = Mark.create({ name: "highlight", addOptions: function addOptions23() {
  return { multicolor: false, HTMLAttributes: {} };
}, addAttributes: function addAttributes5() {
  if (!this.options.multicolor) {
    return {};
  }
  return { color: { default: null, parseHTML: function parseHTML31(element) {
    return element.getAttribute("data-color") || element.style.backgroundColor;
  }, renderHTML: function renderHTML31(attributes) {
    if (!attributes.color) {
      return {};
    }
    return { "data-color": attributes.color, style: "background-color: " + attributes.color + "; color: inherit" };
  } } };
}, parseHTML: function parseHTML19() {
  return [{ tag: "mark" }];
}, renderHTML: function renderHTML19(_ref164) {
  var HTMLAttributes = _ref164.HTMLAttributes;
  return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands18() {
  var _this104 = this;
  return { setHighlight: function setHighlight(attributes) {
    return function(_ref165) {
      var commands2 = _ref165.commands;
      return commands2.setMark(_this104.name, attributes);
    };
  }, toggleHighlight: function toggleHighlight(attributes) {
    return function(_ref166) {
      var commands2 = _ref166.commands;
      return commands2.toggleMark(_this104.name, attributes);
    };
  }, unsetHighlight: function unsetHighlight() {
    return function(_ref167) {
      var commands2 = _ref167.commands;
      return commands2.unsetMark(_this104.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts17() {
  var _this105 = this;
  return { "Mod-Shift-h": function ModShiftH() {
    return _this105.editor.commands.toggleHighlight();
  } };
}, addInputRules: function addInputRules12() {
  return [markInputRule({ find: inputRegex$1, type: this.type })];
}, addPasteRules: function addPasteRules5() {
  return [markPasteRule({ find: pasteRegex, type: this.type })];
} });
var TextStyle = Mark.create({ name: "textStyle", addOptions: function addOptions24() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML20() {
  return [{ tag: "span", getAttrs: function getAttrs(element) {
    var hasStyles = element.hasAttribute("style");
    if (!hasStyles) {
      return false;
    }
    return {};
  } }];
}, renderHTML: function renderHTML20(_ref168) {
  var HTMLAttributes = _ref168.HTMLAttributes;
  return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands19() {
  var _this106 = this;
  return { removeEmptyTextStyle: function removeEmptyTextStyle() {
    return function(_ref169) {
      var state = _ref169.state, commands2 = _ref169.commands;
      var attributes = getMarkAttributes(state, _this106.type);
      var hasStyles = Object.entries(attributes).some(function(_ref170) {
        var value = _ref170[1];
        return !!value;
      });
      if (hasStyles) {
        return true;
      }
      return commands2.unsetMark(_this106.name);
    };
  } };
} });
var Color = Extension.create({ name: "color", addOptions: function addOptions25() {
  return { types: ["textStyle"] };
}, addGlobalAttributes: function addGlobalAttributes() {
  return [{ types: this.options.types, attributes: { color: { default: null, parseHTML: function parseHTML31(element) {
    var _a;
    return (_a = element.style.color) === null || _a === void 0 ? void 0 : _a.replace(/['"]+/g, "");
  }, renderHTML: function renderHTML31(attributes) {
    if (!attributes.color) {
      return {};
    }
    return { style: "color: " + attributes.color };
  } } } }];
}, addCommands: function addCommands20() {
  return { setColor: function setColor(color) {
    return function(_ref171) {
      var chain = _ref171.chain;
      return chain().setMark("textStyle", { color }).run();
    };
  }, unsetColor: function unsetColor() {
    return function(_ref172) {
      var chain = _ref172.chain;
      return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
    };
  } };
} });
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
var assign = function assign2(target, properties) {
  for (var key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (var k in flags) {
    var group2 = registerGroup(k, groups);
    if (group2.indexOf(t) < 0) {
      group2.push(t);
    }
  }
}
function flagsForToken(t, groups) {
  var result = {};
  for (var _c2 in groups) {
    if (groups[_c2].indexOf(t) >= 0) {
      result[_c2] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  /**
  * Follow an existing transition from the given input to the next state.
  * Does not mutate.
  * @param {string} input character or token type to transition on
  * @returns {?State<T>} the next state, if any
  */
  go: function go(input) {
    var state = this;
    var nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (var _i210 = 0; _i210 < state.jr.length; _i210++) {
      var regex = state.jr[_i210][0];
      var _nextState = state.jr[_i210][1];
      if (_nextState && regex.test(input)) {
        return _nextState;
      }
    }
    return state.jd;
  },
  /**
  * Whether the state has a transition for the given input. Set the second
  * argument to true to only look for an exact match (and not a default or
  * regular-expression-based transition)
  * @param {string} input
  * @param {boolean} exactOnly
  */
  has: function has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
  * Short for "transition all"; create a transition from the array of items
  * in the given list to the same final resulting state.
  * @param {string | string[]} inputs Group of inputs to transition on
  * @param {Transition<T> | State<T>} [next] Transition options
  * @param {Flags} [flags] Collections flags to add token to
  * @param {Collections<T>} [groups] Master list of token groups
  */
  ta: function ta(inputs, next, flags, groups) {
    for (var _i211 = 0; _i211 < inputs.length; _i211++) {
      this.tt(inputs[_i211], next, flags, groups);
    }
  },
  /**
  * Short for "take regexp transition"; defines a transition for this state
  * when it encounters a token which matches the given regular expression
  * @param {RegExp} regexp Regular expression transition (populate first)
  * @param {T | State<T>} [next] Transition options
  * @param {Flags} [flags] Collections flags to add token to
  * @param {Collections<T>} [groups] Master list of token groups
  * @returns {State<T>} taken after the given input
  */
  tr: function tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    var nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
  * Short for "take transitions", will take as many sequential transitions as
  * the length of the given input and returns the
  * resulting final state.
  * @param {string | string[]} input
  * @param {T | State<T>} [next] Transition options
  * @param {Flags} [flags] Collections flags to add token to
  * @param {Collections<T>} [groups] Master list of token groups
  * @returns {State<T>} taken after the given input
  */
  ts: function ts(input, next, flags, groups) {
    var state = this;
    var len = input.length;
    if (!len) {
      return state;
    }
    for (var _i212 = 0; _i212 < len - 1; _i212++) {
      state = state.tt(input[_i212]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
  * Short for "take transition", this is a method for building/working with
  * state machines.
  *
  * If a state already exists for the given input, returns it.
  *
  * If a token is specified, that state will emit that token when reached by
  * the linkify engine.
  *
  * If no state exists, it will be initialized with some default transitions
  * that resemble existing default transitions.
  *
  * If a state is given for the second argument, that state will be
  * transitioned to on the given input regardless of what that input
  * previously did.
  *
  * Specify a token group flags to define groups that this token belongs to.
  * The token will be added to corresponding entires in the given groups
  * object.
  *
  * @param {string} input character, token type to transition on
  * @param {T | State<T>} [next] Transition options
  * @param {Flags} [flags] Collections flags to add token to
  * @param {Collections<T>} [groups] Master list of groups
  * @returns {State<T>} taken after the given input
  */
  tt: function tt(input, next, flags, groups) {
    groups = groups || State.groups;
    var state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    var t = next;
    var nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          var allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t, allFlags, groups);
        } else if (flags) {
          addToGroups(t, flags, groups);
        }
      }
      nextState.t = t;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta2 = function ta3(state, input, next, flags, groups) {
  return state.ta(input, next, flags, groups);
};
var tr2 = function tr3(state, regexp, next, flags, groups) {
  return state.tr(regexp, next, flags, groups);
};
var ts2 = function ts3(state, input, next, flags, groups) {
  return state.ts(input, next, flags, groups);
};
var tt2 = function tt3(state, input, next, flags, groups) {
  return state.tt(input, next, flags, groups);
};
var WORD = "WORD";
var UWORD = "UWORD";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL$1 = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({ __proto__: null, WORD, UWORD, LOCALHOST, TLD, UTLD, SCHEME, SLASH_SCHEME, NUM, WS, NL: NL$1, OPENBRACE, CLOSEBRACE, OPENBRACKET, CLOSEBRACKET, OPENPAREN, CLOSEPAREN, OPENANGLEBRACKET, CLOSEANGLEBRACKET, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN, AMPERSAND, APOSTROPHE, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, COLON, COMMA, DOLLAR, DOT, EQUALS, EXCLAMATION, HYPHEN, PERCENT, PIPE, PLUS, POUND, QUERY, QUOTE, SEMI, SLASH, TILDE, UNDERSCORE, EMOJI: EMOJI$1, SYM });
var ASCII_LETTER = /[a-z]/;
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])/;
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDC-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8])/;
var DIGIT = /\d/;
var SPACE = /\s/;
var NL = "\n";
var EMOJI_VARIATION = "️";
var EMOJI_JOINER = "‍";
var tlds = null, utlds = null;
function init$2(customSchemes) {
  var _tr14, _tr15, _tr16, _tr17, _tt, _tr18;
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  var groups = {};
  State.groups = groups;
  var Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt2(Start, "'", APOSTROPHE);
  tt2(Start, "{", OPENBRACE);
  tt2(Start, "}", CLOSEBRACE);
  tt2(Start, "[", OPENBRACKET);
  tt2(Start, "]", CLOSEBRACKET);
  tt2(Start, "(", OPENPAREN);
  tt2(Start, ")", CLOSEPAREN);
  tt2(Start, "<", OPENANGLEBRACKET);
  tt2(Start, ">", CLOSEANGLEBRACKET);
  tt2(Start, "（", FULLWIDTHLEFTPAREN);
  tt2(Start, "）", FULLWIDTHRIGHTPAREN);
  tt2(Start, "「", LEFTCORNERBRACKET);
  tt2(Start, "」", RIGHTCORNERBRACKET);
  tt2(Start, "『", LEFTWHITECORNERBRACKET);
  tt2(Start, "』", RIGHTWHITECORNERBRACKET);
  tt2(Start, "＜", FULLWIDTHLESSTHAN);
  tt2(Start, "＞", FULLWIDTHGREATERTHAN);
  tt2(Start, "&", AMPERSAND);
  tt2(Start, "*", ASTERISK);
  tt2(Start, "@", AT);
  tt2(Start, "`", BACKTICK);
  tt2(Start, "^", CARET);
  tt2(Start, ":", COLON);
  tt2(Start, ",", COMMA);
  tt2(Start, "$", DOLLAR);
  tt2(Start, ".", DOT);
  tt2(Start, "=", EQUALS);
  tt2(Start, "!", EXCLAMATION);
  tt2(Start, "-", HYPHEN);
  tt2(Start, "%", PERCENT);
  tt2(Start, "|", PIPE);
  tt2(Start, "+", PLUS);
  tt2(Start, "#", POUND);
  tt2(Start, "?", QUERY);
  tt2(Start, '"', QUOTE);
  tt2(Start, "/", SLASH);
  tt2(Start, ";", SEMI);
  tt2(Start, "~", TILDE);
  tt2(Start, "_", UNDERSCORE);
  tt2(Start, "\\", BACKSLASH);
  var Num = tr2(Start, DIGIT, NUM, (_tr14 = {}, _tr14[numeric] = true, _tr14));
  tr2(Num, DIGIT, Num);
  var Word = tr2(Start, ASCII_LETTER, WORD, (_tr15 = {}, _tr15[ascii] = true, _tr15));
  tr2(Word, ASCII_LETTER, Word);
  var UWord = tr2(Start, LETTER, UWORD, (_tr16 = {}, _tr16[alpha] = true, _tr16));
  tr2(UWord, ASCII_LETTER);
  tr2(UWord, LETTER, UWord);
  var Ws = tr2(Start, SPACE, WS, (_tr17 = {}, _tr17[whitespace] = true, _tr17));
  tt2(Start, NL, NL$1, (_tt = {}, _tt[whitespace] = true, _tt));
  tt2(Ws, NL);
  tr2(Ws, SPACE, Ws);
  var Emoji = tr2(Start, EMOJI, EMOJI$1, (_tr18 = {}, _tr18[emoji] = true, _tr18));
  tr2(Emoji, EMOJI, Emoji);
  tt2(Emoji, EMOJI_VARIATION, Emoji);
  var EmojiJoiner = tt2(Emoji, EMOJI_JOINER);
  tr2(EmojiJoiner, EMOJI, Emoji);
  var wordjr = [[ASCII_LETTER, Word]];
  var uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (var _i213 = 0; _i213 < tlds.length; _i213++) {
    fastts(Start, tlds[_i213], TLD, WORD, wordjr);
  }
  for (var _i214 = 0; _i214 < utlds.length; _i214++) {
    fastts(Start, utlds[_i214], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, { tld: true, ascii: true }, groups);
  addToGroups(UTLD, { utld: true, alpha: true }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, { scheme: true, ascii: true }, groups);
  addToGroups(SLASH_SCHEME, { slashscheme: true, ascii: true }, groups);
  customSchemes = customSchemes.sort(function(a, b) {
    return a[0] > b[0] ? 1 : -1;
  });
  for (var _i215 = 0; _i215 < customSchemes.length; _i215++) {
    var _ref173, _ref174;
    var sch = customSchemes[_i215][0];
    var optionalSlashSlash = customSchemes[_i215][1];
    var flags = optionalSlashSlash ? (_ref173 = {}, _ref173[scheme] = true, _ref173) : (_ref174 = {}, _ref174[slashscheme] = true, _ref174);
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts2(Start, sch, sch, flags);
  }
  ts2(Start, "localhost", LOCALHOST, { ascii: true });
  Start.jd = new State(SYM);
  return { start: Start, tokens: assign({ groups }, tk) };
}
function run$1(start2, str) {
  var iterable = stringToArray(str.replace(/[A-Z]/g, function(c2) {
    return c2.toLowerCase();
  }));
  var charCount = iterable.length;
  var tokens = [];
  var cursor = 0;
  var charCursor = 0;
  while (charCursor < charCount) {
    var state = start2;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  var result = [];
  var len = str.length;
  var index = 0;
  while (index < len) {
    var _first7 = str.charCodeAt(index);
    var second = void 0;
    var char = _first7 < 55296 || _first7 > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t, defaultt, jr) {
  var next;
  var len = input.length;
  for (var _i216 = 0; _i216 < len - 1; _i216++) {
    var char = input[_i216];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  var words = [];
  var stack = [];
  var i = 0;
  var digits = "0123456789";
  while (i < encoded.length) {
    var popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (var popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = { defaultProtocol: "http", events: null, format: noop, formatHref: noop, nl2br: false, tagName: "a", target: null, rel: null, validate: true, truncate: Infinity, className: null, attributes: null, ignoreTags: [], render: null };
function Options(opts, defaultRender2) {
  if (defaultRender2 === void 0) {
    defaultRender2 = null;
  }
  var o = assign({}, defaults);
  if (opts) {
    o = assign(o, opts instanceof Options ? opts.o : opts);
  }
  var ignoredTags = o.ignoreTags;
  var uppercaseIgnoredTags = [];
  for (var _i217 = 0; _i217 < ignoredTags.length; _i217++) {
    uppercaseIgnoredTags.push(ignoredTags[_i217].toUpperCase());
  }
  this.o = o;
  if (defaultRender2) {
    this.defaultRender = defaultRender2;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
  * @type string[]
  */
  ignoreTags: [],
  /**
  * @param {IntermediateRepresentation} ir
  * @returns {any}
  */
  defaultRender: function defaultRender(ir) {
    return ir;
  },
  /**
  * Returns true or false based on whether a token should be displayed as a
  * link based on the user options.
  * @param {MultiToken} token
  * @returns {boolean}
  */
  check: function check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
     * Resolve an option's value based on the value of the option and the given
     * params. If operator and token are specified and the target option is
     * callable, automatically calls the function with the given argument.
     * @template {keyof Opts} K
     * @param {K} key Name of option to use
     * @param {string} [operator] will be passed to the target option if it's a
     * function. If not specified, RAW function value gets returned
     * @param {MultiToken} [token] The token from linkify.tokenize
     * @returns {Opts[K] | any}
     */
  get: function get4(key, operator2, token) {
    var isCallable = operator2 != null;
    var option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator2, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator2, token.t, token);
    }
    return option;
  },
  /**
  * @template {keyof Opts} L
  * @param {L} key Name of options object to use
  * @param {string} [operator]
  * @param {MultiToken} [token]
  * @returns {Opts[L] | any}
  */
  getObj: function getObj(key, operator2, token) {
    var obj = this.o[key];
    if (typeof obj === "function" && operator2 != null) {
      obj = obj(operator2, token.t, token);
    }
    return obj;
  },
  /**
  * Convert the given token to a rendered element that may be added to the
  * calling-interface's DOM
  * @param {MultiToken} token Token to render to an HTML element
  * @returns {any} Render result; e.g., HTML string, DOM element, React
  *   Component, etc.
  */
  render: function render5(token) {
    var ir = token.render(this);
    var renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
  * Return the string this token represents.
  * @return {string}
  */
  toString: function toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref: function toHref(scheme2) {
    return this.toString();
  },
  /**
  * @param {Options} options Formatting options
  * @returns {string}
  */
  toFormattedString: function toFormattedString(options) {
    var val = this.toString();
    var truncate = options.get("truncate", val, this);
    var formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
  },
  /**
  *
  * @param {Options} options
  * @returns {string}
  */
  toFormattedHref: function toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
  * The start index of this token in the original input string
  * @returns {number}
  */
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  /**
  * The end index of this token in the original input string (up to this
  * index but not including it)
  * @returns {number}
  */
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject: function toObject2(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return { type: this.t, value: this.toString(), isLink: this.isLink, href: this.toHref(protocol), start: this.startIndex(), end: this.endIndex() };
  },
  /**
  *
  * @param {Options} options Formatting option
  */
  toFormattedObject: function toFormattedObject(options) {
    return { type: this.t, value: this.toFormattedString(options), isLink: this.isLink, href: this.toFormattedHref(options), start: this.startIndex(), end: this.endIndex() };
  },
  /**
  * Whether this token should be rendered as a link according to the given options
  * @param {Options} options
  * @returns {boolean}
  */
  validate: function validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
  * Return an object that represents how this link should be rendered.
  * @param {Options} options Formattinng options
  */
  render: function render6(options) {
    var token = this;
    var href = this.toHref(options.get("defaultProtocol"));
    var formattedHref = options.get("formatHref", href, this);
    var tagName = options.get("tagName", href, token);
    var content5 = this.toFormattedString(options);
    var attributes = {};
    var className = options.get("className", href, token);
    var target = options.get("target", href, token);
    var rel = options.get("rel", href, token);
    var attrs = options.getObj("attributes", href, token);
    var eventListeners2 = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return { tagName, attributes, content: content5, eventListeners: eventListeners2 };
  }
};
function createTokenClass(type, props) {
  var Token = /* @__PURE__ */ function(_MultiToken) {
    _inheritsLoose(Token2, _MultiToken);
    function Token2(value, tokens) {
      var _this107;
      _this107 = _MultiToken.call(this, value, tokens) || this;
      _this107.t = type;
      return _this107;
    }
    return Token2;
  }(MultiToken);
  for (var p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", { isLink: true, toHref: function toHref2() {
  return "mailto:" + this.toString();
} });
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref: function toHref3(scheme2) {
    if (scheme2 === void 0) {
      scheme2 = defaults.defaultProtocol;
    }
    return this.hasProtocol() ? this.v : scheme2 + "://" + this.v;
  },
  /**
  * Check whether this URL token has a protocol
  * @return {boolean}
  */
  hasProtocol: function hasProtocol() {
    var tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var makeState = function makeState2(arg) {
  return new State(arg);
};
function init$1(_ref) {
  var groups = _ref.groups;
  var qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  var qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  var Start = makeState();
  var Localpart = tt2(Start, TILDE);
  ta2(Localpart, localpartAccepting, Localpart);
  ta2(Localpart, groups.domain, Localpart);
  var Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta2(Start, groups.domain, Domain);
  ta2(Start, groups.scheme, Scheme);
  ta2(Start, groups.slashscheme, SlashScheme);
  ta2(Domain, localpartAccepting, Localpart);
  ta2(Domain, groups.domain, Domain);
  var LocalpartAt = tt2(Domain, AT);
  tt2(Localpart, AT, LocalpartAt);
  tt2(Scheme, AT, LocalpartAt);
  tt2(SlashScheme, AT, LocalpartAt);
  var LocalpartDot = tt2(Localpart, DOT);
  ta2(LocalpartDot, localpartAccepting, Localpart);
  ta2(LocalpartDot, groups.domain, Localpart);
  var EmailDomain = makeState();
  ta2(LocalpartAt, groups.domain, EmailDomain);
  ta2(EmailDomain, groups.domain, EmailDomain);
  var EmailDomainDot = tt2(EmailDomain, DOT);
  ta2(EmailDomainDot, groups.domain, EmailDomain);
  var Email$1 = makeState(Email);
  ta2(EmailDomainDot, groups.tld, Email$1);
  ta2(EmailDomainDot, groups.utld, Email$1);
  tt2(LocalpartAt, LOCALHOST, Email$1);
  var EmailDomainHyphen = tt2(EmailDomain, HYPHEN);
  ta2(EmailDomainHyphen, groups.domain, EmailDomain);
  ta2(Email$1, groups.domain, EmailDomain);
  tt2(Email$1, DOT, EmailDomainDot);
  tt2(Email$1, HYPHEN, EmailDomainHyphen);
  var EmailColon = tt2(Email$1, COLON);
  ta2(EmailColon, groups.numeric, Email);
  var DomainHyphen = tt2(Domain, HYPHEN);
  var DomainDot = tt2(Domain, DOT);
  ta2(DomainHyphen, groups.domain, Domain);
  ta2(DomainDot, localpartAccepting, Localpart);
  ta2(DomainDot, groups.domain, Domain);
  var DomainDotTld = makeState(Url);
  ta2(DomainDot, groups.tld, DomainDotTld);
  ta2(DomainDot, groups.utld, DomainDotTld);
  ta2(DomainDotTld, groups.domain, Domain);
  ta2(DomainDotTld, localpartAccepting, Localpart);
  tt2(DomainDotTld, DOT, DomainDot);
  tt2(DomainDotTld, HYPHEN, DomainHyphen);
  tt2(DomainDotTld, AT, LocalpartAt);
  var DomainDotTldColon = tt2(DomainDotTld, COLON);
  var DomainDotTldColonPort = makeState(Url);
  ta2(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  var Url$1 = makeState(Url);
  var UrlNonaccept = makeState();
  ta2(Url$1, qsAccepting, Url$1);
  ta2(Url$1, qsNonAccepting, UrlNonaccept);
  ta2(UrlNonaccept, qsAccepting, Url$1);
  ta2(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt2(DomainDotTld, SLASH, Url$1);
  tt2(DomainDotTldColonPort, SLASH, Url$1);
  var SchemeColon = tt2(Scheme, COLON);
  var SlashSchemeColon = tt2(SlashScheme, COLON);
  var SlashSchemeColonSlash = tt2(SlashSchemeColon, SLASH);
  var UriPrefix = tt2(SlashSchemeColonSlash, SLASH);
  ta2(Scheme, groups.domain, Domain);
  tt2(Scheme, DOT, DomainDot);
  tt2(Scheme, HYPHEN, DomainHyphen);
  ta2(SlashScheme, groups.domain, Domain);
  tt2(SlashScheme, DOT, DomainDot);
  tt2(SlashScheme, HYPHEN, DomainHyphen);
  ta2(SchemeColon, groups.domain, Url$1);
  tt2(SchemeColon, SLASH, Url$1);
  ta2(UriPrefix, groups.domain, Url$1);
  ta2(UriPrefix, qsAccepting, Url$1);
  tt2(UriPrefix, SLASH, Url$1);
  var bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (var _i218 = 0; _i218 < bracketPairs.length; _i218++) {
    var _bracketPairs$_i = bracketPairs[_i218], OPEN = _bracketPairs$_i[0], CLOSE = _bracketPairs$_i[1];
    var UrlOpen = tt2(Url$1, OPEN);
    tt2(UrlNonaccept, OPEN, UrlOpen);
    tt2(UrlOpen, CLOSE, Url$1);
    var UrlOpenQ = makeState(Url);
    ta2(UrlOpen, qsAccepting, UrlOpenQ);
    var UrlOpenSyms = makeState();
    ta2(UrlOpen, qsNonAccepting);
    ta2(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta2(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta2(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta2(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt2(UrlOpenQ, CLOSE, Url$1);
    tt2(UrlOpenSyms, CLOSE, Url$1);
  }
  tt2(Start, LOCALHOST, DomainDotTld);
  tt2(Start, NL$1, Nl);
  return { start: Start, tokens: tk };
}
function run(start2, input, tokens) {
  var len = tokens.length;
  var cursor = 0;
  var multis = [];
  var textTokens = [];
  while (cursor < len) {
    var state = start2;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn$2 = typeof console !== "undefined" && console && console.warn || function() {
};
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = { scanner: null, parser: null, tokenQueue: [], pluginQueue: [], customSchemes: [], initialized: false };
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
}
function registerCustomProtocol(scheme2, optionalSlashSlash) {
  if (optionalSlashSlash === void 0) {
    optionalSlashSlash = false;
  }
  if (INIT.initialized) {
    warn$2('linkifyjs: already initialized - will not register custom scheme "' + scheme2 + '" ' + warnAdvice);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error('linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or "-"\n2. Cannot start or end with "-"\n3. "-" cannot repeat');
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init5() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (var _i219 = 0; _i219 < INIT.tokenQueue.length; _i219++) {
    INIT.tokenQueue[_i219][1]({ scanner: INIT.scanner });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (var _i220 = 0; _i220 < INIT.pluginQueue.length; _i220++) {
    INIT.pluginQueue[_i220][1]({ scanner: INIT.scanner, parser: INIT.parser });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init5();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function _find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && typeof type === "object") {
    if (opts) {
      throw Error("linkifyjs: Invalid link type " + type + "; must be a string");
    }
    opts = type;
    type = null;
  }
  var options = new Options(opts);
  var tokens = tokenize(str);
  var filtered = [];
  for (var _i221 = 0; _i221 < tokens.length; _i221++) {
    var token = tokens[_i221];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}
function autolink(options) {
  return new Plugin({ key: new PluginKey("autolink"), appendTransaction: function appendTransaction(transactions, oldState, newState) {
    var docChanges = transactions.some(function(transaction) {
      return transaction.docChanged;
    }) && !oldState.doc.eq(newState.doc);
    var preventAutolink = transactions.some(function(transaction) {
      return transaction.getMeta("preventAutolink");
    });
    if (!docChanges || preventAutolink) {
      return;
    }
    var tr4 = newState.tr;
    var transform = combineTransactionSteps(oldState.doc, [].concat(transactions));
    var changes = getChangedRanges(transform);
    changes.forEach(function(_ref175) {
      var newRange = _ref175.newRange;
      var nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, function(node) {
        return node.isTextblock;
      });
      var textBlock;
      var textBeforeWhitespace;
      if (nodesInChangedRanges.length > 1) {
        textBlock = nodesInChangedRanges[0];
        textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
      } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
        textBlock = nodesInChangedRanges[0];
        textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
      }
      if (textBlock && textBeforeWhitespace) {
        var wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter(function(s) {
          return s !== "";
        });
        if (wordsBeforeWhitespace.length <= 0) {
          return false;
        }
        var lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
        var lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
        if (!lastWordBeforeSpace) {
          return false;
        }
        _find(lastWordBeforeSpace).filter(function(link) {
          return link.isLink;
        }).map(function(link) {
          return _extends({}, link, { from: lastWordAndBlockOffset + link.start + 1, to: lastWordAndBlockOffset + link.end + 1 });
        }).filter(function(link) {
          if (!newState.schema.marks.code) {
            return true;
          }
          return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
        }).filter(function(link) {
          if (options.validate) {
            return options.validate(link.value);
          }
          return true;
        }).forEach(function(link) {
          if (getMarksBetween(link.from, link.to, newState.doc).some(function(item) {
            return item.mark.type === options.type;
          })) {
            return;
          }
          tr4.addMark(link.from, link.to, options.type.create({ href: link.href }));
        });
      }
    });
    if (!tr4.steps.length) {
      return;
    }
    return tr4;
  } });
}
function clickHandler(options) {
  return new Plugin({ key: new PluginKey("handleClickLink"), props: { handleClick: function handleClick2(view, pos, event) {
    var _a, _b;
    if (event.button !== 0) {
      return false;
    }
    var eventTarget = event.target;
    if (eventTarget.nodeName !== "A") {
      return false;
    }
    var attrs = _getAttributes(view.state, options.type.name);
    var link = event.target;
    var href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;
    var target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
    if (link && href) {
      if (view.editable) {
        window.open(href, target);
      }
      return true;
    }
    return false;
  } } });
}
function pasteHandler(options) {
  return new Plugin({ key: new PluginKey("handlePasteLink"), props: { handlePaste: function handlePaste2(view, event, slice2) {
    var _a;
    var state = view.state;
    var selection = state.selection;
    var empty2 = selection.empty;
    if (empty2) {
      return false;
    }
    var textContent = "";
    slice2.content.forEach(function(node) {
      textContent += node.textContent;
    });
    var link = _find(textContent).find(function(item) {
      return item.isLink && item.value === textContent;
    });
    if (!textContent || !link) {
      return false;
    }
    var html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
    var hrefRegex = /href="([^"]*)"/;
    var existingLink = html === null || html === void 0 ? void 0 : html.match(hrefRegex);
    var url = existingLink ? existingLink[1] : link.href;
    options.editor.commands.setMark(options.type, { href: url });
    return true;
  } } });
}
var Link = Mark.create({ name: "link", priority: 1e3, keepOnSplit: false, onCreate: function onCreate2() {
  this.options.protocols.forEach(function(protocol) {
    if (typeof protocol === "string") {
      registerCustomProtocol(protocol);
      return;
    }
    registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
  });
}, onDestroy: function onDestroy2() {
  reset();
}, inclusive: function inclusive() {
  return this.options.autolink;
}, addOptions: function addOptions26() {
  return { openOnClick: true, linkOnPaste: true, autolink: true, protocols: [], HTMLAttributes: { target: "_blank", rel: "noopener noreferrer nofollow", class: null }, validate: void 0 };
}, addAttributes: function addAttributes6() {
  return { href: { default: null }, target: { default: this.options.HTMLAttributes.target }, rel: { default: this.options.HTMLAttributes.rel }, class: { default: this.options.HTMLAttributes.class } };
}, parseHTML: function parseHTML21() {
  return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
}, renderHTML: function renderHTML21(_ref176) {
  var HTMLAttributes = _ref176.HTMLAttributes;
  var _a;
  if ((_a = HTMLAttributes.href) === null || _a === void 0 ? void 0 : _a.startsWith("javascript:")) {
    return ["a", mergeAttributes(this.options.HTMLAttributes, _extends({}, HTMLAttributes, { href: "" })), 0];
  }
  return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands21() {
  var _this108 = this;
  return { setLink: function setLink(attributes) {
    return function(_ref177) {
      var chain = _ref177.chain;
      return chain().setMark(_this108.name, attributes).setMeta("preventAutolink", true).run();
    };
  }, toggleLink: function toggleLink(attributes) {
    return function(_ref178) {
      var chain = _ref178.chain;
      return chain().toggleMark(_this108.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
    };
  }, unsetLink: function unsetLink() {
    return function(_ref179) {
      var chain = _ref179.chain;
      return chain().unsetMark(_this108.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
    };
  } };
}, addPasteRules: function addPasteRules6() {
  var _this109 = this;
  return [markPasteRule({ find: function find2(text) {
    return _find(text).filter(function(link) {
      if (_this109.options.validate) {
        return _this109.options.validate(link.value);
      }
      return true;
    }).filter(function(link) {
      return link.isLink;
    }).map(function(link) {
      return { text: link.value, index: link.start, data: link };
    });
  }, type: this.type, getAttributes: function getAttributes(match, pasteEvent) {
    var _a, _b;
    var html = (_a = pasteEvent === null || pasteEvent === void 0 ? void 0 : pasteEvent.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
    var hrefRegex = /href="([^"]*)"/;
    var existingLink = html === null || html === void 0 ? void 0 : html.match(hrefRegex);
    if (existingLink) {
      return { href: existingLink[1] };
    }
    return { href: (_b = match.data) === null || _b === void 0 ? void 0 : _b.href };
  } })];
}, addProseMirrorPlugins: function addProseMirrorPlugins12() {
  var plugins = [];
  if (this.options.autolink) {
    plugins.push(autolink({ type: this.type, validate: this.options.validate }));
  }
  if (this.options.openOnClick) {
    plugins.push(clickHandler({ type: this.type }));
  }
  if (this.options.linkOnPaste) {
    plugins.push(pasteHandler({ editor: this.editor, type: this.type }));
  }
  return plugins;
} });
var Underline = Mark.create({ name: "underline", addOptions: function addOptions27() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML22() {
  return [{ tag: "u" }, { style: "text-decoration", consuming: false, getAttrs: function getAttrs(style2) {
    return style2.includes("underline") ? {} : false;
  } }];
}, renderHTML: function renderHTML22(_ref180) {
  var HTMLAttributes = _ref180.HTMLAttributes;
  return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands22() {
  var _this110 = this;
  return { setUnderline: function setUnderline() {
    return function(_ref181) {
      var commands2 = _ref181.commands;
      return commands2.setMark(_this110.name);
    };
  }, toggleUnderline: function toggleUnderline() {
    return function(_ref182) {
      var commands2 = _ref182.commands;
      return commands2.toggleMark(_this110.name);
    };
  }, unsetUnderline: function unsetUnderline() {
    return function(_ref183) {
      var commands2 = _ref183.commands;
      return commands2.unsetMark(_this110.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts18() {
  var _this111 = this;
  return { "Mod-u": function ModU() {
    return _this111.editor.commands.toggleUnderline();
  }, "Mod-U": function ModU() {
    return _this111.editor.commands.toggleUnderline();
  } };
} });
var Subscript = Mark.create({ name: "subscript", addOptions: function addOptions28() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML23() {
  return [{ tag: "sub" }, { style: "vertical-align", getAttrs: function getAttrs(value) {
    if (value !== "sub") {
      return false;
    }
    return null;
  } }];
}, renderHTML: function renderHTML23(_ref184) {
  var HTMLAttributes = _ref184.HTMLAttributes;
  return ["sub", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands23() {
  var _this112 = this;
  return { setSubscript: function setSubscript() {
    return function(_ref185) {
      var commands2 = _ref185.commands;
      return commands2.setMark(_this112.name);
    };
  }, toggleSubscript: function toggleSubscript() {
    return function(_ref186) {
      var commands2 = _ref186.commands;
      return commands2.toggleMark(_this112.name);
    };
  }, unsetSubscript: function unsetSubscript() {
    return function(_ref187) {
      var commands2 = _ref187.commands;
      return commands2.unsetMark(_this112.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts19() {
  var _this113 = this;
  return { "Mod-,": function Mod() {
    return _this113.editor.commands.toggleSubscript();
  } };
} });
var Superscript = Mark.create({ name: "superscript", addOptions: function addOptions29() {
  return { HTMLAttributes: {} };
}, parseHTML: function parseHTML24() {
  return [{ tag: "sup" }, { style: "vertical-align", getAttrs: function getAttrs(value) {
    if (value !== "super") {
      return false;
    }
    return null;
  } }];
}, renderHTML: function renderHTML24(_ref188) {
  var HTMLAttributes = _ref188.HTMLAttributes;
  return ["sup", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
}, addCommands: function addCommands24() {
  var _this114 = this;
  return { setSuperscript: function setSuperscript() {
    return function(_ref189) {
      var commands2 = _ref189.commands;
      return commands2.setMark(_this114.name);
    };
  }, toggleSuperscript: function toggleSuperscript() {
    return function(_ref190) {
      var commands2 = _ref190.commands;
      return commands2.toggleMark(_this114.name);
    };
  }, unsetSuperscript: function unsetSuperscript() {
    return function(_ref191) {
      var commands2 = _ref191.commands;
      return commands2.unsetMark(_this114.name);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts20() {
  var _this115 = this;
  return { "Mod-.": function Mod() {
    return _this115.editor.commands.toggleSuperscript();
  } };
} });
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  var cache = /* @__PURE__ */ new WeakMap();
  readFromCache = function readFromCache2(key) {
    return cache.get(key);
  };
  addToCache = function addToCache2(key, value) {
    cache.set(key, value);
    return value;
  };
} else {
  var _cache2 = [];
  var cacheSize = 10;
  var cachePos = 0;
  readFromCache = function readFromCache2(key) {
    for (var _i222 = 0; _i222 < _cache2.length; _i222 += 2)
      if (_cache2[_i222] == key)
        return _cache2[_i222 + 1];
  };
  addToCache = function addToCache2(key, value) {
    if (cachePos == cacheSize)
      cachePos = 0;
    _cache2[cachePos++] = key;
    return _cache2[cachePos++] = value;
  };
}
var TableMap = /* @__PURE__ */ function() {
  function TableMap2(width, height, map3, problems) {
    this.width = width;
    this.height = height;
    this.map = map3;
    this.problems = problems;
  }
  var _proto75 = TableMap2.prototype;
  _proto75.findCell = function findCell(pos) {
    for (var _i223 = 0; _i223 < this.map.length; _i223++) {
      var curPos = this.map[_i223];
      if (curPos != pos)
        continue;
      var _left2 = _i223 % this.width;
      var _top5 = _i223 / this.width | 0;
      var _right = _left2 + 1;
      var _bottom = _top5 + 1;
      for (var j = 1; _right < this.width && this.map[_i223 + j] == curPos; j++) {
        _right++;
      }
      for (var _j4 = 1; _bottom < this.height && this.map[_i223 + this.width * _j4] == curPos; _j4++) {
        _bottom++;
      }
      return { left: _left2, top: _top5, right: _right, bottom: _bottom };
    }
    throw new RangeError("No cell with offset " + pos + " found");
  };
  _proto75.colCount = function colCount(pos) {
    for (var _i224 = 0; _i224 < this.map.length; _i224++) {
      if (this.map[_i224] == pos) {
        return _i224 % this.width;
      }
    }
    throw new RangeError("No cell with offset " + pos + " found");
  };
  _proto75.nextCell = function nextCell2(pos, axis, dir) {
    var _this$findCell = this.findCell(pos), left2 = _this$findCell.left, right2 = _this$findCell.right, top2 = _this$findCell.top, bottom2 = _this$findCell.bottom;
    if (axis == "horiz") {
      if (dir < 0 ? left2 == 0 : right2 == this.width)
        return null;
      return this.map[top2 * this.width + (dir < 0 ? left2 - 1 : right2)];
    } else {
      if (dir < 0 ? top2 == 0 : bottom2 == this.height)
        return null;
      return this.map[left2 + this.width * (dir < 0 ? top2 - 1 : bottom2)];
    }
  };
  _proto75.rectBetween = function rectBetween(a, b) {
    var _this$findCell2 = this.findCell(a), leftA = _this$findCell2.left, rightA = _this$findCell2.right, topA = _this$findCell2.top, bottomA = _this$findCell2.bottom;
    var _this$findCell3 = this.findCell(b), leftB = _this$findCell3.left, rightB = _this$findCell3.right, topB = _this$findCell3.top, bottomB = _this$findCell3.bottom;
    return { left: Math.min(leftA, leftB), top: Math.min(topA, topB), right: Math.max(rightA, rightB), bottom: Math.max(bottomA, bottomB) };
  };
  _proto75.cellsInRect = function cellsInRect(rect) {
    var result = [];
    var seen = {};
    for (var row = rect.top; row < rect.bottom; row++) {
      for (var col = rect.left; col < rect.right; col++) {
        var index = row * this.width + col;
        var pos = this.map[index];
        if (seen[pos])
          continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {
          continue;
        }
        result.push(pos);
      }
    }
    return result;
  };
  _proto75.positionAt = function positionAt(row, col, table) {
    for (var _i225 = 0, rowStart = 0; ; _i225++) {
      var rowEnd = rowStart + table.child(_i225).nodeSize;
      if (_i225 == row) {
        var index = col + row * this.width;
        var rowEndIndex = (row + 1) * this.width;
        while (index < rowEndIndex && this.map[index] < rowStart)
          index++;
        return index == rowEndIndex ? rowEnd - 1 : this.map[index];
      }
      rowStart = rowEnd;
    }
  };
  TableMap2.get = function get5(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  };
  return TableMap2;
}();
function computeMap(table) {
  if (table.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table.type.name);
  var width = findWidth(table), height = table.childCount;
  var map3 = [];
  var mapPos = 0;
  var problems = null;
  var colWidths = [];
  for (var _i226 = 0, e = width * height; _i226 < e; _i226++)
    map3[_i226] = 0;
  for (var row = 0, pos = 0; row < height; row++) {
    var rowNode = table.child(row);
    pos++;
    for (var _i227 = 0; ; _i227++) {
      while (mapPos < map3.length && map3[mapPos] != 0)
        mapPos++;
      if (_i227 == rowNode.childCount)
        break;
      var cellNode = rowNode.child(_i227);
      var _cellNode$attrs = cellNode.attrs, colspan = _cellNode$attrs.colspan, rowspan = _cellNode$attrs.rowspan, colwidth = _cellNode$attrs.colwidth;
      for (var _h2 = 0; _h2 < rowspan; _h2++) {
        if (_h2 + row >= height) {
          (problems || (problems = [])).push({ type: "overlong_rowspan", pos, n: rowspan - _h2 });
          break;
        }
        var _start13 = mapPos + _h2 * width;
        for (var w = 0; w < colspan; w++) {
          if (map3[_start13 + w] == 0)
            map3[_start13 + w] = pos;
          else
            (problems || (problems = [])).push({ type: "collision", row, pos, n: colspan - w });
          var colW = colwidth && colwidth[w];
          if (colW) {
            var widthIndex = (_start13 + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    var expectedPos = (row + 1) * width;
    var missing = 0;
    while (mapPos < expectedPos)
      if (map3[mapPos++] == 0)
        missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    pos++;
  }
  var tableMap = new TableMap(width, height, map3, problems);
  var badWidths = false;
  for (var _i228 = 0; !badWidths && _i228 < colWidths.length; _i228 += 2)
    if (colWidths[_i228] != null && colWidths[_i228 + 1] < height)
      badWidths = true;
  if (badWidths)
    findBadColWidths(tableMap, colWidths, table);
  return tableMap;
}
function findWidth(table) {
  var width = -1;
  var hasRowSpan = false;
  for (var row = 0; row < table.childCount; row++) {
    var rowNode = table.child(row);
    var rowWidth = 0;
    if (hasRowSpan)
      for (var j = 0; j < row; j++) {
        var prevRow = table.child(j);
        for (var _i229 = 0; _i229 < prevRow.childCount; _i229++) {
          var cell = prevRow.child(_i229);
          if (j + cell.attrs.rowspan > row)
            rowWidth += cell.attrs.colspan;
        }
      }
    for (var _i230 = 0; _i230 < rowNode.childCount; _i230++) {
      var _cell = rowNode.child(_i230);
      rowWidth += _cell.attrs.colspan;
      if (_cell.attrs.rowspan > 1)
        hasRowSpan = true;
    }
    if (width == -1)
      width = rowWidth;
    else if (width != rowWidth)
      width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map3, colWidths, table) {
  if (!map3.problems)
    map3.problems = [];
  var seen = {};
  for (var _i231 = 0; _i231 < map3.map.length; _i231++) {
    var pos = map3.map[_i231];
    if (seen[pos])
      continue;
    seen[pos] = true;
    var node = table.nodeAt(pos);
    if (!node) {
      throw new RangeError("No cell with offset " + pos + " found");
    }
    var updated = null;
    var attrs = node.attrs;
    for (var j = 0; j < attrs.colspan; j++) {
      var col = (_i231 + j) % map3.width;
      var colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
    }
    if (updated)
      map3.problems.unshift({ type: "colwidth mismatch", pos, colwidth: updated });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth)
    return attrs.colwidth.slice();
  var result = [];
  for (var _i232 = 0; _i232 < attrs.colspan; _i232++)
    result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  var result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (var name in schema.nodes) {
      var type = schema.nodes[name], role = type.spec.tableRole;
      if (role)
        result[role] = type;
    }
  }
  return result;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround($pos) {
  for (var d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping($pos) {
  for (var d = $pos.depth; d > 0; d--) {
    var role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell")
      return $pos.node(d);
  }
  return null;
}
function isInTable(state) {
  var $head = state.selection.$head;
  for (var d = $head.depth; d > 0; d--)
    if ($head.node(d).type.spec.tableRole == "row")
      return true;
  return false;
}
function selectionCell(state) {
  var sel = state.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  var $cell = cellAround(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError("No cell found around position " + sel.head);
}
function cellNear($pos) {
  for (var after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    var role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos);
  }
  for (var before = $pos.nodeBefore, _pos2 = $pos.pos; before; before = before.lastChild, _pos2--) {
    var _role = before.type.spec.tableRole;
    if (_role == "cell" || _role == "header_cell")
      return $pos.doc.resolve(_pos2 - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  var table = $pos.node(-1);
  var map3 = TableMap.get(table);
  var tableStart = $pos.start(-1);
  var moved = map3.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n) {
  if (n === void 0) {
    n = 1;
  }
  var result = _extends({}, attrs, { colspan: attrs.colspan - n });
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n);
    if (!result.colwidth.some(function(w) {
      return w > 0;
    }))
      result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n) {
  if (n === void 0) {
    n = 1;
  }
  var result = _extends({}, attrs, { colspan: attrs.colspan + n });
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (var _i233 = 0; _i233 < n; _i233++)
      result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map3, table, col) {
  var headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (var row = 0; row < map3.height; row++)
    if (table.nodeAt(map3.map[col + row * map3.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = /* @__PURE__ */ function(_Selection5) {
  _inheritsLoose(_CellSelection, _Selection5);
  function _CellSelection($anchorCell, $headCell) {
    var _this116;
    if ($headCell === void 0) {
      $headCell = $anchorCell;
    }
    var table = $anchorCell.node(-1);
    var map3 = TableMap.get(table);
    var tableStart = $anchorCell.start(-1);
    var rect = map3.rectBetween($anchorCell.pos - tableStart, $headCell.pos - tableStart);
    var doc2 = $anchorCell.node(0);
    var cells = map3.cellsInRect(rect).filter(function(p) {
      return p != $headCell.pos - tableStart;
    });
    cells.unshift($headCell.pos - tableStart);
    var ranges = cells.map(function(pos) {
      var cell = table.nodeAt(pos);
      if (!cell) {
        throw RangeError("No cell with offset " + pos + " found");
      }
      var from2 = tableStart + pos + 1;
      return new SelectionRange(doc2.resolve(from2), doc2.resolve(from2 + cell.content.size));
    });
    _this116 = _Selection5.call(this, ranges[0].$from, ranges[0].$to, ranges) || this;
    _this116.$anchorCell = $anchorCell;
    _this116.$headCell = $headCell;
    return _this116;
  }
  var _proto76 = _CellSelection.prototype;
  _proto76.map = function map3(doc2, mapping) {
    var $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    var $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else
        return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection.between($anchorCell, $headCell);
  };
  _proto76.content = function content5() {
    var table = this.$anchorCell.node(-1);
    var map3 = TableMap.get(table);
    var tableStart = this.$anchorCell.start(-1);
    var rect = map3.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart);
    var seen = {};
    var rows = [];
    for (var row = rect.top; row < rect.bottom; row++) {
      var rowContent = [];
      for (var index = row * map3.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
        var pos = map3.map[index];
        if (seen[pos])
          continue;
        seen[pos] = true;
        var cellRect = map3.findCell(pos);
        var cell = table.nodeAt(pos);
        if (!cell) {
          throw RangeError("No cell with offset " + pos + " found");
        }
        var extraLeft = rect.left - cellRect.left;
        var extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          var attrs = cell.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);
          }
          if (cellRect.left < rect.left) {
            cell = cell.type.createAndFill(attrs);
            if (!cell) {
              throw RangeError("Could not create cell with attrs " + JSON.stringify(attrs));
            }
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          var _attrs = _extends({}, cell.attrs, { rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top) });
          if (cellRect.top < rect.top) {
            cell = cell.type.createAndFill(_attrs);
          } else {
            cell = cell.type.create(_attrs, cell.content);
          }
        }
        rowContent.push(cell);
      }
      rows.push(table.child(row).copy(Fragment.from(rowContent)));
    }
    var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  };
  _proto76.replace = function replace(tr4, content5) {
    if (content5 === void 0) {
      content5 = Slice.empty;
    }
    var mapFrom = tr4.steps.length, ranges = this.ranges;
    for (var _i234 = 0; _i234 < ranges.length; _i234++) {
      var _ranges$_i3 = ranges[_i234], $from = _ranges$_i3.$from, $to = _ranges$_i3.$to, mapping = tr4.mapping.slice(mapFrom);
      tr4.replace(mapping.map($from.pos), mapping.map($to.pos), _i234 ? Slice.empty : content5);
    }
    var sel = Selection.findFrom(tr4.doc.resolve(tr4.mapping.slice(mapFrom).map(this.to)), -1);
    if (sel)
      tr4.setSelection(sel);
  };
  _proto76.replaceWith = function replaceWith(tr4, node) {
    this.replace(tr4, new Slice(Fragment.from(node), 0, 0));
  };
  _proto76.forEachCell = function forEachCell(f) {
    var table = this.$anchorCell.node(-1);
    var map3 = TableMap.get(table);
    var tableStart = this.$anchorCell.start(-1);
    var cells = map3.cellsInRect(map3.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart));
    for (var _i235 = 0; _i235 < cells.length; _i235++) {
      f(table.nodeAt(cells[_i235]), tableStart + cells[_i235]);
    }
  };
  _proto76.isColSelection = function isColSelection() {
    var anchorTop = this.$anchorCell.index(-1);
    var headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0)
      return false;
    var anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    var headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  };
  _CellSelection.colSelection = function colSelection($anchorCell, $headCell) {
    if ($headCell === void 0) {
      $headCell = $anchorCell;
    }
    var table = $anchorCell.node(-1);
    var map3 = TableMap.get(table);
    var tableStart = $anchorCell.start(-1);
    var anchorRect = map3.findCell($anchorCell.pos - tableStart);
    var headRect = map3.findCell($headCell.pos - tableStart);
    var doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc2.resolve(tableStart + map3.map[anchorRect.left]);
      if (headRect.bottom < map3.height)
        $headCell = doc2.resolve(tableStart + map3.map[map3.width * (map3.height - 1) + headRect.right - 1]);
    } else {
      if (headRect.top > 0)
        $headCell = doc2.resolve(tableStart + map3.map[headRect.left]);
      if (anchorRect.bottom < map3.height)
        $anchorCell = doc2.resolve(tableStart + map3.map[map3.width * (map3.height - 1) + anchorRect.right - 1]);
    }
    return new _CellSelection($anchorCell, $headCell);
  };
  _proto76.isRowSelection = function isRowSelection() {
    var table = this.$anchorCell.node(-1);
    var map3 = TableMap.get(table);
    var tableStart = this.$anchorCell.start(-1);
    var anchorLeft = map3.colCount(this.$anchorCell.pos - tableStart);
    var headLeft = map3.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0)
      return false;
    var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    var headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map3.width;
  };
  _proto76.eq = function eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  };
  _CellSelection.rowSelection = function rowSelection($anchorCell, $headCell) {
    if ($headCell === void 0) {
      $headCell = $anchorCell;
    }
    var table = $anchorCell.node(-1);
    var map3 = TableMap.get(table);
    var tableStart = $anchorCell.start(-1);
    var anchorRect = map3.findCell($anchorCell.pos - tableStart);
    var headRect = map3.findCell($headCell.pos - tableStart);
    var doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc2.resolve(tableStart + map3.map[anchorRect.top * map3.width]);
      if (headRect.right < map3.width)
        $headCell = doc2.resolve(tableStart + map3.map[map3.width * (headRect.top + 1) - 1]);
    } else {
      if (headRect.left > 0)
        $headCell = doc2.resolve(tableStart + map3.map[headRect.top * map3.width]);
      if (anchorRect.right < map3.width)
        $anchorCell = doc2.resolve(tableStart + map3.map[map3.width * (anchorRect.top + 1) - 1]);
    }
    return new _CellSelection($anchorCell, $headCell);
  };
  _proto76.toJSON = function toJSON() {
    return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos };
  };
  _CellSelection.fromJSON = function fromJSON(doc2, json2) {
    return new _CellSelection(doc2.resolve(json2.anchor), doc2.resolve(json2.head));
  };
  _CellSelection.create = function create2(doc2, anchorCell, headCell) {
    if (headCell === void 0) {
      headCell = anchorCell;
    }
    return new _CellSelection(doc2.resolve(anchorCell), doc2.resolve(headCell));
  };
  _proto76.getBookmark = function getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  };
  return _CellSelection;
}(Selection);
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = /* @__PURE__ */ function() {
  function _CellBookmark(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  var _proto77 = _CellBookmark.prototype;
  _proto77.map = function map3(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  };
  _proto77.resolve = function resolve2(doc2) {
    var $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else
      return Selection.near($headCell, 1);
  };
  return _CellBookmark;
}();
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection))
    return null;
  var cells = [];
  state.selection.forEachCell(function(node, pos) {
    cells.push(Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" }));
  });
  return DecorationSet.create(state.doc, cells);
}
function isCellBoundarySelection(_ref192) {
  var $from = _ref192.$from, $to = _ref192.$to;
  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)
    return false;
  var afterFrom = $from.pos;
  var beforeTo = $to.pos;
  var depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth))
      break;
  for (var d = $to.depth; d >= 0; d--, beforeTo--)
    if ($to.before(d + 1) > $to.start(d))
      break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells(_ref193) {
  var $from = _ref193.$from, $to = _ref193.$to;
  var fromCellBoundaryNode;
  var toCellBoundaryNode;
  for (var _i236 = $from.depth; _i236 > 0; _i236--) {
    var node = $from.node(_i236);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node;
      break;
    }
  }
  for (var _i237 = $to.depth; _i237 > 0; _i237--) {
    var _node3 = $to.node(_i237);
    if (_node3.type.spec.tableRole === "cell" || _node3.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = _node3;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr4, allowTableNodeSelection) {
  var sel = (tr4 || state).selection;
  var doc2 = (tr4 || state).doc;
  var normalize2;
  var role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc2, sel.from);
    } else if (role == "row") {
      var $cell = doc2.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      var map3 = TableMap.get(sel.node);
      var _start14 = sel.from + 1;
      var lastCell = _start14 + map3.map[map3.width * map3.height - 1];
      normalize2 = CellSelection.create(doc2, _start14 + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection.create(doc2, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
  }
  if (normalize2)
    (tr4 || (tr4 = state.tr)).setSelection(normalize2);
  return tr4;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset2, f) {
  var oldSize = old.childCount, curSize = cur.childCount;
  outer:
    for (var _i238 = 0, j = 0; _i238 < curSize; _i238++) {
      var child = cur.child(_i238);
      for (var scan = j, e = Math.min(oldSize, _i238 + 3); scan < e; scan++) {
        if (old.child(scan) == child) {
          j = scan + 1;
          offset2 += child.nodeSize;
          continue outer;
        }
      }
      f(child, offset2);
      if (j < oldSize && old.child(j).sameMarkup(child))
        changedDescendants(old.child(j), child, offset2 + 1, f);
      else
        child.nodesBetween(0, child.content.size, f, offset2 + 1);
      offset2 += child.nodeSize;
    }
}
function _fixTables(state, oldState) {
  var tr4;
  var check2 = function check3(node, pos) {
    if (node.type.spec.tableRole == "table")
      tr4 = fixTable(state, node, pos, tr4);
  };
  if (!oldState)
    state.doc.descendants(check2);
  else if (oldState.doc != state.doc)
    changedDescendants(oldState.doc, state.doc, 0, check2);
  return tr4;
}
function fixTable(state, table, tablePos, tr4) {
  var map3 = TableMap.get(table);
  if (!map3.problems)
    return tr4;
  if (!tr4)
    tr4 = state.tr;
  var mustAdd = [];
  for (var _i239 = 0; _i239 < map3.height; _i239++)
    mustAdd.push(0);
  for (var _i240 = 0; _i240 < map3.problems.length; _i240++) {
    var prob = map3.problems[_i240];
    if (prob.type == "collision") {
      var cell = table.nodeAt(prob.pos);
      if (!cell)
        continue;
      var attrs = cell.attrs;
      for (var j = 0; j < attrs.rowspan; j++)
        mustAdd[prob.row + j] += prob.n;
      tr4.setNodeMarkup(tr4.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(attrs, attrs.colspan - prob.n, prob.n));
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      var _cell2 = table.nodeAt(prob.pos);
      if (!_cell2)
        continue;
      tr4.setNodeMarkup(tr4.mapping.map(tablePos + 1 + prob.pos), null, _extends({}, _cell2.attrs, { rowspan: _cell2.attrs.rowspan - prob.n }));
    } else if (prob.type == "colwidth mismatch") {
      var _cell3 = table.nodeAt(prob.pos);
      if (!_cell3)
        continue;
      tr4.setNodeMarkup(tr4.mapping.map(tablePos + 1 + prob.pos), null, _extends({}, _cell3.attrs, { colwidth: prob.colwidth }));
    }
  }
  var first3, last;
  for (var _i241 = 0; _i241 < mustAdd.length; _i241++)
    if (mustAdd[_i241]) {
      if (first3 == null)
        first3 = _i241;
      last = _i241;
    }
  for (var _i242 = 0, pos = tablePos + 1; _i242 < map3.height; _i242++) {
    var row = table.child(_i242);
    var _end22 = pos + row.nodeSize;
    var add = mustAdd[_i242];
    if (add > 0) {
      var role = "cell";
      if (row.firstChild) {
        role = row.firstChild.type.spec.tableRole;
      }
      var nodes = [];
      for (var _j5 = 0; _j5 < add; _j5++) {
        var node = tableNodeTypes(state.schema)[role].createAndFill();
        if (node)
          nodes.push(node);
      }
      var side = (_i242 == 0 || first3 == _i242 - 1) && last == _i242 ? pos + 1 : _end22 - 1;
      tr4.insert(tr4.mapping.map(side), nodes);
    }
    pos = _end22;
  }
  return tr4.setMeta(fixTablesKey, { fixTables: true });
}
function pastedCells(slice2) {
  if (!slice2.size)
    return null;
  var content5 = slice2.content, openStart = slice2.openStart, openEnd = slice2.openEnd;
  while (content5.childCount == 1 && (openStart > 0 && openEnd > 0 || content5.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content5 = content5.child(0).content;
  }
  var first3 = content5.child(0);
  var role = first3.type.spec.tableRole;
  var schema = first3.type.schema, rows = [];
  if (role == "row") {
    for (var _i243 = 0; _i243 < content5.childCount; _i243++) {
      var cells = content5.child(_i243).content;
      var _left3 = _i243 ? 0 : Math.max(0, openStart - 1);
      var _right2 = _i243 < content5.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (_left3 || _right2)
        cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, _left3, _right2)).content;
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content5, openStart, openEnd)).content : content5);
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  var widths = [];
  for (var _i244 = 0; _i244 < rows.length; _i244++) {
    var row = rows[_i244];
    for (var j = row.childCount - 1; j >= 0; j--) {
      var _row$child$attrs = row.child(j).attrs, rowspan = _row$child$attrs.rowspan, colspan = _row$child$attrs.colspan;
      for (var _r2 = _i244; _r2 < _i244 + rowspan; _r2++)
        widths[_r2] = (widths[_r2] || 0) + colspan;
    }
  }
  var width = 0;
  for (var _r3 = 0; _r3 < widths.length; _r3++)
    width = Math.max(width, widths[_r3]);
  for (var _r4 = 0; _r4 < widths.length; _r4++) {
    if (_r4 >= rows.length)
      rows.push(Fragment.empty);
    if (widths[_r4] < width) {
      var _empty = tableNodeTypes(schema).cell.createAndFill();
      var cells = [];
      for (var _i245 = widths[_r4]; _i245 < width; _i245++) {
        cells.push(_empty);
      }
      rows[_r4] = rows[_r4].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice2) {
  var node = nodeType.createAndFill();
  var tr4 = new Transform(node).replace(0, node.content.size, slice2);
  return tr4.doc;
}
function clipCells(_ref194, newWidth, newHeight) {
  var width = _ref194.width, height = _ref194.height, rows = _ref194.rows;
  if (width != newWidth) {
    var added = [];
    var newRows = [];
    for (var row = 0; row < rows.length; row++) {
      var _frag = rows[row], cells = [];
      for (var col = added[row] || 0, _i246 = 0; col < newWidth; _i246++) {
        var cell = _frag.child(_i246 % _frag.childCount);
        if (col + cell.attrs.colspan > newWidth)
          cell = cell.type.createChecked(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);
        cells.push(cell);
        col += cell.attrs.colspan;
        for (var j = 1; j < cell.attrs.rowspan; j++)
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    var _newRows = [];
    for (var _row = 0, _i247 = 0; _row < newHeight; _row++, _i247++) {
      var _cells = [], _source = rows[_i247 % height];
      for (var _j6 = 0; _j6 < _source.childCount; _j6++) {
        var _cell4 = _source.child(_j6);
        if (_row + _cell4.attrs.rowspan > newHeight)
          _cell4 = _cell4.type.create(_extends({}, _cell4.attrs, { rowspan: Math.max(1, newHeight - _cell4.attrs.rowspan) }), _cell4.content);
        _cells.push(_cell4);
      }
      _newRows.push(Fragment.from(_cells));
    }
    rows = _newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr4, map3, table, start2, width, height, mapFrom) {
  var schema = tr4.doc.type.schema;
  var types = tableNodeTypes(schema);
  var empty2;
  var emptyHead;
  if (width > map3.width) {
    for (var row = 0, rowEnd = 0; row < map3.height; row++) {
      var rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      var cells = [];
      var add = void 0;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
        add = empty2 || (empty2 = types.cell.createAndFill());
      else
        add = emptyHead || (emptyHead = types.header_cell.createAndFill());
      for (var _i248 = map3.width; _i248 < width; _i248++)
        cells.push(add);
      tr4.insert(tr4.mapping.slice(mapFrom).map(rowEnd - 1 + start2), cells);
    }
  }
  if (height > map3.height) {
    var _cells2 = [];
    for (var _i249 = 0, start22 = (map3.height - 1) * map3.width; _i249 < Math.max(map3.width, width); _i249++) {
      var header = _i249 >= map3.width ? false : table.nodeAt(map3.map[start22 + _i249]).type == types.header_cell;
      _cells2.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill()));
    }
    var emptyRow = types.row.create(null, Fragment.from(_cells2)), rows = [];
    for (var _i250 = map3.height; _i250 < height; _i250++)
      rows.push(emptyRow);
    tr4.insert(tr4.mapping.slice(mapFrom).map(start2 + table.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr4, map3, table, start2, left2, right2, top2, mapFrom) {
  if (top2 == 0 || top2 == map3.height)
    return false;
  var found2 = false;
  for (var col = left2; col < right2; col++) {
    var index = top2 * map3.width + col, pos = map3.map[index];
    if (map3.map[index - map3.width] == pos) {
      found2 = true;
      var cell = table.nodeAt(pos);
      var _map$findCell = map3.findCell(pos), cellTop = _map$findCell.top, cellLeft = _map$findCell.left;
      tr4.setNodeMarkup(tr4.mapping.slice(mapFrom).map(pos + start2), null, _extends({}, cell.attrs, { rowspan: top2 - cellTop }));
      tr4.insert(tr4.mapping.slice(mapFrom).map(map3.positionAt(top2, cellLeft, table)), cell.type.createAndFill(_extends({}, cell.attrs, { rowspan: cellTop + cell.attrs.rowspan - top2 })));
      col += cell.attrs.colspan - 1;
    }
  }
  return found2;
}
function isolateVertical(tr4, map3, table, start2, top2, bottom2, left2, mapFrom) {
  if (left2 == 0 || left2 == map3.width)
    return false;
  var found2 = false;
  for (var row = top2; row < bottom2; row++) {
    var index = row * map3.width + left2, pos = map3.map[index];
    if (map3.map[index - 1] == pos) {
      found2 = true;
      var cell = table.nodeAt(pos);
      var cellLeft = map3.colCount(pos);
      var updatePos = tr4.mapping.slice(mapFrom).map(pos + start2);
      tr4.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left2 - cellLeft, cell.attrs.colspan - (left2 - cellLeft)));
      tr4.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left2 - cellLeft)));
      row += cell.attrs.rowspan - 1;
    }
  }
  return found2;
}
function insertCells(state, dispatch, tableStart, rect, cells) {
  var table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
  if (!table) {
    throw new Error("No table found");
  }
  var map3 = TableMap.get(table);
  var top2 = rect.top, left2 = rect.left;
  var right2 = left2 + cells.width, bottom2 = top2 + cells.height;
  var tr4 = state.tr;
  var mapFrom = 0;
  function recomp() {
    table = tableStart ? tr4.doc.nodeAt(tableStart - 1) : tr4.doc;
    if (!table) {
      throw new Error("No table found");
    }
    map3 = TableMap.get(table);
    mapFrom = tr4.mapping.maps.length;
  }
  if (growTable(tr4, map3, table, tableStart, right2, bottom2, mapFrom))
    recomp();
  if (isolateHorizontal(tr4, map3, table, tableStart, left2, right2, top2, mapFrom))
    recomp();
  if (isolateHorizontal(tr4, map3, table, tableStart, left2, right2, bottom2, mapFrom))
    recomp();
  if (isolateVertical(tr4, map3, table, tableStart, top2, bottom2, left2, mapFrom))
    recomp();
  if (isolateVertical(tr4, map3, table, tableStart, top2, bottom2, right2, mapFrom))
    recomp();
  for (var row = top2; row < bottom2; row++) {
    var _from19 = map3.positionAt(row, left2, table), to = map3.positionAt(row, right2, table);
    tr4.replace(tr4.mapping.slice(mapFrom).map(_from19 + tableStart), tr4.mapping.slice(mapFrom).map(to + tableStart), new Slice(cells.rows[row - top2], 0, 0));
  }
  recomp();
  tr4.setSelection(new CellSelection(tr4.doc.resolve(tableStart + map3.positionAt(top2, left2, table)), tr4.doc.resolve(tableStart + map3.positionAt(bottom2 - 1, right2 - 1, table))));
  dispatch(tr4);
}
var handleKeyDown = keydownHandler({ ArrowLeft: arrow("horiz", -1), ArrowRight: arrow("horiz", 1), ArrowUp: arrow("vert", -1), ArrowDown: arrow("vert", 1), "Shift-ArrowLeft": shiftArrow("horiz", -1), "Shift-ArrowRight": shiftArrow("horiz", 1), "Shift-ArrowUp": shiftArrow("vert", -1), "Shift-ArrowDown": shiftArrow("vert", 1), Backspace: deleteCellSelection, "Mod-Backspace": deleteCellSelection, Delete: deleteCellSelection, "Mod-Delete": deleteCellSelection });
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow(axis, dir) {
  return function(state, dispatch, view) {
    if (!view)
      return false;
    var sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir));
    }
    if (axis != "horiz" && !sel.empty)
      return false;
    var end2 = atEndOfCell(view, axis, dir);
    if (end2 == null)
      return false;
    if (axis == "horiz") {
      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir));
    } else {
      var $cell = state.doc.resolve(end2);
      var $next = nextCell($cell, axis, dir);
      var newSel;
      if ($next)
        newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      else
        newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return function(state, dispatch, view) {
    if (!view)
      return false;
    var sel = state.selection;
    var cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      var _end23 = atEndOfCell(view, axis, dir);
      if (_end23 == null)
        return false;
      cellSel = new CellSelection(state.doc.resolve(_end23));
    }
    var $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head)
      return false;
    return maybeSetSelection(state, dispatch, new CellSelection(cellSel.$anchorCell, $head));
  };
}
function deleteCellSelection(state, dispatch) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection))
    return false;
  if (dispatch) {
    var _tr19 = state.tr;
    var baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell(function(cell, pos) {
      if (!cell.content.eq(baseContent))
        _tr19.replace(_tr19.mapping.map(pos + 1), _tr19.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));
    });
    if (_tr19.docChanged)
      dispatch(_tr19);
  }
  return true;
}
function handleTripleClick(view, pos) {
  var doc2 = view.state.doc, $cell = cellAround(doc2.resolve(pos));
  if (!$cell)
    return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _, slice2) {
  if (!isInTable(view.state))
    return false;
  var cells = pastedCells(slice2);
  var sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells)
      cells = { width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice2))] };
    var table = sel.$anchorCell.node(-1);
    var _start15 = sel.$anchorCell.start(-1);
    var rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - _start15, sel.$headCell.pos - _start15);
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, _start15, rect, cells);
    return true;
  } else if (cells) {
    var $cell = selectionCell(view.state);
    var _start16 = $cell.start(-1);
    insertCells(view.state, view.dispatch, _start16, TableMap.get($cell.node(-1)).findCell($cell.pos - _start16), cells);
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a;
  if (startEvent.ctrlKey || startEvent.metaKey)
    return;
  var startDOMCell = domInCell(view, startEvent.target);
  var $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    var $head = cellUnderMouse(view, event);
    var starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting)
        $head = $anchor2;
      else
        return;
    }
    var selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      var _tr20 = view.state.tr.setSelection(selection);
      if (starting)
        _tr20.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(_tr20);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move(_event) {
    var event = _event;
    var anchor = tableEditingKey.getState(view.state);
    var $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2)
        return stop();
    }
    if ($anchor2)
      setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return null;
  var $head = view.state.selection.$head;
  for (var d = $head.depth - 1; d >= 0; d--) {
    var parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index != (dir < 0 ? 0 : parent.childCount))
      return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      var cellPos = $head.before(d);
      var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  var mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!mousePos)
    return null;
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var TableView$1 = /* @__PURE__ */ function() {
  function TableView2(node, cellMinWidth) {
    this.node = node;
    this.cellMinWidth = cellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  var _proto78 = TableView2.prototype;
  _proto78.update = function update2(node) {
    if (node.type != this.node.type)
      return false;
    this.node = node;
    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);
    return true;
  };
  _proto78.ignoreMutation = function ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  };
  return TableView2;
}();
function updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  var _a;
  var totalWidth = 0;
  var fixedWidth = true;
  var nextDOM = colgroup.firstChild;
  var row = node.firstChild;
  if (!row)
    return;
  for (var _i251 = 0, col = 0; _i251 < row.childCount; _i251++) {
    var _row$child$attrs2 = row.child(_i251).attrs, colspan = _row$child$attrs2.colspan, colwidth = _row$child$attrs2.colwidth;
    for (var j = 0; j < colspan; j++, col++) {
      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      var cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth)
        fixedWidth = false;
      if (!nextDOM) {
        colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
      } else {
        if (nextDOM.style.width != cssWidth)
          nextDOM.style.width = cssWidth;
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    var after = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
var columnResizingPluginKey = new PluginKey("tableColumnResizing");
function columnResizing(_temp2) {
  var _ref195 = _temp2 === void 0 ? {} : _temp2, _ref195$handleWidth = _ref195.handleWidth, handleWidth = _ref195$handleWidth === void 0 ? 5 : _ref195$handleWidth, _ref195$cellMinWidth = _ref195.cellMinWidth, cellMinWidth = _ref195$cellMinWidth === void 0 ? 25 : _ref195$cellMinWidth, _ref195$View = _ref195.View, View = _ref195$View === void 0 ? TableView$1 : _ref195$View, _ref195$lastColumnRes = _ref195.lastColumnResizable, lastColumnResizable = _ref195$lastColumnRes === void 0 ? true : _ref195$lastColumnRes;
  var plugin = new Plugin({ key: columnResizingPluginKey, state: { init: function init6(_, state) {
    plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = function(node, view) {
      return new View(node, cellMinWidth, view);
    };
    return new ResizeState(-1, false);
  }, apply: function apply6(tr4, prev) {
    return prev.apply(tr4);
  } }, props: { attributes: function attributes(state) {
    var pluginState = columnResizingPluginKey.getState(state);
    return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
  }, handleDOMEvents: { mousemove: function mousemove(view, event) {
    handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);
  }, mouseleave: function mouseleave(view) {
    handleMouseLeave(view);
  }, mousedown: function mousedown(view, event) {
    handleMouseDown2(view, event, cellMinWidth);
  } }, decorations: function decorations(state) {
    var pluginState = columnResizingPluginKey.getState(state);
    if (pluginState && pluginState.activeHandle > -1) {
      return handleDecorations(state, pluginState.activeHandle);
    }
  }, nodeViews: {} } });
  return plugin;
}
var ResizeState = /* @__PURE__ */ function() {
  function _ResizeState(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  var _proto79 = _ResizeState.prototype;
  _proto79.apply = function apply6(tr4) {
    var state = this;
    var action = tr4.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null)
      return new _ResizeState(action.setHandle, false);
    if (action && action.setDragging !== void 0)
      return new _ResizeState(state.activeHandle, action.setDragging);
    if (state.activeHandle > -1 && tr4.docChanged) {
      var handle = tr4.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr4.doc.resolve(handle))) {
        handle = -1;
      }
      return new _ResizeState(handle, state.dragging);
    }
    return state;
  };
  return _ResizeState;
}();
function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
  var pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState)
    return;
  if (!pluginState.dragging) {
    var target = domCellAround(event.target);
    var cell = -1;
    if (target) {
      var _target$getBoundingCl = target.getBoundingClientRect(), _left4 = _target$getBoundingCl.left, _right3 = _target$getBoundingCl.right;
      if (event.clientX - _left4 <= handleWidth)
        cell = edgeCell(view, event, "left", handleWidth);
      else if (_right3 - event.clientX <= handleWidth)
        cell = edgeCell(view, event, "right", handleWidth);
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        var $cell = view.state.doc.resolve(cell);
        var table = $cell.node(-1);
        var map3 = TableMap.get(table);
        var tableStart = $cell.start(-1);
        var col = map3.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map3.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  var pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
    updateHandle(view, -1);
}
function handleMouseDown2(view, event, cellMinWidth) {
  var pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
    return false;
  var cell = view.state.doc.nodeAt(pluginState.activeHandle);
  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setDragging: { startX: event.clientX, startWidth: width } }));
  function finish(event2) {
    window.removeEventListener("mouseup", finish);
    window.removeEventListener("mousemove", move);
    var pluginState2 = columnResizingPluginKey.getState(view.state);
    if (pluginState2 == null ? void 0 : pluginState2.dragging) {
      updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));
      view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null }));
    }
  }
  function move(event2) {
    if (!event2.which)
      return finish(event2);
    var pluginState2 = columnResizingPluginKey.getState(view.state);
    if (!pluginState2)
      return;
    if (pluginState2.dragging) {
      var dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
    }
  }
  window.addEventListener("mouseup", finish);
  window.addEventListener("mousemove", move);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, _ref196) {
  var colspan = _ref196.colspan, colwidth = _ref196.colwidth;
  var width = colwidth && colwidth[colwidth.length - 1];
  if (width)
    return width;
  var dom = view.domAtPos(cellPos);
  var node = dom.node.childNodes[dom.offset];
  var domWidth = node.offsetWidth, parts = colspan;
  if (colwidth) {
    for (var _i252 = 0; _i252 < colspan; _i252++)
      if (colwidth[_i252]) {
        domWidth -= colwidth[_i252];
        parts--;
      }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  var offset2 = side == "right" ? -handleWidth : handleWidth;
  var found2 = view.posAtCoords({ left: event.clientX + offset2, top: event.clientY });
  if (!found2)
    return -1;
  var pos = found2.pos;
  var $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell)
    return -1;
  if (side == "right")
    return $cell.pos;
  var map3 = TableMap.get($cell.node(-1)), start2 = $cell.start(-1);
  var index = map3.map.indexOf($cell.pos - start2);
  return index % map3.width == 0 ? -1 : start2 + map3.map[index - 1];
}
function draggedWidth(dragging, event, cellMinWidth) {
  var offset2 = event.clientX - dragging.startX;
  return Math.max(cellMinWidth, dragging.startWidth + offset2);
}
function updateHandle(view, value) {
  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value }));
}
function updateColumnWidth(view, cell, width) {
  var $cell = view.state.doc.resolve(cell);
  var table = $cell.node(-1), map3 = TableMap.get(table), start2 = $cell.start(-1);
  var col = map3.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  var tr4 = view.state.tr;
  for (var row = 0; row < map3.height; row++) {
    var mapIndex = row * map3.width + col;
    if (row && map3.map[mapIndex] == map3.map[mapIndex - map3.width])
      continue;
    var pos = map3.map[mapIndex];
    var attrs = table.nodeAt(pos).attrs;
    var index = attrs.colspan == 1 ? 0 : col - map3.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index] == width)
      continue;
    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index] = width;
    tr4.setNodeMarkup(start2 + pos, null, _extends({}, attrs, { colwidth }));
  }
  if (tr4.docChanged)
    view.dispatch(tr4);
}
function displayColumnWidth(view, cell, width, cellMinWidth) {
  var $cell = view.state.doc.resolve(cell);
  var table = $cell.node(-1), start2 = $cell.start(-1);
  var col = TableMap.get(table).colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  var dom = view.domAtPos($cell.start(-1)).node;
  while (dom && dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  if (!dom)
    return;
  updateColumnsOnResize(table, dom.firstChild, dom, cellMinWidth, col, width);
}
function zeroes(n) {
  return Array(n).fill(0);
}
function handleDecorations(state, cell) {
  var decorations = [];
  var $cell = state.doc.resolve(cell);
  var table = $cell.node(-1);
  if (!table) {
    return DecorationSet.empty;
  }
  var map3 = TableMap.get(table);
  var start2 = $cell.start(-1);
  var col = map3.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan;
  for (var row = 0; row < map3.height; row++) {
    var index = col + row * map3.width - 1;
    if ((col == map3.width || map3.map[index] != map3.map[index + 1]) && (row == 0 || map3.map[index] != map3.map[index - map3.width])) {
      var cellPos = map3.map[index];
      var pos = start2 + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      var dom = document.createElement("div");
      dom.className = "column-resize-handle";
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function selectedRect(state) {
  var sel = state.selection;
  var $pos = selectionCell(state);
  var table = $pos.node(-1);
  var tableStart = $pos.start(-1);
  var map3 = TableMap.get(table);
  var rect = sel instanceof CellSelection ? map3.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart) : map3.findCell($pos.pos - tableStart);
  return _extends({}, rect, { tableStart, map: map3, table });
}
function addColumn(tr4, _ref197, col) {
  var map3 = _ref197.map, tableStart = _ref197.tableStart, table = _ref197.table;
  var refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map3, table, col + refColumn)) {
    refColumn = col == 0 || col == map3.width ? null : 0;
  }
  for (var row = 0; row < map3.height; row++) {
    var index = row * map3.width + col;
    if (col > 0 && col < map3.width && map3.map[index - 1] == map3.map[index]) {
      var pos = map3.map[index];
      var cell = table.nodeAt(pos);
      tr4.setNodeMarkup(tr4.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map3.colCount(pos)));
      row += cell.attrs.rowspan - 1;
    } else {
      var type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map3.map[index + refColumn]).type;
      var _pos3 = map3.positionAt(row, col, table);
      tr4.insert(tr4.mapping.map(tableStart + _pos3), type.createAndFill());
    }
  }
  return tr4;
}
function _addColumnBefore(state, dispatch) {
  if (!isInTable(state))
    return false;
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function _addColumnAfter(state, dispatch) {
  if (!isInTable(state))
    return false;
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr4, _ref198, col) {
  var map3 = _ref198.map, table = _ref198.table, tableStart = _ref198.tableStart;
  var mapStart = tr4.mapping.maps.length;
  for (var row = 0; row < map3.height; ) {
    var index = row * map3.width + col;
    var pos = map3.map[index];
    var cell = table.nodeAt(pos);
    var attrs = cell.attrs;
    if (col > 0 && map3.map[index - 1] == pos || col < map3.width - 1 && map3.map[index + 1] == pos) {
      tr4.setNodeMarkup(tr4.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(attrs, col - map3.colCount(pos)));
    } else {
      var _start17 = tr4.mapping.slice(mapStart).map(tableStart + pos);
      tr4.delete(_start17, _start17 + cell.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function _deleteColumn(state, dispatch) {
  if (!isInTable(state))
    return false;
  if (dispatch) {
    var rect = selectedRect(state);
    var _tr21 = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width)
      return false;
    for (var _i253 = rect.right - 1; ; _i253--) {
      removeColumn(_tr21, rect, _i253);
      if (_i253 == rect.left)
        break;
      var table = rect.tableStart ? _tr21.doc.nodeAt(rect.tableStart - 1) : _tr21.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(table);
    }
    dispatch(_tr21);
  }
  return true;
}
function rowIsHeader(map3, table, row) {
  var _a;
  var headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (var col = 0; col < map3.width; col++)
    if (((_a = table.nodeAt(map3.map[col + row * map3.width])) == null ? void 0 : _a.type) != headerCell)
      return false;
  return true;
}
function addRow(tr4, _ref199, row) {
  var map3 = _ref199.map, tableStart = _ref199.tableStart, table = _ref199.table;
  var _a;
  var rowPos = tableStart;
  for (var _i254 = 0; _i254 < row; _i254++)
    rowPos += table.child(_i254).nodeSize;
  var cells = [];
  var refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map3, table, row + refRow))
    refRow = row == 0 || row == map3.height ? null : 0;
  for (var col = 0, index = map3.width * row; col < map3.width; col++, index++) {
    if (row > 0 && row < map3.height && map3.map[index] == map3.map[index - map3.width]) {
      var pos = map3.map[index];
      var attrs = table.nodeAt(pos).attrs;
      tr4.setNodeMarkup(tableStart + pos, null, _extends({}, attrs, { rowspan: attrs.rowspan + 1 }));
      col += attrs.colspan - 1;
    } else {
      var type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map3.map[index + refRow * map3.width])) == null ? void 0 : _a.type;
      var node = type == null ? void 0 : type.createAndFill();
      if (node)
        cells.push(node);
    }
  }
  tr4.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr4;
}
function _addRowBefore(state, dispatch) {
  if (!isInTable(state))
    return false;
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function _addRowAfter(state, dispatch) {
  if (!isInTable(state))
    return false;
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr4, _ref200, row) {
  var map3 = _ref200.map, table = _ref200.table, tableStart = _ref200.tableStart;
  var rowPos = 0;
  for (var _i255 = 0; _i255 < row; _i255++)
    rowPos += table.child(_i255).nodeSize;
  var nextRow = rowPos + table.child(row).nodeSize;
  var mapFrom = tr4.mapping.maps.length;
  tr4.delete(rowPos + tableStart, nextRow + tableStart);
  var seen = /* @__PURE__ */ new Set();
  for (var col = 0, index = row * map3.width; col < map3.width; col++, index++) {
    var pos = map3.map[index];
    if (seen.has(pos))
      continue;
    seen.add(pos);
    if (row > 0 && pos == map3.map[index - map3.width]) {
      var attrs = table.nodeAt(pos).attrs;
      tr4.setNodeMarkup(tr4.mapping.slice(mapFrom).map(pos + tableStart), null, _extends({}, attrs, { rowspan: attrs.rowspan - 1 }));
      col += attrs.colspan - 1;
    } else if (row < map3.height && pos == map3.map[index + map3.width]) {
      var cell = table.nodeAt(pos);
      var _attrs2 = cell.attrs;
      var _copy = cell.type.create(_extends({}, _attrs2, { rowspan: cell.attrs.rowspan - 1 }), cell.content);
      var newPos = map3.positionAt(row + 1, col, table);
      tr4.insert(tr4.mapping.slice(mapFrom).map(tableStart + newPos), _copy);
      col += _attrs2.colspan - 1;
    }
  }
}
function _deleteRow(state, dispatch) {
  if (!isInTable(state))
    return false;
  if (dispatch) {
    var rect = selectedRect(state), _tr22 = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height)
      return false;
    for (var _i256 = rect.bottom - 1; ; _i256--) {
      removeRow(_tr22, rect, _i256);
      if (_i256 == rect.top)
        break;
      var table = rect.tableStart ? _tr22.doc.nodeAt(rect.tableStart - 1) : _tr22.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(_tr22);
  }
  return true;
}
function isEmpty(cell) {
  var c2 = cell.content;
  return c2.childCount == 1 && c2.child(0).isTextblock && c2.child(0).childCount == 0;
}
function cellsOverlapRectangle(_ref201, rect) {
  var width = _ref201.width, height = _ref201.height, map3 = _ref201.map;
  var indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  var indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (var _i257 = rect.top; _i257 < rect.bottom; _i257++) {
    if (rect.left > 0 && map3[indexLeft] == map3[indexLeft - 1] || rect.right < width && map3[indexRight] == map3[indexRight + 1])
      return true;
    indexLeft += width;
    indexRight += width;
  }
  for (var _i258 = rect.left; _i258 < rect.right; _i258++) {
    if (rect.top > 0 && map3[indexTop] == map3[indexTop - width] || rect.bottom < height && map3[indexBottom] == map3[indexBottom + width])
      return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function _mergeCells(state, dispatch) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
    return false;
  var rect = selectedRect(state), map3 = rect.map;
  if (cellsOverlapRectangle(map3, rect))
    return false;
  if (dispatch) {
    var _tr23 = state.tr;
    var seen = {};
    var content5 = Fragment.empty;
    var mergedPos;
    var mergedCell;
    for (var row = rect.top; row < rect.bottom; row++) {
      for (var col = rect.left; col < rect.right; col++) {
        var cellPos = map3.map[row * map3.width + col];
        var cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos] || !cell)
          continue;
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell))
            content5 = content5.append(cell.content);
          var mapped = _tr23.mapping.map(cellPos + rect.tableStart);
          _tr23.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    if (mergedPos == null || mergedCell == null) {
      return true;
    }
    _tr23.setNodeMarkup(mergedPos + rect.tableStart, null, _extends({}, addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan), { rowspan: rect.bottom - rect.top }));
    if (content5.size) {
      var _end24 = mergedPos + 1 + mergedCell.content.size;
      var _start18 = isEmpty(mergedCell) ? mergedPos + 1 : _end24;
      _tr23.replaceWith(_start18 + rect.tableStart, _end24 + rect.tableStart, content5);
    }
    _tr23.setSelection(new CellSelection(_tr23.doc.resolve(mergedPos + rect.tableStart)));
    dispatch(_tr23);
  }
  return true;
}
function _splitCell(state, dispatch) {
  var nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(function(_ref202) {
    var node = _ref202.node;
    return nodeTypes[node.type.spec.tableRole];
  })(state, dispatch);
}
function splitCellWithType(getCellType) {
  return function(state, dispatch) {
    var _a;
    var sel = state.selection;
    var cellNode;
    var cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode)
        return false;
      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos)
        return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) {
      return false;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch) {
      var baseAttrs = cellNode.attrs;
      var attrs = [];
      var colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1)
        baseAttrs = _extends({}, baseAttrs, { rowspan: 1 });
      if (baseAttrs.colspan > 1)
        baseAttrs = _extends({}, baseAttrs, { colspan: 1 });
      var rect = selectedRect(state), _tr24 = state.tr;
      for (var _i259 = 0; _i259 < rect.right - rect.left; _i259++)
        attrs.push(colwidth ? _extends({}, baseAttrs, { colwidth: colwidth && colwidth[_i259] ? [colwidth[_i259]] : null }) : baseAttrs);
      var lastCell;
      for (var row = rect.top; row < rect.bottom; row++) {
        var pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top)
          pos += cellNode.nodeSize;
        for (var col = rect.left, _i260 = 0; col < rect.right; col++, _i260++) {
          if (col == rect.left && row == rect.top)
            continue;
          _tr24.insert(lastCell = _tr24.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row, col }).createAndFill(attrs[_i260]));
        }
      }
      _tr24.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left }), attrs[0]);
      if (sel instanceof CellSelection)
        _tr24.setSelection(new CellSelection(_tr24.doc.resolve(sel.$anchorCell.pos), lastCell ? _tr24.doc.resolve(lastCell) : void 0));
      dispatch(_tr24);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch) {
    if (!isInTable(state))
      return false;
    var $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value)
      return false;
    if (dispatch) {
      var _extends5;
      var _tr25 = state.tr;
      if (state.selection instanceof CellSelection)
        state.selection.forEachCell(function(node, pos) {
          var _extends4;
          if (node.attrs[name] !== value)
            _tr25.setNodeMarkup(pos, null, _extends({}, node.attrs, (_extends4 = {}, _extends4[name] = value, _extends4)));
        });
      else
        _tr25.setNodeMarkup($cell.pos, null, _extends({}, $cell.nodeAfter.attrs, (_extends5 = {}, _extends5[name] = value, _extends5)));
      dispatch(_tr25);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state))
      return false;
    if (dispatch) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), _tr26 = state.tr;
      var cells = rect.map.cellsInRect(type == "column" ? { left: rect.left, top: 0, right: rect.right, bottom: rect.map.height } : type == "row" ? { left: 0, top: rect.top, right: rect.map.width, bottom: rect.bottom } : rect);
      var nodes = cells.map(function(pos) {
        return rect.table.nodeAt(pos);
      });
      for (var _i261 = 0; _i261 < cells.length; _i261++)
        if (nodes[_i261].type == types.header_cell)
          _tr26.setNodeMarkup(rect.tableStart + cells[_i261], types.cell, nodes[_i261].attrs);
      if (_tr26.steps.length == 0)
        for (var _i262 = 0; _i262 < cells.length; _i262++)
          _tr26.setNodeMarkup(rect.tableStart + cells[_i262], types.header_cell, nodes[_i262].attrs);
      dispatch(_tr26);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  var cellPositions = rect.map.cellsInRect({ left: 0, top: 0, right: type == "row" ? rect.map.width : 1, bottom: type == "column" ? rect.map.height : 1 });
  for (var _i263 = 0; _i263 < cellPositions.length; _i263++) {
    var cell = rect.table.nodeAt(cellPositions[_i263]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic)
    return deprecated_toggleHeader(type);
  return function(state, dispatch) {
    if (!isInTable(state))
      return false;
    if (dispatch) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), _tr27 = state.tr;
      var isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      var isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types);
      var isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      var selectionStartsAt = isHeaderEnabled ? 1 : 0;
      var cellsRect = type == "column" ? { left: 0, top: selectionStartsAt, right: 1, bottom: rect.map.height } : type == "row" ? { left: selectionStartsAt, top: 0, right: rect.map.width, bottom: 1 } : rect;
      var newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach(function(relativeCellPos) {
        var cellPos = relativeCellPos + rect.tableStart;
        var cell = _tr27.doc.nodeAt(cellPos);
        if (cell) {
          _tr27.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(_tr27);
    }
    return true;
  };
}
toggleHeader("row", { useDeprecatedLogic: true });
toggleHeader("column", { useDeprecatedLogic: true });
var _toggleHeaderCell = toggleHeader("cell", { useDeprecatedLogic: true });
function findNextCell($cell, dir) {
  if (dir < 0) {
    var before = $cell.nodeBefore;
    if (before)
      return $cell.pos - before.nodeSize;
    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      var rowNode = $cell.node(-1).child(row);
      var lastChild = rowNode.lastChild;
      if (lastChild) {
        return rowEnd - 1 - lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    var table = $cell.node(-1);
    for (var _row2 = $cell.indexAfter(-1), rowStart = $cell.after(); _row2 < table.childCount; _row2++) {
      var _rowNode = table.child(_row2);
      if (_rowNode.childCount)
        return rowStart + 1;
      rowStart += _rowNode.nodeSize;
    }
  }
  return null;
}
function _goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state))
      return false;
    var cell = findNextCell(selectionCell(state), direction);
    if (cell == null)
      return false;
    if (dispatch) {
      var $cell = state.doc.resolve(cell);
      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());
    }
    return true;
  };
}
function _deleteTable(state, dispatch) {
  var $pos = state.selection.$anchor;
  for (var d = $pos.depth; d > 0; d--) {
    var node = $pos.node(d);
    if (node.type.spec.tableRole == "table") {
      if (dispatch)
        dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());
      return true;
    }
  }
  return false;
}
function tableEditing(_temp3) {
  var _ref203 = _temp3 === void 0 ? {} : _temp3, _ref203$allowTableNod = _ref203.allowTableNodeSelection, allowTableNodeSelection = _ref203$allowTableNod === void 0 ? false : _ref203$allowTableNod;
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: { init: function init6() {
      return null;
    }, apply: function apply6(tr4, cur) {
      var set2 = tr4.getMeta(tableEditingKey);
      if (set2 != null)
        return set2 == -1 ? null : set2;
      if (cur == null || !tr4.docChanged)
        return cur;
      var _tr$mapping$mapResult = tr4.mapping.mapResult(cur), deleted = _tr$mapping$mapResult.deleted, pos = _tr$mapping$mapResult.pos;
      return deleted ? null : pos;
    } },
    props: { decorations: drawCellSelection, handleDOMEvents: { mousedown: handleMouseDown }, createSelectionBetween: function createSelectionBetween(view) {
      return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
    }, handleTripleClick, handleKeyDown, handlePaste },
    appendTransaction: function appendTransaction(_, oldState, state) {
      return normalizeSelection(state, _fixTables(state, oldState), allowTableNodeSelection);
    }
  });
}
function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  var totalWidth = 0;
  var fixedWidth = true;
  var nextDOM = colgroup.firstChild;
  var row = node.firstChild;
  for (var _i264 = 0, col = 0; _i264 < row.childCount; _i264 += 1) {
    var _row$child$attrs3 = row.child(_i264).attrs, colspan = _row$child$attrs3.colspan, colwidth = _row$child$attrs3.colwidth;
    for (var j = 0; j < colspan; j += 1, col += 1) {
      var hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
      var cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      if (!nextDOM) {
        colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
      } else {
        if (nextDOM.style.width !== cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    var after = nextDOM.nextSibling;
    nextDOM.parentNode.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
var TableView = /* @__PURE__ */ function() {
  function TableView2(node, cellMinWidth) {
    this.node = node;
    this.cellMinWidth = cellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumns(node, this.colgroup, this.table, cellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  var _proto80 = TableView2.prototype;
  _proto80.update = function update2(node) {
    if (node.type !== this.node.type) {
      return false;
    }
    this.node = node;
    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
    return true;
  };
  _proto80.ignoreMutation = function ignoreMutation(mutation) {
    return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
  };
  return TableView2;
}();
function createCell(cellType, cellContent) {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
}
function getTableNodeTypes(schema) {
  if (schema.cached.tableNodeTypes) {
    return schema.cached.tableNodeTypes;
  }
  var roles = {};
  Object.keys(schema.nodes).forEach(function(type) {
    var nodeType = schema.nodes[type];
    if (nodeType.spec.tableRole) {
      roles[nodeType.spec.tableRole] = nodeType;
    }
  });
  schema.cached.tableNodeTypes = roles;
  return roles;
}
function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
  var types = getTableNodeTypes(schema);
  var headerCells = [];
  var cells = [];
  for (var index = 0; index < colsCount; index += 1) {
    var cell = createCell(types.cell, cellContent);
    if (cell) {
      cells.push(cell);
    }
    if (withHeaderRow) {
      var headerCell = createCell(types.header_cell, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  var rows = [];
  for (var _index3 = 0; _index3 < rowsCount; _index3 += 1) {
    rows.push(types.row.createChecked(null, withHeaderRow && _index3 === 0 ? headerCells : cells));
  }
  return types.table.createChecked(null, rows);
}
function isCellSelection(value) {
  return value instanceof CellSelection;
}
var deleteTableWhenAllCellsSelected = function deleteTableWhenAllCellsSelected2(_ref204) {
  var editor = _ref204.editor;
  var selection = editor.state.selection;
  if (!isCellSelection(selection)) {
    return false;
  }
  var cellCount = 0;
  var table = findParentNodeClosestToPos(selection.ranges[0].$from, function(node) {
    return node.type.name === "table";
  });
  table === null || table === void 0 ? void 0 : table.node.descendants(function(node) {
    if (node.type.name === "table") {
      return false;
    }
    if (["tableCell", "tableHeader"].includes(node.type.name)) {
      cellCount += 1;
    }
  });
  var allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
var Table = Node.create({
  name: "table",
  // @ts-ignore
  addOptions: function addOptions30() {
    return {
      HTMLAttributes: {},
      resizable: false,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: TableView,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: true,
  group: "block",
  parseHTML: function parseHTML25() {
    return [{ tag: "table" }];
  },
  renderHTML: function renderHTML25(_ref205) {
    var HTMLAttributes = _ref205.HTMLAttributes;
    return ["table", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ["tbody", 0]];
  },
  addCommands: function addCommands25() {
    return { insertTable: function insertTable(_temp4) {
      var _ref206 = _temp4 === void 0 ? {} : _temp4, _ref206$rows = _ref206.rows, rows = _ref206$rows === void 0 ? 3 : _ref206$rows, _ref206$cols = _ref206.cols, cols = _ref206$cols === void 0 ? 3 : _ref206$cols, _ref206$withHeaderRow = _ref206.withHeaderRow, withHeaderRow = _ref206$withHeaderRow === void 0 ? true : _ref206$withHeaderRow;
      return function(_ref207) {
        var tr4 = _ref207.tr, dispatch = _ref207.dispatch, editor = _ref207.editor;
        var node = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch) {
          var _offset11 = tr4.selection.anchor + 1;
          tr4.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr4.doc.resolve(_offset11)));
        }
        return true;
      };
    }, addColumnBefore: function addColumnBefore() {
      return function(_ref208) {
        var state = _ref208.state, dispatch = _ref208.dispatch;
        return _addColumnBefore(state, dispatch);
      };
    }, addColumnAfter: function addColumnAfter() {
      return function(_ref209) {
        var state = _ref209.state, dispatch = _ref209.dispatch;
        return _addColumnAfter(state, dispatch);
      };
    }, deleteColumn: function deleteColumn() {
      return function(_ref210) {
        var state = _ref210.state, dispatch = _ref210.dispatch;
        return _deleteColumn(state, dispatch);
      };
    }, addRowBefore: function addRowBefore() {
      return function(_ref211) {
        var state = _ref211.state, dispatch = _ref211.dispatch;
        return _addRowBefore(state, dispatch);
      };
    }, addRowAfter: function addRowAfter() {
      return function(_ref212) {
        var state = _ref212.state, dispatch = _ref212.dispatch;
        return _addRowAfter(state, dispatch);
      };
    }, deleteRow: function deleteRow() {
      return function(_ref213) {
        var state = _ref213.state, dispatch = _ref213.dispatch;
        return _deleteRow(state, dispatch);
      };
    }, deleteTable: function deleteTable() {
      return function(_ref214) {
        var state = _ref214.state, dispatch = _ref214.dispatch;
        return _deleteTable(state, dispatch);
      };
    }, mergeCells: function mergeCells() {
      return function(_ref215) {
        var state = _ref215.state, dispatch = _ref215.dispatch;
        return _mergeCells(state, dispatch);
      };
    }, splitCell: function splitCell() {
      return function(_ref216) {
        var state = _ref216.state, dispatch = _ref216.dispatch;
        return _splitCell(state, dispatch);
      };
    }, toggleHeaderColumn: function toggleHeaderColumn() {
      return function(_ref217) {
        var state = _ref217.state, dispatch = _ref217.dispatch;
        return toggleHeader("column")(state, dispatch);
      };
    }, toggleHeaderRow: function toggleHeaderRow() {
      return function(_ref218) {
        var state = _ref218.state, dispatch = _ref218.dispatch;
        return toggleHeader("row")(state, dispatch);
      };
    }, toggleHeaderCell: function toggleHeaderCell() {
      return function(_ref219) {
        var state = _ref219.state, dispatch = _ref219.dispatch;
        return _toggleHeaderCell(state, dispatch);
      };
    }, mergeOrSplit: function mergeOrSplit() {
      return function(_ref220) {
        var state = _ref220.state, dispatch = _ref220.dispatch;
        if (_mergeCells(state, dispatch)) {
          return true;
        }
        return _splitCell(state, dispatch);
      };
    }, setCellAttribute: function setCellAttribute(name, value) {
      return function(_ref221) {
        var state = _ref221.state, dispatch = _ref221.dispatch;
        return setCellAttr(name, value)(state, dispatch);
      };
    }, goToNextCell: function goToNextCell() {
      return function(_ref222) {
        var state = _ref222.state, dispatch = _ref222.dispatch;
        return _goToNextCell(1)(state, dispatch);
      };
    }, goToPreviousCell: function goToPreviousCell() {
      return function(_ref223) {
        var state = _ref223.state, dispatch = _ref223.dispatch;
        return _goToNextCell(-1)(state, dispatch);
      };
    }, fixTables: function fixTables() {
      return function(_ref224) {
        var state = _ref224.state, dispatch = _ref224.dispatch;
        if (dispatch) {
          _fixTables(state);
        }
        return true;
      };
    }, setCellSelection: function setCellSelection(position) {
      return function(_ref225) {
        var tr4 = _ref225.tr, dispatch = _ref225.dispatch;
        if (dispatch) {
          var selection = CellSelection.create(tr4.doc, position.anchorCell, position.headCell);
          tr4.setSelection(selection);
        }
        return true;
      };
    } };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts21() {
    var _this117 = this;
    return { Tab: function Tab() {
      if (_this117.editor.commands.goToNextCell()) {
        return true;
      }
      if (!_this117.editor.can().addRowAfter()) {
        return false;
      }
      return _this117.editor.chain().addRowAfter().goToNextCell().run();
    }, "Shift-Tab": function ShiftTab() {
      return _this117.editor.commands.goToPreviousCell();
    }, Backspace: deleteTableWhenAllCellsSelected, "Mod-Backspace": deleteTableWhenAllCellsSelected, Delete: deleteTableWhenAllCellsSelected, "Mod-Delete": deleteTableWhenAllCellsSelected };
  },
  addProseMirrorPlugins: function addProseMirrorPlugins13() {
    var isResizable = this.options.resizable && this.editor.isEditable;
    return [].concat(isResizable ? [columnResizing({
      handleWidth: this.options.handleWidth,
      cellMinWidth: this.options.cellMinWidth,
      // @ts-ignore (incorrect type)
      View: this.options.View,
      // TODO: PR for @types/prosemirror-tables
      // @ts-ignore (incorrect type)
      lastColumnResizable: this.options.lastColumnResizable
    })] : [], [tableEditing({ allowTableNodeSelection: this.options.allowTableNodeSelection })]);
  },
  extendNodeSchema: function extendNodeSchema2(extension) {
    var context = { name: extension.name, options: extension.options, storage: extension.storage };
    return { tableRole: callOrReturn(getExtensionField(extension, "tableRole", context)) };
  }
});
var TableCell = Node.create({ name: "tableCell", addOptions: function addOptions31() {
  return { HTMLAttributes: {} };
}, content: "block+", addAttributes: function addAttributes7() {
  return { colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: function parseHTML31(element) {
    var colwidth = element.getAttribute("colwidth");
    var value = colwidth ? [parseInt(colwidth, 10)] : null;
    return value;
  } } };
}, tableRole: "cell", isolating: true, parseHTML: function parseHTML26() {
  return [{ tag: "td" }];
}, renderHTML: function renderHTML26(_ref226) {
  var HTMLAttributes = _ref226.HTMLAttributes;
  return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
} });
var TableHeader = Node.create({ name: "tableHeader", addOptions: function addOptions32() {
  return { HTMLAttributes: {} };
}, content: "block+", addAttributes: function addAttributes8() {
  return { colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: function parseHTML31(element) {
    var colwidth = element.getAttribute("colwidth");
    var value = colwidth ? [parseInt(colwidth, 10)] : null;
    return value;
  } } };
}, tableRole: "header_cell", isolating: true, parseHTML: function parseHTML27() {
  return [{ tag: "th" }];
}, renderHTML: function renderHTML27(_ref227) {
  var HTMLAttributes = _ref227.HTMLAttributes;
  return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
} });
var TableRow = Node.create({ name: "tableRow", addOptions: function addOptions33() {
  return { HTMLAttributes: {} };
}, content: "(tableCell | tableHeader)*", tableRole: "row", parseHTML: function parseHTML28() {
  return [{ tag: "tr" }];
}, renderHTML: function renderHTML28(_ref228) {
  var HTMLAttributes = _ref228.HTMLAttributes;
  return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
} });
var inputRegex = /^\s*(\[([( |x])?\])\s$/;
var TaskItem = Node.create({ name: "taskItem", addOptions: function addOptions34() {
  return { nested: false, HTMLAttributes: {}, taskListTypeName: "taskList" };
}, content: function content3() {
  return this.options.nested ? "paragraph block*" : "paragraph+";
}, defining: true, addAttributes: function addAttributes9() {
  return { checked: { default: false, keepOnSplit: false, parseHTML: function parseHTML31(element) {
    return element.getAttribute("data-checked") === "true";
  }, renderHTML: function renderHTML31(attributes) {
    return { "data-checked": attributes.checked };
  } } };
}, parseHTML: function parseHTML29() {
  return [{ tag: 'li[data-type="' + this.name + '"]', priority: 51 }];
}, renderHTML: function renderHTML29(_ref229) {
  var node = _ref229.node, HTMLAttributes = _ref229.HTMLAttributes;
  return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), ["label", ["input", { type: "checkbox", checked: node.attrs.checked ? "checked" : null }], ["span"]], ["div", 0]];
}, addKeyboardShortcuts: function addKeyboardShortcuts22() {
  var _this118 = this;
  var shortcuts = { Enter: function Enter() {
    return _this118.editor.commands.splitListItem(_this118.name);
  }, "Shift-Tab": function ShiftTab() {
    return _this118.editor.commands.liftListItem(_this118.name);
  } };
  if (!this.options.nested) {
    return shortcuts;
  }
  return _extends({}, shortcuts, { Tab: function Tab() {
    return _this118.editor.commands.sinkListItem(_this118.name);
  } });
}, addNodeView: function addNodeView() {
  var _this119 = this;
  return function(_ref230) {
    var node = _ref230.node, HTMLAttributes = _ref230.HTMLAttributes, getPos = _ref230.getPos, editor = _ref230.editor;
    var listItem = document.createElement("li");
    var checkboxWrapper = document.createElement("label");
    var checkboxStyler = document.createElement("span");
    var checkbox = document.createElement("input");
    var content5 = document.createElement("div");
    checkboxWrapper.contentEditable = "false";
    checkbox.type = "checkbox";
    checkbox.addEventListener("change", function(event) {
      if (!editor.isEditable && !_this119.options.onReadOnlyChecked) {
        checkbox.checked = !checkbox.checked;
        return;
      }
      var checked = event.target.checked;
      if (editor.isEditable && typeof getPos === "function") {
        editor.chain().focus(void 0, { scrollIntoView: false }).command(function(_ref231) {
          var tr4 = _ref231.tr;
          var position = getPos();
          var currentNode = tr4.doc.nodeAt(position);
          tr4.setNodeMarkup(position, void 0, _extends({}, currentNode === null || currentNode === void 0 ? void 0 : currentNode.attrs, { checked }));
          return true;
        }).run();
      }
      if (!editor.isEditable && _this119.options.onReadOnlyChecked) {
        if (!_this119.options.onReadOnlyChecked(node, checked)) {
          checkbox.checked = !checkbox.checked;
        }
      }
    });
    Object.entries(_this119.options.HTMLAttributes).forEach(function(_ref232) {
      var key = _ref232[0], value = _ref232[1];
      listItem.setAttribute(key, value);
    });
    listItem.dataset.checked = node.attrs.checked;
    if (node.attrs.checked) {
      checkbox.setAttribute("checked", "checked");
    }
    checkboxWrapper.append(checkbox, checkboxStyler);
    listItem.append(checkboxWrapper, content5);
    Object.entries(HTMLAttributes).forEach(function(_ref233) {
      var key = _ref233[0], value = _ref233[1];
      listItem.setAttribute(key, value);
    });
    return { dom: listItem, contentDOM: content5, update: function update2(updatedNode) {
      if (updatedNode.type !== _this119.type) {
        return false;
      }
      listItem.dataset.checked = updatedNode.attrs.checked;
      if (updatedNode.attrs.checked) {
        checkbox.setAttribute("checked", "checked");
      } else {
        checkbox.removeAttribute("checked");
      }
      return true;
    } };
  };
}, addInputRules: function addInputRules13() {
  return [wrappingInputRule({ find: inputRegex, type: this.type, getAttributes: function getAttributes(match) {
    return { checked: match[match.length - 1] === "x" };
  } })];
} });
var TaskList = Node.create({ name: "taskList", addOptions: function addOptions35() {
  return { itemTypeName: "taskItem", HTMLAttributes: {} };
}, group: "block list", content: function content4() {
  return this.options.itemTypeName + "+";
}, parseHTML: function parseHTML30() {
  return [{ tag: 'ul[data-type="' + this.name + '"]', priority: 51 }];
}, renderHTML: function renderHTML30(_ref234) {
  var HTMLAttributes = _ref234.HTMLAttributes;
  return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
}, addCommands: function addCommands26() {
  var _this120 = this;
  return { toggleTaskList: function toggleTaskList() {
    return function(_ref235) {
      var commands2 = _ref235.commands;
      return commands2.toggleList(_this120.name, _this120.options.itemTypeName);
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts23() {
  var _this121 = this;
  return { "Mod-Shift-9": function ModShift9() {
    return _this121.editor.commands.toggleTaskList();
  } };
} });
var TextAlign = Extension.create({ name: "textAlign", addOptions: function addOptions36() {
  return { types: [], alignments: ["left", "center", "right", "justify"], defaultAlignment: "left" };
}, addGlobalAttributes: function addGlobalAttributes2() {
  var _this122 = this;
  return [{ types: this.options.types, attributes: { textAlign: { default: this.options.defaultAlignment, parseHTML: function parseHTML31(element) {
    return element.style.textAlign || _this122.options.defaultAlignment;
  }, renderHTML: function renderHTML31(attributes) {
    if (attributes.textAlign === _this122.options.defaultAlignment) {
      return {};
    }
    return { style: "text-align: " + attributes.textAlign };
  } } } }];
}, addCommands: function addCommands27() {
  var _this123 = this;
  return { setTextAlign: function setTextAlign(alignment) {
    return function(_ref236) {
      var commands2 = _ref236.commands;
      if (!_this123.options.alignments.includes(alignment)) {
        return false;
      }
      return _this123.options.types.every(function(type) {
        return commands2.updateAttributes(type, { textAlign: alignment });
      });
    };
  }, unsetTextAlign: function unsetTextAlign() {
    return function(_ref237) {
      var commands2 = _ref237.commands;
      return _this123.options.types.every(function(type) {
        return commands2.resetAttributes(type, "textAlign");
      });
    };
  } };
}, addKeyboardShortcuts: function addKeyboardShortcuts24() {
  var _this124 = this;
  return { "Mod-Shift-l": function ModShiftL() {
    return _this124.editor.commands.setTextAlign("left");
  }, "Mod-Shift-e": function ModShiftE() {
    return _this124.editor.commands.setTextAlign("center");
  }, "Mod-Shift-r": function ModShiftR() {
    return _this124.editor.commands.setTextAlign("right");
  }, "Mod-Shift-j": function ModShiftJ() {
    return _this124.editor.commands.setTextAlign("justify");
  } };
} });
var deepFreezeEs6 = { exports: {} };
function deepFreeze$1(obj) {
  if (obj instanceof Map) {
    obj.clear = obj.delete = obj.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj instanceof Set) {
    obj.add = obj.clear = obj.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach(function(name) {
    var prop = obj[name];
    if (typeof prop == "object" && !Object.isFrozen(prop)) {
      deepFreeze$1(prop);
    }
  });
  return obj;
}
deepFreezeEs6.exports = deepFreeze$1;
deepFreezeEs6.exports.default = deepFreeze$1;
var Response$1 = /* @__PURE__ */ function() {
  function Response2(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  var _proto81 = Response2.prototype;
  _proto81.ignoreMatch = function ignoreMatch() {
    this.isMatchIgnored = true;
  };
  return Response2;
}();
function escapeHTML$1(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1$1(original) {
  var result = /* @__PURE__ */ Object.create(null);
  for (var key in original) {
    result[key] = original[key];
  }
  for (var _len5 = arguments.length, objects = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    objects[_key5 - 1] = arguments[_key5];
  }
  objects.forEach(function(obj) {
    for (var _key6 in obj) {
      result[_key6] = obj[_key6];
    }
  });
  return (
    /** @type {T} */
    result
  );
}
var SPAN_CLOSE$1 = "</span>";
var emitsWrappingTags$1 = function emitsWrappingTags$12(node) {
  return !!node.scope || node.sublanguage && node.language;
};
var scopeToCSSClass$1 = function scopeToCSSClass$12(name, _ref238) {
  var prefix = _ref238.prefix;
  if (name.includes(".")) {
    var pieces = name.split(".");
    return ["" + prefix + pieces.shift()].concat(pieces.map(function(x, i) {
      return "" + x + "_".repeat(i + 1);
    })).join(" ");
  }
  return "" + prefix + name;
};
var HTMLRenderer$1 = /* @__PURE__ */ function() {
  function HTMLRenderer2(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  var _proto82 = HTMLRenderer2.prototype;
  _proto82.addText = function addText(text) {
    this.buffer += escapeHTML$1(text);
  };
  _proto82.openNode = function openNode(node) {
    if (!emitsWrappingTags$1(node))
      return;
    var className = "";
    if (node.sublanguage) {
      className = "language-" + node.language;
    } else {
      className = scopeToCSSClass$1(node.scope, { prefix: this.classPrefix });
    }
    this.span(className);
  };
  _proto82.closeNode = function closeNode(node) {
    if (!emitsWrappingTags$1(node))
      return;
    this.buffer += SPAN_CLOSE$1;
  };
  _proto82.value = function value() {
    return this.buffer;
  };
  _proto82.span = function span(className) {
    this.buffer += '<span class="' + className + '">';
  };
  return HTMLRenderer2;
}();
var newNode$1 = function newNode$12(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var result = { children: [] };
  Object.assign(result, opts);
  return result;
};
var TokenTree$1 = /* @__PURE__ */ function() {
  function TokenTree2() {
    this.rootNode = newNode$1();
    this.stack = [this.rootNode];
  }
  var _proto83 = TokenTree2.prototype;
  _proto83.add = function add(node) {
    this.top.children.push(node);
  };
  _proto83.openNode = function openNode(scope) {
    var node = newNode$1({ scope });
    this.add(node);
    this.stack.push(node);
  };
  _proto83.closeNode = function closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  };
  _proto83.closeAllNodes = function closeAllNodes() {
    while (this.closeNode())
      ;
  };
  _proto83.toJSON = function toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  };
  _proto83.walk = function walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  };
  TokenTree2._walk = function _walk(builder, node) {
    var _this125 = this;
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach(function(child) {
        return _this125._walk(builder, child);
      });
      builder.closeNode(node);
    }
    return builder;
  };
  TokenTree2._collapse = function _collapse(node) {
    if (typeof node === "string")
      return;
    if (!node.children)
      return;
    if (node.children.every(function(el) {
      return typeof el === "string";
    })) {
      node.children = [node.children.join("")];
    } else {
      node.children.forEach(function(child) {
        TokenTree2._collapse(child);
      });
    }
  };
  _createClass(TokenTree2, [{ key: "top", get: function get5() {
    return this.stack[this.stack.length - 1];
  } }, { key: "root", get: function get5() {
    return this.rootNode;
  } }]);
  return TokenTree2;
}();
var TokenTreeEmitter$1 = /* @__PURE__ */ function(_TokenTree$) {
  _inheritsLoose(TokenTreeEmitter2, _TokenTree$);
  function TokenTreeEmitter2(options) {
    var _this126;
    _this126 = _TokenTree$.call(this) || this;
    _this126.options = options;
    return _this126;
  }
  var _proto84 = TokenTreeEmitter2.prototype;
  _proto84.addKeyword = function addKeyword(text, scope) {
    if (text === "") {
      return;
    }
    this.openNode(scope);
    this.addText(text);
    this.closeNode();
  };
  _proto84.addText = function addText(text) {
    if (text === "") {
      return;
    }
    this.add(text);
  };
  _proto84.addSublanguage = function addSublanguage(emitter, name) {
    var node = emitter.root;
    node.sublanguage = true;
    node.language = name;
    this.add(node);
  };
  _proto84.toHTML = function toHTML() {
    var renderer = new HTMLRenderer$1(this, this.options);
    return renderer.value();
  };
  _proto84.finalize = function finalize() {
    return true;
  };
  return TokenTreeEmitter2;
}(TokenTree$1);
function source$2(re) {
  if (!re)
    return null;
  if (typeof re === "string")
    return re;
  return re.source;
}
function lookahead$2(re) {
  return concat$2("(?=", re, ")");
}
function anyNumberOfTimes$1(re) {
  return concat$2("(?:", re, ")*");
}
function optional$1(re) {
  return concat$2("(?:", re, ")?");
}
function concat$2() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
    args[_key7] = arguments[_key7];
  }
  var joined = args.map(function(x) {
    return source$2(x);
  }).join("");
  return joined;
}
function stripOptionsFromArgs$2(args) {
  var opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either$2() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
    args[_key8] = arguments[_key8];
  }
  var opts = stripOptionsFromArgs$2(args);
  var joined = "(" + (opts.capture ? "" : "?:") + args.map(function(x) {
    return source$2(x);
  }).join("|") + ")";
  return joined;
}
function countMatchGroups$1(re) {
  return new RegExp(re.toString() + "|").exec("").length - 1;
}
function startsWith$1(re, lexeme) {
  var match = re && re.exec(lexeme);
  return match && match.index === 0;
}
var BACKREF_RE$1 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences$1(regexps, _ref239) {
  var joinWith = _ref239.joinWith;
  var numCaptures = 0;
  return regexps.map(function(regex) {
    numCaptures += 1;
    var offset2 = numCaptures;
    var re = source$2(regex);
    var out = "";
    while (re.length > 0) {
      var match = BACKREF_RE$1.exec(re);
      if (!match) {
        out += re;
        break;
      }
      out += re.substring(0, match.index);
      re = re.substring(match.index + match[0].length);
      if (match[0][0] === "\\" && match[1]) {
        out += "\\" + String(Number(match[1]) + offset2);
      } else {
        out += match[0];
        if (match[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map(function(re) {
    return "(" + re + ")";
  }).join(joinWith);
}
var MATCH_NOTHING_RE$1 = /\b\B/;
var IDENT_RE$3 = "[a-zA-Z]\\w*";
var UNDERSCORE_IDENT_RE$1 = "[a-zA-Z_]\\w*";
var NUMBER_RE$1 = "\\b\\d+(\\.\\d+)?";
var C_NUMBER_RE$1 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
var BINARY_NUMBER_RE$1 = "\\b(0b[01]+)";
var RE_STARTERS_RE$1 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
var SHEBANG$1 = function SHEBANG$12(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat$2(beginShebang, /.*\b/, opts.binary, /\b.*/);
  }
  return inherit$1$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": function onBegin(m, resp) {
      if (m.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
var BACKSLASH_ESCAPE$1 = { begin: "\\\\[\\s\\S]", relevance: 0 };
var APOS_STRING_MODE$1 = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [BACKSLASH_ESCAPE$1] };
var QUOTE_STRING_MODE$1 = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [BACKSLASH_ESCAPE$1] };
var PHRASAL_WORDS_MODE$1 = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ };
var COMMENT$1 = function COMMENT$12(begin, end2, modeOptions) {
  if (modeOptions === void 0) {
    modeOptions = {};
  }
  var mode = inherit$1$1({ scope: "comment", begin, end: end2, contains: [] }, modeOptions);
  mode.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  var ENGLISH_WORD = either$2(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  mode.contains.push({
    // TODO: how to include ", (, ) without breaking grammars that use these for
    // comment delimiters?
    // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
    // ---
    // this tries to find sequences of 3 english words in a row (without any
    // "programming" type syntax) this gives us a strong signal that we've
    // TRULY found a comment - vs perhaps scanning with the wrong language.
    // It's possible to find something that LOOKS like the start of the
    // comment - but then if there is no readable text - good chance it is a
    // false match and not a comment.
    //
    // for a visual example please see:
    // https://github.com/highlightjs/highlight.js/issues/2827
    begin: concat$2(
      /[ ]+/,
      // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
      "(",
      ENGLISH_WORD,
      /[.]?[:]?([.][ ]|[ ])/,
      "){3}"
    )
    // look for 3 words in a row
  });
  return mode;
};
var C_LINE_COMMENT_MODE$1 = COMMENT$1("//", "$");
var C_BLOCK_COMMENT_MODE$1 = COMMENT$1("/\\*", "\\*/");
var HASH_COMMENT_MODE$1 = COMMENT$1("#", "$");
var NUMBER_MODE$1 = { scope: "number", begin: NUMBER_RE$1, relevance: 0 };
var C_NUMBER_MODE$1 = { scope: "number", begin: C_NUMBER_RE$1, relevance: 0 };
var BINARY_NUMBER_MODE$1 = { scope: "number", begin: BINARY_NUMBER_RE$1, relevance: 0 };
var REGEXP_MODE$1 = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{ scope: "regexp", begin: /\//, end: /\/[gimuy]*/, illegal: /\n/, contains: [BACKSLASH_ESCAPE$1, { begin: /\[/, end: /\]/, relevance: 0, contains: [BACKSLASH_ESCAPE$1] }] }]
};
var TITLE_MODE$1 = { scope: "title", begin: IDENT_RE$3, relevance: 0 };
var UNDERSCORE_TITLE_MODE$1 = { scope: "title", begin: UNDERSCORE_IDENT_RE$1, relevance: 0 };
var METHOD_GUARD$1 = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE$1,
  relevance: 0
};
var END_SAME_AS_BEGIN$1 = function END_SAME_AS_BEGIN$12(mode) {
  return Object.assign(mode, {
    /** @type {ModeCallback} */
    "on:begin": function onBegin(m, resp) {
      resp.data._beginMatch = m[1];
    },
    /** @type {ModeCallback} */
    "on:end": function onEnd(m, resp) {
      if (resp.data._beginMatch !== m[1])
        resp.ignoreMatch();
    }
  });
};
var MODES$4 = /* @__PURE__ */ Object.freeze({ __proto__: null, MATCH_NOTHING_RE: MATCH_NOTHING_RE$1, IDENT_RE: IDENT_RE$3, UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE$1, NUMBER_RE: NUMBER_RE$1, C_NUMBER_RE: C_NUMBER_RE$1, BINARY_NUMBER_RE: BINARY_NUMBER_RE$1, RE_STARTERS_RE: RE_STARTERS_RE$1, SHEBANG: SHEBANG$1, BACKSLASH_ESCAPE: BACKSLASH_ESCAPE$1, APOS_STRING_MODE: APOS_STRING_MODE$1, QUOTE_STRING_MODE: QUOTE_STRING_MODE$1, PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE$1, COMMENT: COMMENT$1, C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE$1, C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE$1, HASH_COMMENT_MODE: HASH_COMMENT_MODE$1, NUMBER_MODE: NUMBER_MODE$1, C_NUMBER_MODE: C_NUMBER_MODE$1, BINARY_NUMBER_MODE: BINARY_NUMBER_MODE$1, REGEXP_MODE: REGEXP_MODE$1, TITLE_MODE: TITLE_MODE$1, UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE$1, METHOD_GUARD: METHOD_GUARD$1, END_SAME_AS_BEGIN: END_SAME_AS_BEGIN$1 });
function skipIfHasPrecedingDot$1(match, response) {
  var before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName$1(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords$1(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot$1;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal$1(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either$2.apply(void 0, mode.illegal);
}
function compileMatch$1(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance$1(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
var beforeMatchExt$1 = function beforeMatchExt$12(mode, parent) {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  var originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach(function(key) {
    delete mode[key];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat$2(originalMode.beforeMatch, lookahead$2(originalMode.begin));
  mode.starts = { relevance: 0, contains: [Object.assign(originalMode, { endsParent: true })] };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
var COMMON_KEYWORDS$1 = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
];
var DEFAULT_KEYWORD_SCOPE$1 = "keyword";
function compileKeywords$1(rawKeywords, caseInsensitive, scopeName) {
  if (scopeName === void 0) {
    scopeName = DEFAULT_KEYWORD_SCOPE$1;
  }
  var compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(compiledKeywords, compileKeywords$1(rawKeywords[scopeName2], caseInsensitive, scopeName2));
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map(function(x) {
        return x.toLowerCase();
      });
    }
    keywordList.forEach(function(keyword) {
      var pair = keyword.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword$1(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword$1(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword$1(keyword) ? 0 : 1;
}
function commonKeyword$1(keyword) {
  return COMMON_KEYWORDS$1.includes(keyword.toLowerCase());
}
var seenDeprecations$1 = {};
var error$1 = function error$12(message) {
  console.error(message);
};
var warn$1 = function warn$12(message) {
  var _console3;
  for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key9 = 1; _key9 < _len8; _key9++) {
    args[_key9 - 1] = arguments[_key9];
  }
  (_console3 = console).log.apply(_console3, ["WARN: " + message].concat(args));
};
var deprecated$1 = function deprecated$12(version2, message) {
  if (seenDeprecations$1[version2 + "/" + message])
    return;
  console.log("Deprecated as of " + version2 + ". " + message);
  seenDeprecations$1[version2 + "/" + message] = true;
};
var MultiClassError$1 = new Error();
function remapScopeNames$1(mode, regexes, _ref240) {
  var key = _ref240.key;
  var offset2 = 0;
  var scopeNames = mode[key];
  var emit = {};
  var positions = {};
  for (var _i265 = 1; _i265 <= regexes.length; _i265++) {
    positions[_i265 + offset2] = scopeNames[_i265];
    emit[_i265 + offset2] = true;
    offset2 += countMatchGroups$1(regexes[_i265 - 1]);
  }
  mode[key] = positions;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}
function beginMultiClass$1(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error$1("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError$1;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error$1("beginScope must be object");
    throw MultiClassError$1;
  }
  remapScopeNames$1(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences$1(mode.begin, { joinWith: "" });
}
function endMultiClass$1(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error$1("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError$1;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error$1("endScope must be object");
    throw MultiClassError$1;
  }
  remapScopeNames$1(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences$1(mode.end, { joinWith: "" });
}
function scopeSugar$1(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass$1(mode) {
  scopeSugar$1(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass$1(mode);
  endMultiClass$1(mode);
}
function compileLanguage$1(language) {
  function langRe(value, global) {
    return new RegExp(source$2(value), "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global ? "g" : ""));
  }
  var MultiRegex = /* @__PURE__ */ function() {
    function MultiRegex2() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    var _proto85 = MultiRegex2.prototype;
    _proto85.addRule = function addRule(re, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re]);
      this.matchAt += countMatchGroups$1(re) + 1;
    };
    _proto85.compile = function compile() {
      if (this.regexes.length === 0) {
        this.exec = function() {
          return null;
        };
      }
      var terminators = this.regexes.map(function(el) {
        return el[1];
      });
      this.matcherRe = langRe(_rewriteBackreferences$1(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    };
    _proto85.exec = function exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      var match = this.matcherRe.exec(s);
      if (!match) {
        return null;
      }
      var i = match.findIndex(function(el, i2) {
        return i2 > 0 && el !== void 0;
      });
      var matchData = this.matchIndexes[i];
      match.splice(0, i);
      return Object.assign(match, matchData);
    };
    return MultiRegex2;
  }();
  var ResumableMultiRegex = /* @__PURE__ */ function() {
    function ResumableMultiRegex2() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    var _proto86 = ResumableMultiRegex2.prototype;
    _proto86.getMatcher = function getMatcher(index) {
      if (this.multiRegexes[index])
        return this.multiRegexes[index];
      var matcher = new MultiRegex();
      this.rules.slice(index).forEach(function(_ref241) {
        var re = _ref241[0], opts = _ref241[1];
        return matcher.addRule(re, opts);
      });
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    };
    _proto86.resumingScanAtSamePosition = function resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    };
    _proto86.considerAll = function considerAll() {
      this.regexIndex = 0;
    };
    _proto86.addRule = function addRule(re, opts) {
      this.rules.push([re, opts]);
      if (opts.type === "begin")
        this.count++;
    };
    _proto86.exec = function exec(s) {
      var m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      var result = m.exec(s);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          var m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result = m2.exec(s);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    };
    return ResumableMultiRegex2;
  }();
  function buildModeRegex(mode) {
    var mm = new ResumableMultiRegex();
    mode.contains.forEach(function(term) {
      return mm.addRule(term.begin, { rule: term, type: "begin" });
    });
    if (mode.terminatorEnd) {
      mm.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm.addRule(mode.illegal, { type: "illegal" });
    }
    return mm;
  }
  function compileMode(mode, parent) {
    var _ref242;
    var cmode = (
      /** @type CompiledMode */
      mode
    );
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName$1,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch$1,
      MultiClass$1,
      beforeMatchExt$1
    ].forEach(function(ext) {
      return ext(mode, parent);
    });
    language.compilerExtensions.forEach(function(ext) {
      return ext(mode, parent);
    });
    mode.__beforeBegin = null;
    [
      beginKeywords$1,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal$1,
      // default to 1 relevance if not specified
      compileRelevance$1
    ].forEach(function(ext) {
      return ext(mode, parent);
    });
    mode.isCompiled = true;
    var keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords$1(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source$2(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(
        /** @type {RegExp | string} */
        mode.illegal
      );
    if (!mode.contains)
      mode.contains = [];
    mode.contains = (_ref242 = []).concat.apply(_ref242, mode.contains.map(function(c2) {
      return expandOrCloneMode$1(c2 === "self" ? mode : c2);
    }));
    mode.contains.forEach(function(c2) {
      compileMode(
        /** @type Mode */
        c2,
        cmode
      );
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1$1(language.classNameAliases || {});
  return compileMode(
    /** @type Mode */
    language
  );
}
function dependencyOnParent$1(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent$1(mode.starts);
}
function expandOrCloneMode$1(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent$1(mode)) {
    return inherit$1$1(mode, { starts: mode.starts ? inherit$1$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1$1(mode);
  }
  return mode;
}
var version$2 = "11.6.0";
var HTMLInjectionError$1 = /* @__PURE__ */ function(_Error3) {
  _inheritsLoose(HTMLInjectionError2, _Error3);
  function HTMLInjectionError2(reason, html) {
    var _this127;
    _this127 = _Error3.call(this, reason) || this;
    _this127.name = "HTMLInjectionError";
    _this127.html = html;
    return _this127;
  }
  return HTMLInjectionError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var escape$1 = escapeHTML$1;
var inherit$2 = inherit$1$1;
var NO_MATCH$1 = Symbol("nomatch");
var MAX_KEYWORD_HITS$1 = 7;
var HLJS$1 = function HLJS$12(hljs) {
  var languages = /* @__PURE__ */ Object.create(null);
  var aliases = /* @__PURE__ */ Object.create(null);
  var plugins = [];
  var SAFE_MODE = true;
  var LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  var PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
  var options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter$1
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    var classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    var match = options.languageDetectRe.exec(classes);
    if (match) {
      var language = getLanguage(match[1]);
      if (!language) {
        warn$1(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn$1("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match[1] : "no-highlight";
    }
    return classes.split(/\s+/).find(function(_class) {
      return shouldNotHighlight(_class) || getLanguage(_class);
    });
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    var code = "";
    var languageName = "";
    if (typeof optionsOrCode === "object") {
      code = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated$1("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated$1("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    var context = { code, language: languageName };
    fire("before:highlight", context);
    var result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result.code = context.code;
    fire("after:highlight", result);
    return result;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    var keywordHits = /* @__PURE__ */ Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top2.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      var lastIndex = 0;
      top2.keywordPatternRe.lastIndex = 0;
      var match2 = top2.keywordPatternRe.exec(modeBuffer);
      var buf = "";
      while (match2) {
        buf += modeBuffer.substring(lastIndex, match2.index);
        var word = language.case_insensitive ? match2[0].toLowerCase() : match2[0];
        var data2 = keywordData(top2, word);
        if (data2) {
          var kind = data2[0], keywordRelevance = data2[1];
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS$1)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match2[0];
          } else {
            var cssClass = language.classNameAliases[kind] || kind;
            emitter.addKeyword(match2[0], cssClass);
          }
        } else {
          buf += match2[0];
        }
        lastIndex = top2.keywordPatternRe.lastIndex;
        match2 = top2.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substring(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      var result2 = null;
      if (typeof top2.subLanguage === "string") {
        if (!languages[top2.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
        continuations[top2.subLanguage] = /** @type {CompiledMode} */
        result2._top;
      } else {
        result2 = highlightAuto2(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
      }
      if (top2.relevance > 0) {
        relevance += result2.relevance;
      }
      emitter.addSublanguage(result2._emitter, result2.language);
    }
    function processBuffer() {
      if (top2.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitMultiClass(scope, match2) {
      var i = 1;
      var max2 = match2.length - 1;
      while (i <= max2) {
        if (!scope._emit[i]) {
          i++;
          continue;
        }
        var klass = language.classNameAliases[scope[i]] || scope[i];
        var text = match2[i];
        if (klass) {
          emitter.addKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i++;
      }
    }
    function startNewMode(mode, match2) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match2);
          modeBuffer = "";
        }
      }
      top2 = Object.create(mode, { parent: { value: top2 } });
      return top2;
    }
    function endOfMode(mode, match2, matchPlusRemainder) {
      var matched = startsWith$1(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          var resp = new Response$1(mode);
          mode["on:end"](match2, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match2, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top2.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match2) {
      var lexeme = match2[0];
      var newMode = match2.rule;
      var resp = new Response$1(newMode);
      var beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (var _i266 = 0, _beforeCallbacks = beforeCallbacks; _i266 < _beforeCallbacks.length; _i266++) {
        var cb = _beforeCallbacks[_i266];
        if (!cb)
          continue;
        cb(match2, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match2);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match2) {
      var lexeme = match2[0];
      var matchPlusRemainder = codeToHighlight.substring(match2.index);
      var endMode = endOfMode(top2, match2, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH$1;
      }
      var origin = top2;
      if (top2.endScope && top2.endScope._wrap) {
        processBuffer();
        emitter.addKeyword(lexeme, top2.endScope._wrap);
      } else if (top2.endScope && top2.endScope._multi) {
        processBuffer();
        emitMultiClass(top2.endScope, match2);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top2.scope) {
          emitter.closeNode();
        }
        if (!top2.skip && !top2.subLanguage) {
          relevance += top2.relevance;
        }
        top2 = top2.parent;
      } while (top2 !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match2);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      var list = [];
      for (var current = top2; current !== language; current = current.parent) {
        if (current.scope) {
          list.unshift(current.scope);
        }
      }
      list.forEach(function(item) {
        return emitter.openNode(item);
      });
    }
    var lastMatch = {};
    function processLexeme(textBeforeMatch, match2) {
      var lexeme = match2 && match2[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match2.type === "end" && lastMatch.index === match2.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match2.index, match2.index + 1);
        if (!SAFE_MODE) {
          var err = new Error("0 width match regex (" + languageName + ")");
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match2;
      if (match2.type === "begin") {
        return doBeginMatch(match2);
      } else if (match2.type === "illegal" && !ignoreIllegals) {
        var _err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.scope || "<unnamed>") + '"');
        _err.mode = top2;
        throw _err;
      } else if (match2.type === "end") {
        var processed = doEndMatch(match2);
        if (processed !== NO_MATCH$1) {
          return processed;
        }
      }
      if (match2.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match2.index * 3) {
        var _err2 = new Error("potential infinite loop, way more iterations than matches");
        throw _err2;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    var language = getLanguage(languageName);
    if (!language) {
      error$1(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    var md = compileLanguage$1(language);
    var result = "";
    var top2 = continuation || md;
    var continuations = {};
    var emitter = new options.__emitter(options);
    processContinuations();
    var modeBuffer = "";
    var relevance = 0;
    var index = 0;
    var iterations = 0;
    var resumeScanAtSamePosition = false;
    try {
      top2.matcher.considerAll();
      for (; ; ) {
        iterations++;
        if (resumeScanAtSamePosition) {
          resumeScanAtSamePosition = false;
        } else {
          top2.matcher.considerAll();
        }
        top2.matcher.lastIndex = index;
        var match = top2.matcher.exec(codeToHighlight);
        if (!match)
          break;
        var beforeMatch = codeToHighlight.substring(index, match.index);
        var processedCount = processLexeme(beforeMatch, match);
        index = match.index + processedCount;
      }
      processLexeme(codeToHighlight.substring(index));
      emitter.closeAllNodes();
      emitter.finalize();
      result = emitter.toHTML();
      return { language: languageName, value: result, relevance, illegal: false, _emitter: emitter, _top: top2 };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return { language: languageName, value: escape$1(codeToHighlight), illegal: true, relevance: 0, _illegalBy: { message: err.message, index, context: codeToHighlight.slice(index - 100, index + 100), mode: err.mode, resultSoFar: result }, _emitter: emitter };
      } else if (SAFE_MODE) {
        return { language: languageName, value: escape$1(codeToHighlight), illegal: false, relevance: 0, errorRaised: err, _emitter: emitter, _top: top2 };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code) {
    var result = { value: escape$1(code), illegal: false, relevance: 0, _top: PLAINTEXT_LANGUAGE, _emitter: new options.__emitter(options) };
    result._emitter.addText(code);
    return result;
  }
  function highlightAuto2(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    var plaintext2 = justTextHighlightResult(code);
    var results = languageSubset.filter(getLanguage).filter(autoDetection).map(function(name) {
      return _highlight(name, code, false);
    });
    results.unshift(plaintext2);
    var sorted = results.sort(function(a, b) {
      if (a.relevance !== b.relevance)
        return b.relevance - a.relevance;
      if (a.language && b.language) {
        if (getLanguage(a.language).supersetOf === b.language) {
          return 1;
        } else if (getLanguage(b.language).supersetOf === a.language) {
          return -1;
        }
      }
      return 0;
    });
    var best = sorted[0], secondBest = sorted[1];
    var result = best;
    result.secondBest = secondBest;
    return result;
  }
  function updateClassName(element, currentLang, resultLang) {
    var language = currentLang && aliases[currentLang] || resultLang;
    element.classList.add("hljs");
    element.classList.add("language-" + language);
  }
  function highlightElement(element) {
    var node = null;
    var language = blockLanguage(element);
    if (shouldNotHighlight(language))
      return;
    fire("before:highlightElement", { el: element, language });
    if (element.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element);
      }
      if (options.throwUnescapedHTML) {
        var err = new HTMLInjectionError$1("One of your code blocks includes unescaped HTML.", element.innerHTML);
        throw err;
      }
    }
    node = element;
    var text = node.textContent;
    var result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto2(text);
    element.innerHTML = result.value;
    updateClassName(element, language, result.language);
    element.result = {
      language: result.language,
      // TODO: remove with version 11.0
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element.secondBest = { language: result.secondBest.language, relevance: result.secondBest.relevance };
    }
    fire("after:highlightElement", { el: element, result, text });
  }
  function configure(userOptions) {
    options = inherit$2(options, userOptions);
  }
  var initHighlighting = function initHighlighting2() {
    highlightAll();
    deprecated$1("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated$1("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  var wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    var blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage2(languageName, languageDefinition) {
    var lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1$1) {
      error$1("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$1$1;
      } else {
        error$1(error$1$1);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (var _i267 = 0, _Object$keys = Object.keys(aliases); _i267 < _Object$keys.length; _i267++) {
      var alias = _Object$keys[_i267];
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages2() {
    return Object.keys(languages);
  }
  function getLanguage(name) {
    name = (name || "").toLowerCase();
    return languages[name] || languages[aliases[name]];
  }
  function registerAliases(aliasList, _ref243) {
    var languageName = _ref243.languageName;
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach(function(alias) {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name) {
    var lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = function(data2) {
        plugin["before:highlightBlock"](Object.assign({ block: data2.el }, data2));
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = function(data2) {
        plugin["after:highlightBlock"](Object.assign({ block: data2.el }, data2));
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function fire(event, args) {
    var cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }
  function deprecateHighlightBlock(el) {
    deprecated$1("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated$1("10.7.0", "Please use highlightElement now.");
    return highlightElement(el);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto: highlightAuto2,
    highlightAll,
    highlightElement,
    // TODO: Remove with v12 API
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage: registerLanguage2,
    unregisterLanguage,
    listLanguages: listLanguages2,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit: inherit$2,
    addPlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version$2;
  hljs.regex = { concat: concat$2, lookahead: lookahead$2, either: either$2, optional: optional$1, anyNumberOfTimes: anyNumberOfTimes$1 };
  for (var key in MODES$4) {
    if (typeof MODES$4[key] === "object") {
      deepFreezeEs6.exports(MODES$4[key]);
    }
  }
  Object.assign(hljs, MODES$4);
  return hljs;
};
var highlight$2 = HLJS$1({});
var core$1 = highlight$2;
highlight$2.HighlightJS = highlight$2;
highlight$2.default = highlight$2;
var HighlightJS$1 = core$1;
function parseNodes(nodes, className) {
  if (className === void 0) {
    className = [];
  }
  return nodes.map(function(node) {
    var classes = [].concat(className, node.properties ? node.properties.className : []);
    if (node.children) {
      return parseNodes(node.children, classes);
    }
    return { text: node.value, classes };
  }).flat();
}
function getHighlightNodes(result) {
  return result.value || result.children || [];
}
function registered$1(aliasOrLanguage) {
  return Boolean(HighlightJS$1.getLanguage(aliasOrLanguage));
}
function getDecorations(_ref244) {
  var doc2 = _ref244.doc, name = _ref244.name, lowlight2 = _ref244.lowlight, defaultLanguage = _ref244.defaultLanguage;
  var decorations = [];
  findChildren(doc2, function(node) {
    return node.type.name === name;
  }).forEach(function(block) {
    var from2 = block.pos + 1;
    var language = block.node.attrs.language || defaultLanguage;
    var languages = lowlight2.listLanguages();
    var nodes = language && (languages.includes(language) || registered$1(language)) ? getHighlightNodes(lowlight2.highlight(language, block.node.textContent)) : getHighlightNodes(lowlight2.highlightAuto(block.node.textContent));
    parseNodes(nodes).forEach(function(node) {
      var to = from2 + node.text.length;
      if (node.classes.length) {
        var decoration = Decoration.inline(from2, to, { class: node.classes.join(" ") });
        decorations.push(decoration);
      }
      from2 = to;
    });
  });
  return DecorationSet.create(doc2, decorations);
}
function isFunction(param) {
  return typeof param === "function";
}
function LowlightPlugin(_ref245) {
  var name = _ref245.name, lowlight2 = _ref245.lowlight, defaultLanguage = _ref245.defaultLanguage;
  if (!["highlight", "highlightAuto", "listLanguages"].every(function(api2) {
    return isFunction(lowlight2[api2]);
  })) {
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  }
  var lowlightPlugin = new Plugin({ key: new PluginKey("lowlight"), state: { init: function init6(_, _ref246) {
    var doc2 = _ref246.doc;
    return getDecorations({ doc: doc2, name, lowlight: lowlight2, defaultLanguage });
  }, apply: function apply6(transaction, decorationSet, oldState, newState) {
    var oldNodeName = oldState.selection.$head.parent.type.name;
    var newNodeName = newState.selection.$head.parent.type.name;
    var oldNodes = findChildren(oldState.doc, function(node) {
      return node.type.name === name;
    });
    var newNodes = findChildren(newState.doc, function(node) {
      return node.type.name === name;
    });
    if (transaction.docChanged && ([oldNodeName, newNodeName].includes(name) || newNodes.length !== oldNodes.length || transaction.steps.some(function(step) {
      return (
        // @ts-ignore
        step.from !== void 0 && step.to !== void 0 && oldNodes.some(function(node) {
          return (
            // @ts-ignore
            node.pos >= step.from && node.pos + node.node.nodeSize <= step.to
          );
        })
      );
    }))) {
      return getDecorations({ doc: transaction.doc, name, lowlight: lowlight2, defaultLanguage });
    }
    return decorationSet.map(transaction.mapping, transaction.doc);
  } }, props: { decorations: function decorations(state) {
    return lowlightPlugin.getState(state);
  } } });
  return lowlightPlugin;
}
var CodeBlockLowlight = CodeBlock.extend({ addOptions: function addOptions37() {
  var _a;
  return _extends({}, (_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this), { lowlight: {}, defaultLanguage: null });
}, addProseMirrorPlugins: function addProseMirrorPlugins14() {
  var _a;
  return [].concat(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.call(this)) || [], [LowlightPlugin({ name: this.name, lowlight: this.options.lowlight, defaultLanguage: this.options.defaultLanguage })]);
} });
var Placeholder = Extension.create({ name: "placeholder", addOptions: function addOptions38() {
  return { emptyEditorClass: "is-editor-empty", emptyNodeClass: "is-empty", placeholder: "Write something …", showOnlyWhenEditable: true, showOnlyCurrent: true, includeChildren: false };
}, addProseMirrorPlugins: function addProseMirrorPlugins15() {
  var _this128 = this;
  return [new Plugin({ key: new PluginKey("placeholder"), props: { decorations: function decorations(_ref247) {
    var doc2 = _ref247.doc, selection = _ref247.selection;
    var active = _this128.editor.isEditable || !_this128.options.showOnlyWhenEditable;
    var anchor = selection.anchor;
    var decorations2 = [];
    if (!active) {
      return null;
    }
    var emptyDocInstance = doc2.type.createAndFill();
    var isEditorEmpty = (emptyDocInstance === null || emptyDocInstance === void 0 ? void 0 : emptyDocInstance.sameMarkup(doc2)) && emptyDocInstance.content.findDiffStart(doc2.content) === null;
    doc2.descendants(function(node, pos) {
      var hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
      var isEmpty2 = !node.isLeaf && !node.childCount;
      if ((hasAnchor || !_this128.options.showOnlyCurrent) && isEmpty2) {
        var classes = [_this128.options.emptyNodeClass];
        if (isEditorEmpty) {
          classes.push(_this128.options.emptyEditorClass);
        }
        var decoration = Decoration.node(pos, pos + node.nodeSize, { class: classes.join(" "), "data-placeholder": typeof _this128.options.placeholder === "function" ? _this128.options.placeholder({ editor: _this128.editor, node, pos, hasAnchor }) : _this128.options.placeholder });
        decorations2.push(decoration);
      }
      return _this128.options.includeChildren;
    });
    return DecorationSet.create(doc2, decorations2);
  } } })];
} });
function cPlusPlus(hljs) {
  var regex = hljs.regex;
  var C_LINE_COMMENT_MODE2 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
  var DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
  var NAMESPACE_RE = "[a-zA-Z_]\\w*::";
  var TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
  var FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex.optional(TEMPLATE_ARGUMENT_RE) + ")";
  var CPP_PRIMITIVE_TYPES = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" };
  var CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
  var STRINGS = { className: "string", variants: [{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [hljs.BACKSLASH_ESCAPE] }, { begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)", end: "'", illegal: "." }, hljs.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ })] };
  var NUMBERS = { className: "number", variants: [{ begin: "\\b(0b[01']+)" }, { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" }, { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }], relevance: 0 };
  var PREPROCESSOR = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, hljs.inherit(STRINGS, { className: "string" }), { className: "string", begin: /<.*?>/ }, C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE] };
  var TITLE_MODE2 = { className: "title", begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE, relevance: 0 };
  var FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
  var RESERVED_KEYWORDS = ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "break", "case", "catch", "class", "co_await", "co_return", "co_yield", "compl", "concept", "const_cast|10", "consteval", "constexpr", "constinit", "continue", "decltype", "default", "delete", "do", "dynamic_cast|10", "else", "enum", "explicit", "export", "extern", "false", "final", "for", "friend", "goto", "if", "import", "inline", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "override", "private", "protected", "public", "reflexpr", "register", "reinterpret_cast|10", "requires", "return", "sizeof", "static_assert", "static_cast|10", "struct", "switch", "synchronized", "template", "this", "thread_local", "throw", "transaction_safe", "transaction_safe_dynamic", "true", "try", "typedef", "typeid", "typename", "union", "using", "virtual", "volatile", "while", "xor", "xor_eq"];
  var RESERVED_TYPES = ["bool", "char", "char16_t", "char32_t", "char8_t", "double", "float", "int", "long", "short", "void", "wchar_t", "unsigned", "signed", "const", "static"];
  var TYPE_HINTS = ["any", "auto_ptr", "barrier", "binary_semaphore", "bitset", "complex", "condition_variable", "condition_variable_any", "counting_semaphore", "deque", "false_type", "future", "imaginary", "initializer_list", "istringstream", "jthread", "latch", "lock_guard", "multimap", "multiset", "mutex", "optional", "ostringstream", "packaged_task", "pair", "promise", "priority_queue", "queue", "recursive_mutex", "recursive_timed_mutex", "scoped_lock", "set", "shared_future", "shared_lock", "shared_mutex", "shared_timed_mutex", "shared_ptr", "stack", "string_view", "stringstream", "timed_mutex", "thread", "true_type", "tuple", "unique_lock", "unique_ptr", "unordered_map", "unordered_multimap", "unordered_multiset", "unordered_set", "variant", "vector", "weak_ptr", "wstring", "wstring_view"];
  var FUNCTION_HINTS = ["abort", "abs", "acos", "apply", "as_const", "asin", "atan", "atan2", "calloc", "ceil", "cerr", "cin", "clog", "cos", "cosh", "cout", "declval", "endl", "exchange", "exit", "exp", "fabs", "floor", "fmod", "forward", "fprintf", "fputs", "free", "frexp", "fscanf", "future", "invoke", "isalnum", "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "isxdigit", "labs", "launder", "ldexp", "log", "log10", "make_pair", "make_shared", "make_shared_for_overwrite", "make_tuple", "make_unique", "malloc", "memchr", "memcmp", "memcpy", "memset", "modf", "move", "pow", "printf", "putchar", "puts", "realloc", "scanf", "sin", "sinh", "snprintf", "sprintf", "sqrt", "sscanf", "std", "stderr", "stdin", "stdout", "strcat", "strchr", "strcmp", "strcpy", "strcspn", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", "strrchr", "strspn", "strstr", "swap", "tan", "tanh", "terminate", "to_underlying", "tolower", "toupper", "vfprintf", "visit", "vprintf", "vsprintf"];
  var LITERALS2 = ["NULL", "false", "nullopt", "nullptr", "true"];
  var BUILT_IN = ["_Pragma"];
  var CPP_KEYWORDS = { type: RESERVED_TYPES, keyword: RESERVED_KEYWORDS, literal: LITERALS2, built_in: BUILT_IN, _type_hints: TYPE_HINTS };
  var FUNCTION_DISPATCH = { className: "function.dispatch", relevance: 0, keywords: {
    // Only for relevance, not highlighting.
    _hint: FUNCTION_HINTS
  }, begin: regex.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, hljs.IDENT_RE, regex.lookahead(/(<[^<>]+>|)\s*\(/)) };
  var EXPRESSION_CONTAINS = [FUNCTION_DISPATCH, PREPROCESSOR, CPP_PRIMITIVE_TYPES, C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE, NUMBERS, STRINGS];
  var EXPRESSION_CONTEXT = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [{ begin: /=/, end: /;/ }, { begin: /\(/, end: /\)/ }, { beginKeywords: "new throw return else", end: /;/ }],
    keywords: CPP_KEYWORDS,
    contains: EXPRESSION_CONTAINS.concat([{ begin: /\(/, end: /\)/, keywords: CPP_KEYWORDS, contains: EXPRESSION_CONTAINS.concat(["self"]), relevance: 0 }]),
    relevance: 0
  };
  var FUNCTION_DECLARATION = { className: "function", begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE, returnBegin: true, end: /[{;=]/, excludeEnd: true, keywords: CPP_KEYWORDS, illegal: /[^\w\s\*&:<>.]/, contains: [
    {
      // to prevent it from being confused as the function title
      begin: DECLTYPE_AUTO_RE,
      keywords: CPP_KEYWORDS,
      relevance: 0
    },
    { begin: FUNCTION_TITLE, returnBegin: true, contains: [TITLE_MODE2], relevance: 0 },
    // needed because we do not have look-behind on the below rule
    // to prevent it from grabbing the final : in a :: pair
    { begin: /::/, relevance: 0 },
    // initializers
    { begin: /:/, endsWithParent: true, contains: [STRINGS, NUMBERS] },
    // allow for multiple declarations, e.g.:
    // extern void f(int), g(char);
    { relevance: 0, match: /,/ },
    { className: "params", begin: /\(/, end: /\)/, keywords: CPP_KEYWORDS, relevance: 0, contains: [
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE,
      STRINGS,
      NUMBERS,
      CPP_PRIMITIVE_TYPES,
      // Count matching parentheses.
      { begin: /\(/, end: /\)/, keywords: CPP_KEYWORDS, relevance: 0, contains: ["self", C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE, STRINGS, NUMBERS, CPP_PRIMITIVE_TYPES] }
    ] },
    CPP_PRIMITIVE_TYPES,
    C_LINE_COMMENT_MODE2,
    hljs.C_BLOCK_COMMENT_MODE,
    PREPROCESSOR
  ] };
  return { name: "C++", aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"], keywords: CPP_KEYWORDS, illegal: "</", classNameAliases: { "function.dispatch": "built_in" }, contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, FUNCTION_DISPATCH, EXPRESSION_CONTAINS, [PREPROCESSOR, {
    // containers: ie, `vector <int> rooms (9);`
    begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
    end: ">",
    keywords: CPP_KEYWORDS,
    contains: ["self", CPP_PRIMITIVE_TYPES]
  }, { begin: hljs.IDENT_RE + "::", keywords: CPP_KEYWORDS }, { match: [
    // extra complexity to deal with `enum class` and `enum struct`
    /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
    /\s+/,
    /\w+/
  ], className: { 1: "keyword", 3: "title.class" } }]) };
}
function arduino(hljs) {
  var ARDUINO_KW = { type: ["boolean", "byte", "word", "String"], built_in: ["KeyboardController", "MouseController", "SoftwareSerial", "EthernetServer", "EthernetClient", "LiquidCrystal", "RobotControl", "GSMVoiceCall", "EthernetUDP", "EsploraTFT", "HttpClient", "RobotMotor", "WiFiClient", "GSMScanner", "FileSystem", "Scheduler", "GSMServer", "YunClient", "YunServer", "IPAddress", "GSMClient", "GSMModem", "Keyboard", "Ethernet", "Console", "GSMBand", "Esplora", "Stepper", "Process", "WiFiUDP", "GSM_SMS", "Mailbox", "USBHost", "Firmata", "PImage", "Client", "Server", "GSMPIN", "FileIO", "Bridge", "Serial", "EEPROM", "Stream", "Mouse", "Audio", "Servo", "File", "Task", "GPRS", "WiFi", "Wire", "TFT", "GSM", "SPI", "SD"], _hints: ["setup", "loop", "runShellCommandAsynchronously", "analogWriteResolution", "retrieveCallingNumber", "printFirmwareVersion", "analogReadResolution", "sendDigitalPortPair", "noListenOnLocalhost", "readJoystickButton", "setFirmwareVersion", "readJoystickSwitch", "scrollDisplayRight", "getVoiceCallStatus", "scrollDisplayLeft", "writeMicroseconds", "delayMicroseconds", "beginTransmission", "getSignalStrength", "runAsynchronously", "getAsynchronously", "listenOnLocalhost", "getCurrentCarrier", "readAccelerometer", "messageAvailable", "sendDigitalPorts", "lineFollowConfig", "countryNameWrite", "runShellCommand", "readStringUntil", "rewindDirectory", "readTemperature", "setClockDivider", "readLightSensor", "endTransmission", "analogReference", "detachInterrupt", "countryNameRead", "attachInterrupt", "encryptionType", "readBytesUntil", "robotNameWrite", "readMicrophone", "robotNameRead", "cityNameWrite", "userNameWrite", "readJoystickY", "readJoystickX", "mouseReleased", "openNextFile", "scanNetworks", "noInterrupts", "digitalWrite", "beginSpeaker", "mousePressed", "isActionDone", "mouseDragged", "displayLogos", "noAutoscroll", "addParameter", "remoteNumber", "getModifiers", "keyboardRead", "userNameRead", "waitContinue", "processInput", "parseCommand", "printVersion", "readNetworks", "writeMessage", "blinkVersion", "cityNameRead", "readMessage", "setDataMode", "parsePacket", "isListening", "setBitOrder", "beginPacket", "isDirectory", "motorsWrite", "drawCompass", "digitalRead", "clearScreen", "serialEvent", "rightToLeft", "setTextSize", "leftToRight", "requestFrom", "keyReleased", "compassRead", "analogWrite", "interrupts", "WiFiServer", "disconnect", "playMelody", "parseFloat", "autoscroll", "getPINUsed", "setPINUsed", "setTimeout", "sendAnalog", "readSlider", "analogRead", "beginWrite", "createChar", "motorsStop", "keyPressed", "tempoWrite", "readButton", "subnetMask", "debugPrint", "macAddress", "writeGreen", "randomSeed", "attachGPRS", "readString", "sendString", "remotePort", "releaseAll", "mouseMoved", "background", "getXChange", "getYChange", "answerCall", "getResult", "voiceCall", "endPacket", "constrain", "getSocket", "writeJSON", "getButton", "available", "connected", "findUntil", "readBytes", "exitValue", "readGreen", "writeBlue", "startLoop", "IPAddress", "isPressed", "sendSysex", "pauseMode", "gatewayIP", "setCursor", "getOemKey", "tuneWrite", "noDisplay", "loadImage", "switchPIN", "onRequest", "onReceive", "changePIN", "playFile", "noBuffer", "parseInt", "overflow", "checkPIN", "knobRead", "beginTFT", "bitClear", "updateIR", "bitWrite", "position", "writeRGB", "highByte", "writeRed", "setSpeed", "readBlue", "noStroke", "remoteIP", "transfer", "shutdown", "hangCall", "beginSMS", "endWrite", "attached", "maintain", "noCursor", "checkReg", "checkPUK", "shiftOut", "isValid", "shiftIn", "pulseIn", "connect", "println", "localIP", "pinMode", "getIMEI", "display", "noBlink", "process", "getBand", "running", "beginSD", "drawBMP", "lowByte", "setBand", "release", "bitRead", "prepare", "pointTo", "readRed", "setMode", "noFill", "remove", "listen", "stroke", "detach", "attach", "noTone", "exists", "buffer", "height", "bitSet", "circle", "config", "cursor", "random", "IRread", "setDNS", "endSMS", "getKey", "micros", "millis", "begin", "print", "write", "ready", "flush", "width", "isPIN", "blink", "clear", "press", "mkdir", "rmdir", "close", "point", "yield", "image", "BSSID", "click", "delay", "read", "text", "move", "peek", "beep", "rect", "line", "open", "seek", "fill", "size", "turn", "stop", "home", "find", "step", "tone", "sqrt", "RSSI", "SSID", "end", "bit", "tan", "cos", "sin", "pow", "map", "abs", "max", "min", "get", "run", "put"], literal: ["DIGITAL_MESSAGE", "FIRMATA_STRING", "ANALOG_MESSAGE", "REPORT_DIGITAL", "REPORT_ANALOG", "INPUT_PULLUP", "SET_PIN_MODE", "INTERNAL2V56", "SYSTEM_RESET", "LED_BUILTIN", "INTERNAL1V1", "SYSEX_START", "INTERNAL", "EXTERNAL", "DEFAULT", "OUTPUT", "INPUT", "HIGH", "LOW"] };
  var ARDUINO = cPlusPlus(hljs);
  var kws = (
    /** @type {Record<string,any>} */
    ARDUINO.keywords
  );
  kws.type = [].concat(kws.type, ARDUINO_KW.type);
  kws.literal = [].concat(kws.literal, ARDUINO_KW.literal);
  kws.built_in = [].concat(kws.built_in, ARDUINO_KW.built_in);
  kws._hints = ARDUINO_KW._hints;
  ARDUINO.name = "Arduino";
  ARDUINO.aliases = ["ino"];
  ARDUINO.supersetOf = "cpp";
  return ARDUINO;
}
function bash(hljs) {
  var regex = hljs.regex;
  var VAR = {};
  var BRACED_VAR = { begin: /\$\{/, end: /\}/, contains: [
    "self",
    { begin: /:-/, contains: [VAR] }
    // default values
  ] };
  Object.assign(VAR, { className: "variable", variants: [{ begin: regex.concat(
    /\$[\w\d#@][\w\d_]*/,
    // negative look-ahead tries to avoid matching patterns that are not
    // Perl at all like $ident$, @ident@, etc.
    "(?![\\w\\d])(?![$])"
  ) }, BRACED_VAR] });
  var SUBST = { className: "subst", begin: /\$\(/, end: /\)/, contains: [hljs.BACKSLASH_ESCAPE] };
  var HERE_DOC = { begin: /<<-?\s*(?=\w+)/, starts: { contains: [hljs.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, className: "string" })] } };
  var QUOTE_STRING = { className: "string", begin: /"/, end: /"/, contains: [hljs.BACKSLASH_ESCAPE, VAR, SUBST] };
  SUBST.contains.push(QUOTE_STRING);
  var ESCAPED_QUOTE = { className: "", begin: /\\"/ };
  var APOS_STRING = { className: "string", begin: /'/, end: /'/ };
  var ARITHMETIC = { begin: /\$?\(\(/, end: /\)\)/, contains: [{ begin: /\d+#[0-9a-f]+/, className: "number" }, hljs.NUMBER_MODE, VAR] };
  var SH_LIKE_SHELLS = ["fish", "bash", "zsh", "sh", "csh", "ksh", "tcsh", "dash", "scsh"];
  var KNOWN_SHEBANG = hljs.SHEBANG({ binary: "(" + SH_LIKE_SHELLS.join("|") + ")", relevance: 10 });
  var FUNCTION = { className: "function", begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/, returnBegin: true, contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })], relevance: 0 };
  var KEYWORDS2 = ["if", "then", "else", "elif", "fi", "for", "while", "until", "in", "do", "done", "case", "esac", "function", "select"];
  var LITERALS2 = ["true", "false"];
  var PATH_MODE = { match: /(\/[a-z._-]+)+/ };
  var SHELL_BUILT_INS = ["break", "cd", "continue", "eval", "exec", "exit", "export", "getopts", "hash", "pwd", "readonly", "return", "shift", "test", "times", "trap", "umask", "unset"];
  var BASH_BUILT_INS = ["alias", "bind", "builtin", "caller", "command", "declare", "echo", "enable", "help", "let", "local", "logout", "mapfile", "printf", "read", "readarray", "source", "type", "typeset", "ulimit", "unalias"];
  var ZSH_BUILT_INS = ["autoload", "bg", "bindkey", "bye", "cap", "chdir", "clone", "comparguments", "compcall", "compctl", "compdescribe", "compfiles", "compgroups", "compquote", "comptags", "comptry", "compvalues", "dirs", "disable", "disown", "echotc", "echoti", "emulate", "fc", "fg", "float", "functions", "getcap", "getln", "history", "integer", "jobs", "kill", "limit", "log", "noglob", "popd", "print", "pushd", "pushln", "rehash", "sched", "setcap", "setopt", "stat", "suspend", "ttyctl", "unfunction", "unhash", "unlimit", "unsetopt", "vared", "wait", "whence", "where", "which", "zcompile", "zformat", "zftp", "zle", "zmodload", "zparseopts", "zprof", "zpty", "zregexparse", "zsocket", "zstyle", "ztcp"];
  var GNU_CORE_UTILS = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return { name: "Bash", aliases: ["sh"], keywords: { $pattern: /\b[a-z][a-z0-9._-]+\b/, keyword: KEYWORDS2, literal: LITERALS2, built_in: [].concat(SHELL_BUILT_INS, BASH_BUILT_INS, [
    // Shell modifiers
    "set",
    "shopt"
  ], ZSH_BUILT_INS, GNU_CORE_UTILS) }, contains: [
    KNOWN_SHEBANG,
    // to catch known shells and boost relevancy
    hljs.SHEBANG(),
    // to catch unknown shells but still highlight the shebang
    FUNCTION,
    ARITHMETIC,
    hljs.HASH_COMMENT_MODE,
    HERE_DOC,
    PATH_MODE,
    QUOTE_STRING,
    ESCAPED_QUOTE,
    APOS_STRING,
    VAR
  ] };
}
function c(hljs) {
  var regex = hljs.regex;
  var C_LINE_COMMENT_MODE2 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
  var DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
  var NAMESPACE_RE = "[a-zA-Z_]\\w*::";
  var TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
  var FUNCTION_TYPE_RE = "(" + DECLTYPE_AUTO_RE + "|" + regex.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex.optional(TEMPLATE_ARGUMENT_RE) + ")";
  var TYPES2 = { className: "type", variants: [{ begin: "\\b[a-z\\d_]*_t\\b" }, { match: /\batomic_[a-z]{3,6}\b/ }] };
  var CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
  var STRINGS = { className: "string", variants: [{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [hljs.BACKSLASH_ESCAPE] }, { begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)", end: "'", illegal: "." }, hljs.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ })] };
  var NUMBERS = { className: "number", variants: [{ begin: "\\b(0b[01']+)" }, { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" }, { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }], relevance: 0 };
  var PREPROCESSOR = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, hljs.inherit(STRINGS, { className: "string" }), { className: "string", begin: /<.*?>/ }, C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE] };
  var TITLE_MODE2 = { className: "title", begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE, relevance: 0 };
  var FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
  var C_KEYWORDS = [
    "asm",
    "auto",
    "break",
    "case",
    "continue",
    "default",
    "do",
    "else",
    "enum",
    "extern",
    "for",
    "fortran",
    "goto",
    "if",
    "inline",
    "register",
    "restrict",
    "return",
    "sizeof",
    "struct",
    "switch",
    "typedef",
    "union",
    "volatile",
    "while",
    "_Alignas",
    "_Alignof",
    "_Atomic",
    "_Generic",
    "_Noreturn",
    "_Static_assert",
    "_Thread_local",
    // aliases
    "alignas",
    "alignof",
    "noreturn",
    "static_assert",
    "thread_local",
    // not a C keyword but is, for all intents and purposes, treated exactly like one.
    "_Pragma"
  ];
  var C_TYPES = [
    "float",
    "double",
    "signed",
    "unsigned",
    "int",
    "short",
    "long",
    "char",
    "void",
    "_Bool",
    "_Complex",
    "_Imaginary",
    "_Decimal32",
    "_Decimal64",
    "_Decimal128",
    // modifiers
    "const",
    "static",
    // aliases
    "complex",
    "bool",
    "imaginary"
  ];
  var KEYWORDS2 = {
    keyword: C_KEYWORDS,
    type: C_TYPES,
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  };
  var EXPRESSION_CONTAINS = [PREPROCESSOR, TYPES2, C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE, NUMBERS, STRINGS];
  var EXPRESSION_CONTEXT = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [{ begin: /=/, end: /;/ }, { begin: /\(/, end: /\)/ }, { beginKeywords: "new throw return else", end: /;/ }],
    keywords: KEYWORDS2,
    contains: EXPRESSION_CONTAINS.concat([{ begin: /\(/, end: /\)/, keywords: KEYWORDS2, contains: EXPRESSION_CONTAINS.concat(["self"]), relevance: 0 }]),
    relevance: 0
  };
  var FUNCTION_DECLARATION = { begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE, returnBegin: true, end: /[{;=]/, excludeEnd: true, keywords: KEYWORDS2, illegal: /[^\w\s\*&:<>.]/, contains: [
    {
      // to prevent it from being confused as the function title
      begin: DECLTYPE_AUTO_RE,
      keywords: KEYWORDS2,
      relevance: 0
    },
    { begin: FUNCTION_TITLE, returnBegin: true, contains: [hljs.inherit(TITLE_MODE2, { className: "title.function" })], relevance: 0 },
    // allow for multiple declarations, e.g.:
    // extern void f(int), g(char);
    { relevance: 0, match: /,/ },
    { className: "params", begin: /\(/, end: /\)/, keywords: KEYWORDS2, relevance: 0, contains: [
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE,
      STRINGS,
      NUMBERS,
      TYPES2,
      // Count matching parentheses.
      { begin: /\(/, end: /\)/, keywords: KEYWORDS2, relevance: 0, contains: ["self", C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE, STRINGS, NUMBERS, TYPES2] }
    ] },
    TYPES2,
    C_LINE_COMMENT_MODE2,
    hljs.C_BLOCK_COMMENT_MODE,
    PREPROCESSOR
  ] };
  return {
    name: "C",
    aliases: ["h"],
    keywords: KEYWORDS2,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: true,
    illegal: "</",
    contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, EXPRESSION_CONTAINS, [PREPROCESSOR, { begin: hljs.IDENT_RE + "::", keywords: KEYWORDS2 }, { className: "class", beginKeywords: "enum class struct union", end: /[{;:<>=]/, contains: [{ beginKeywords: "final class struct" }, hljs.TITLE_MODE] }]),
    exports: { preprocessor: PREPROCESSOR, strings: STRINGS, keywords: KEYWORDS2 }
  };
}
function cpp(hljs) {
  var regex = hljs.regex;
  var C_LINE_COMMENT_MODE2 = hljs.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] });
  var DECLTYPE_AUTO_RE = "decltype\\(auto\\)";
  var NAMESPACE_RE = "[a-zA-Z_]\\w*::";
  var TEMPLATE_ARGUMENT_RE = "<[^<>]+>";
  var FUNCTION_TYPE_RE = "(?!struct)(" + DECLTYPE_AUTO_RE + "|" + regex.optional(NAMESPACE_RE) + "[a-zA-Z_]\\w*" + regex.optional(TEMPLATE_ARGUMENT_RE) + ")";
  var CPP_PRIMITIVE_TYPES = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" };
  var CHARACTER_ESCAPES = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)";
  var STRINGS = { className: "string", variants: [{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [hljs.BACKSLASH_ESCAPE] }, { begin: "(u8?|U|L)?'(" + CHARACTER_ESCAPES + "|.)", end: "'", illegal: "." }, hljs.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ })] };
  var NUMBERS = { className: "number", variants: [{ begin: "\\b(0b[01']+)" }, { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)" }, { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }], relevance: 0 };
  var PREPROCESSOR = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, hljs.inherit(STRINGS, { className: "string" }), { className: "string", begin: /<.*?>/ }, C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE] };
  var TITLE_MODE2 = { className: "title", begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE, relevance: 0 };
  var FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + "\\s*\\(";
  var RESERVED_KEYWORDS = ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "break", "case", "catch", "class", "co_await", "co_return", "co_yield", "compl", "concept", "const_cast|10", "consteval", "constexpr", "constinit", "continue", "decltype", "default", "delete", "do", "dynamic_cast|10", "else", "enum", "explicit", "export", "extern", "false", "final", "for", "friend", "goto", "if", "import", "inline", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "override", "private", "protected", "public", "reflexpr", "register", "reinterpret_cast|10", "requires", "return", "sizeof", "static_assert", "static_cast|10", "struct", "switch", "synchronized", "template", "this", "thread_local", "throw", "transaction_safe", "transaction_safe_dynamic", "true", "try", "typedef", "typeid", "typename", "union", "using", "virtual", "volatile", "while", "xor", "xor_eq"];
  var RESERVED_TYPES = ["bool", "char", "char16_t", "char32_t", "char8_t", "double", "float", "int", "long", "short", "void", "wchar_t", "unsigned", "signed", "const", "static"];
  var TYPE_HINTS = ["any", "auto_ptr", "barrier", "binary_semaphore", "bitset", "complex", "condition_variable", "condition_variable_any", "counting_semaphore", "deque", "false_type", "future", "imaginary", "initializer_list", "istringstream", "jthread", "latch", "lock_guard", "multimap", "multiset", "mutex", "optional", "ostringstream", "packaged_task", "pair", "promise", "priority_queue", "queue", "recursive_mutex", "recursive_timed_mutex", "scoped_lock", "set", "shared_future", "shared_lock", "shared_mutex", "shared_timed_mutex", "shared_ptr", "stack", "string_view", "stringstream", "timed_mutex", "thread", "true_type", "tuple", "unique_lock", "unique_ptr", "unordered_map", "unordered_multimap", "unordered_multiset", "unordered_set", "variant", "vector", "weak_ptr", "wstring", "wstring_view"];
  var FUNCTION_HINTS = ["abort", "abs", "acos", "apply", "as_const", "asin", "atan", "atan2", "calloc", "ceil", "cerr", "cin", "clog", "cos", "cosh", "cout", "declval", "endl", "exchange", "exit", "exp", "fabs", "floor", "fmod", "forward", "fprintf", "fputs", "free", "frexp", "fscanf", "future", "invoke", "isalnum", "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "isxdigit", "labs", "launder", "ldexp", "log", "log10", "make_pair", "make_shared", "make_shared_for_overwrite", "make_tuple", "make_unique", "malloc", "memchr", "memcmp", "memcpy", "memset", "modf", "move", "pow", "printf", "putchar", "puts", "realloc", "scanf", "sin", "sinh", "snprintf", "sprintf", "sqrt", "sscanf", "std", "stderr", "stdin", "stdout", "strcat", "strchr", "strcmp", "strcpy", "strcspn", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", "strrchr", "strspn", "strstr", "swap", "tan", "tanh", "terminate", "to_underlying", "tolower", "toupper", "vfprintf", "visit", "vprintf", "vsprintf"];
  var LITERALS2 = ["NULL", "false", "nullopt", "nullptr", "true"];
  var BUILT_IN = ["_Pragma"];
  var CPP_KEYWORDS = { type: RESERVED_TYPES, keyword: RESERVED_KEYWORDS, literal: LITERALS2, built_in: BUILT_IN, _type_hints: TYPE_HINTS };
  var FUNCTION_DISPATCH = { className: "function.dispatch", relevance: 0, keywords: {
    // Only for relevance, not highlighting.
    _hint: FUNCTION_HINTS
  }, begin: regex.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, hljs.IDENT_RE, regex.lookahead(/(<[^<>]+>|)\s*\(/)) };
  var EXPRESSION_CONTAINS = [FUNCTION_DISPATCH, PREPROCESSOR, CPP_PRIMITIVE_TYPES, C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE, NUMBERS, STRINGS];
  var EXPRESSION_CONTEXT = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [{ begin: /=/, end: /;/ }, { begin: /\(/, end: /\)/ }, { beginKeywords: "new throw return else", end: /;/ }],
    keywords: CPP_KEYWORDS,
    contains: EXPRESSION_CONTAINS.concat([{ begin: /\(/, end: /\)/, keywords: CPP_KEYWORDS, contains: EXPRESSION_CONTAINS.concat(["self"]), relevance: 0 }]),
    relevance: 0
  };
  var FUNCTION_DECLARATION = { className: "function", begin: "(" + FUNCTION_TYPE_RE + "[\\*&\\s]+)+" + FUNCTION_TITLE, returnBegin: true, end: /[{;=]/, excludeEnd: true, keywords: CPP_KEYWORDS, illegal: /[^\w\s\*&:<>.]/, contains: [
    {
      // to prevent it from being confused as the function title
      begin: DECLTYPE_AUTO_RE,
      keywords: CPP_KEYWORDS,
      relevance: 0
    },
    { begin: FUNCTION_TITLE, returnBegin: true, contains: [TITLE_MODE2], relevance: 0 },
    // needed because we do not have look-behind on the below rule
    // to prevent it from grabbing the final : in a :: pair
    { begin: /::/, relevance: 0 },
    // initializers
    { begin: /:/, endsWithParent: true, contains: [STRINGS, NUMBERS] },
    // allow for multiple declarations, e.g.:
    // extern void f(int), g(char);
    { relevance: 0, match: /,/ },
    { className: "params", begin: /\(/, end: /\)/, keywords: CPP_KEYWORDS, relevance: 0, contains: [
      C_LINE_COMMENT_MODE2,
      hljs.C_BLOCK_COMMENT_MODE,
      STRINGS,
      NUMBERS,
      CPP_PRIMITIVE_TYPES,
      // Count matching parentheses.
      { begin: /\(/, end: /\)/, keywords: CPP_KEYWORDS, relevance: 0, contains: ["self", C_LINE_COMMENT_MODE2, hljs.C_BLOCK_COMMENT_MODE, STRINGS, NUMBERS, CPP_PRIMITIVE_TYPES] }
    ] },
    CPP_PRIMITIVE_TYPES,
    C_LINE_COMMENT_MODE2,
    hljs.C_BLOCK_COMMENT_MODE,
    PREPROCESSOR
  ] };
  return { name: "C++", aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"], keywords: CPP_KEYWORDS, illegal: "</", classNameAliases: { "function.dispatch": "built_in" }, contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, FUNCTION_DISPATCH, EXPRESSION_CONTAINS, [PREPROCESSOR, {
    // containers: ie, `vector <int> rooms (9);`
    begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
    end: ">",
    keywords: CPP_KEYWORDS,
    contains: ["self", CPP_PRIMITIVE_TYPES]
  }, { begin: hljs.IDENT_RE + "::", keywords: CPP_KEYWORDS }, { match: [
    // extra complexity to deal with `enum class` and `enum struct`
    /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
    /\s+/,
    /\w+/
  ], className: { 1: "keyword", 3: "title.class" } }]) };
}
function csharp(hljs) {
  var BUILT_IN_KEYWORDS = ["bool", "byte", "char", "decimal", "delegate", "double", "dynamic", "enum", "float", "int", "long", "nint", "nuint", "object", "sbyte", "short", "string", "ulong", "uint", "ushort"];
  var FUNCTION_MODIFIERS = ["public", "private", "protected", "static", "internal", "protected", "abstract", "async", "extern", "override", "unsafe", "virtual", "new", "sealed", "partial"];
  var LITERAL_KEYWORDS = ["default", "false", "null", "true"];
  var NORMAL_KEYWORDS = ["abstract", "as", "base", "break", "case", "catch", "class", "const", "continue", "do", "else", "event", "explicit", "extern", "finally", "fixed", "for", "foreach", "goto", "if", "implicit", "in", "interface", "internal", "is", "lock", "namespace", "new", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "record", "ref", "return", "scoped", "sealed", "sizeof", "stackalloc", "static", "struct", "switch", "this", "throw", "try", "typeof", "unchecked", "unsafe", "using", "virtual", "void", "volatile", "while"];
  var CONTEXTUAL_KEYWORDS = ["add", "alias", "and", "ascending", "async", "await", "by", "descending", "equals", "from", "get", "global", "group", "init", "into", "join", "let", "nameof", "not", "notnull", "on", "or", "orderby", "partial", "remove", "select", "set", "unmanaged", "value|0", "var", "when", "where", "with", "yield"];
  var KEYWORDS2 = { keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS), built_in: BUILT_IN_KEYWORDS, literal: LITERAL_KEYWORDS };
  var TITLE_MODE2 = hljs.inherit(hljs.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" });
  var NUMBERS = { className: "number", variants: [{ begin: "\\b(0b[01']+)" }, { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" }, { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }], relevance: 0 };
  var VERBATIM_STRING = { className: "string", begin: '@"', end: '"', contains: [{ begin: '""' }] };
  var VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, { illegal: /\n/ });
  var SUBST = { className: "subst", begin: /\{/, end: /\}/, keywords: KEYWORDS2 };
  var SUBST_NO_LF = hljs.inherit(SUBST, { illegal: /\n/ });
  var INTERPOLATED_STRING = { className: "string", begin: /\$"/, end: '"', illegal: /\n/, contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, hljs.BACKSLASH_ESCAPE, SUBST_NO_LF] };
  var INTERPOLATED_VERBATIM_STRING = { className: "string", begin: /\$@"/, end: '"', contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, SUBST] };
  var INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, { illegal: /\n/, contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, SUBST_NO_LF] });
  SUBST.contains = [INTERPOLATED_VERBATIM_STRING, INTERPOLATED_STRING, VERBATIM_STRING, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, NUMBERS, hljs.C_BLOCK_COMMENT_MODE];
  SUBST_NO_LF.contains = [INTERPOLATED_VERBATIM_STRING_NO_LF, INTERPOLATED_STRING, VERBATIM_STRING_NO_LF, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, NUMBERS, hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })];
  var STRING = { variants: [INTERPOLATED_VERBATIM_STRING, INTERPOLATED_STRING, VERBATIM_STRING, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE] };
  var GENERIC_MODIFIER = { begin: "<", end: ">", contains: [{ beginKeywords: "in out" }, TITLE_MODE2] };
  var TYPE_IDENT_RE = hljs.IDENT_RE + "(<" + hljs.IDENT_RE + "(\\s*,\\s*" + hljs.IDENT_RE + ")*>)?(\\[\\])?";
  var AT_IDENTIFIER = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + hljs.IDENT_RE,
    relevance: 0
  };
  return { name: "C#", aliases: ["cs", "c#"], keywords: KEYWORDS2, illegal: /::/, contains: [hljs.COMMENT("///", "$", { returnBegin: true, contains: [{ className: "doctag", variants: [{ begin: "///", relevance: 0 }, { begin: "<!--|-->" }, { begin: "</?", end: ">" }] }] }), hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, { className: "meta", begin: "#", end: "$", keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" } }, STRING, NUMBERS, { beginKeywords: "class interface", relevance: 0, end: /[{;=]/, illegal: /[^\s:,]/, contains: [{ beginKeywords: "where class" }, TITLE_MODE2, GENERIC_MODIFIER, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE] }, { beginKeywords: "namespace", relevance: 0, end: /[{;=]/, illegal: /[^\s:]/, contains: [TITLE_MODE2, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE] }, { beginKeywords: "record", relevance: 0, end: /[{;=]/, illegal: /[^\s:]/, contains: [TITLE_MODE2, GENERIC_MODIFIER, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE] }, {
    // [Attributes("")]
    className: "meta",
    begin: "^\\s*\\[(?=[\\w])",
    excludeBegin: true,
    end: "\\]",
    excludeEnd: true,
    contains: [{ className: "string", begin: /"/, end: /"/ }]
  }, {
    // Expression keywords prevent 'keyword Name(...)' from being
    // recognized as a function definition
    beginKeywords: "new return throw await else",
    relevance: 0
  }, { className: "function", begin: "(" + TYPE_IDENT_RE + "\\s+)+" + hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(", returnBegin: true, end: /\s*[{;=]/, excludeEnd: true, keywords: KEYWORDS2, contains: [
    // prevents these from being highlighted `title`
    { beginKeywords: FUNCTION_MODIFIERS.join(" "), relevance: 0 },
    { begin: hljs.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(", returnBegin: true, contains: [hljs.TITLE_MODE, GENERIC_MODIFIER], relevance: 0 },
    { match: /\(\)/ },
    { className: "params", begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: KEYWORDS2, relevance: 0, contains: [STRING, NUMBERS, hljs.C_BLOCK_COMMENT_MODE] },
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE
  ] }, AT_IDENTIFIER] };
}
var MODES$3 = function MODES$32(hljs) {
  return { IMPORTANT: { scope: "meta", begin: "!important" }, BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE, HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ }, FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ }, ATTRIBUTE_SELECTOR_MODE: { scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$", contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE] }, CSS_NUMBER_MODE: { scope: "number", begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", relevance: 0 }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z][A-Za-z0-9_-]*/ } };
};
var TAGS$2 = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"];
var MEDIA_FEATURES$2 = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
var PSEUDO_CLASSES$2 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
];
var PSEUDO_ELEMENTS$2 = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"];
var ATTRIBUTES$2 = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function css(hljs) {
  var regex = hljs.regex;
  var modes = MODES$3(hljs);
  var VENDOR_PREFIX = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ };
  var AT_MODIFIERS = "and or not only";
  var AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
  var IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  var STRINGS = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE];
  return { name: "CSS", case_insensitive: true, illegal: /[=|'\$]/, keywords: { keyframePosition: "from to" }, classNameAliases: {
    // for visual continuity with `tag {}` and because we
    // don't have a great class for this?
    keyframePosition: "selector-tag"
  }, contains: [
    modes.BLOCK_COMMENT,
    VENDOR_PREFIX,
    // to recognize keyframe 40% etc which are outside the scope of our
    // attribute value mode
    modes.CSS_NUMBER_MODE,
    { className: "selector-id", begin: /#[A-Za-z0-9_-]+/, relevance: 0 },
    { className: "selector-class", begin: "\\." + IDENT_RE2, relevance: 0 },
    modes.ATTRIBUTE_SELECTOR_MODE,
    { className: "selector-pseudo", variants: [{ begin: ":(" + PSEUDO_CLASSES$2.join("|") + ")" }, { begin: ":(:)?(" + PSEUDO_ELEMENTS$2.join("|") + ")" }] },
    // we may actually need this (12/2020)
    // { // pseudo-selector params
    //   begin: /\(/,
    //   end: /\)/,
    //   contains: [ hljs.CSS_NUMBER_MODE ]
    // },
    modes.CSS_VARIABLE,
    { className: "attribute", begin: "\\b(" + ATTRIBUTES$2.join("|") + ")\\b" },
    // attribute values
    { begin: /:/, end: /[;}{]/, contains: [modes.BLOCK_COMMENT, modes.HEXCOLOR, modes.IMPORTANT, modes.CSS_NUMBER_MODE].concat(STRINGS, [
      // needed to highlight these as strings and to avoid issues with
      // illegal characters that might be inside urls that would tigger the
      // languages illegal stack
      {
        begin: /(url|data-uri)\(/,
        end: /\)/,
        relevance: 0,
        // from keywords
        keywords: { built_in: "url data-uri" },
        contains: [].concat(STRINGS, [{
          className: "string",
          // any character other than `)` as in `url()` will be the start
          // of a string, which ends with `)` (from the parent mode)
          begin: /[^)]/,
          endsWithParent: true,
          excludeEnd: true
        }])
      },
      modes.FUNCTION_DISPATCH
    ]) },
    {
      begin: regex.lookahead(/@/),
      end: "[{;]",
      relevance: 0,
      illegal: /:/,
      // break on Less variables @var: ...
      contains: [{ className: "keyword", begin: AT_PROPERTY_RE }, { begin: /\s/, endsWithParent: true, excludeEnd: true, relevance: 0, keywords: { $pattern: /[a-z-]+/, keyword: AT_MODIFIERS, attribute: MEDIA_FEATURES$2.join(" ") }, contains: [{ begin: /[a-z-]+(?=:)/, className: "attribute" }].concat(STRINGS, [modes.CSS_NUMBER_MODE]) }]
    },
    { className: "selector-tag", begin: "\\b(" + TAGS$2.join("|") + ")\\b" }
  ] };
}
function diff(hljs) {
  var regex = hljs.regex;
  return { name: "Diff", aliases: ["patch"], contains: [{ className: "meta", relevance: 10, match: regex.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/) }, { className: "comment", variants: [{ begin: regex.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/), end: /$/ }, { match: /^\*{15}$/ }] }, { className: "addition", begin: /^\+/, end: /$/ }, { className: "deletion", begin: /^-/, end: /$/ }, { className: "addition", begin: /^!/, end: /$/ }] };
}
function go2(hljs) {
  var LITERALS2 = ["true", "false", "iota", "nil"];
  var BUILT_INS2 = ["append", "cap", "close", "complex", "copy", "imag", "len", "make", "new", "panic", "print", "println", "real", "recover", "delete"];
  var TYPES2 = ["bool", "byte", "complex64", "complex128", "error", "float32", "float64", "int8", "int16", "int32", "int64", "string", "uint8", "uint16", "uint32", "uint64", "int", "uint", "uintptr", "rune"];
  var KWS = ["break", "case", "chan", "const", "continue", "default", "defer", "else", "fallthrough", "for", "func", "go", "goto", "if", "import", "interface", "map", "package", "range", "return", "select", "struct", "switch", "type", "var"];
  var KEYWORDS2 = { keyword: KWS, type: TYPES2, literal: LITERALS2, built_in: BUILT_INS2 };
  return { name: "Go", aliases: ["golang"], keywords: KEYWORDS2, illegal: "</", contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, { className: "string", variants: [hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, { begin: "`", end: "`" }] }, { className: "number", variants: [{ begin: hljs.C_NUMBER_RE + "[i]", relevance: 1 }, hljs.C_NUMBER_MODE] }, {
    begin: /:=/
    // relevance booster
  }, { className: "function", beginKeywords: "func", end: "\\s*(\\{|$)", excludeEnd: true, contains: [hljs.TITLE_MODE, { className: "params", begin: /\(/, end: /\)/, endsParent: true, keywords: KEYWORDS2, illegal: /["']/ }] }] };
}
function graphql(hljs) {
  var regex = hljs.regex;
  var GQL_NAME = /[_A-Za-z][_0-9A-Za-z]*/;
  return { name: "GraphQL", aliases: ["gql"], case_insensitive: true, disableAutodetect: false, keywords: { keyword: ["query", "mutation", "subscription", "type", "input", "schema", "directive", "interface", "union", "scalar", "fragment", "enum", "on"], literal: ["true", "false", "null"] }, contains: [hljs.HASH_COMMENT_MODE, hljs.QUOTE_STRING_MODE, hljs.NUMBER_MODE, { scope: "punctuation", match: /[.]{3}/, relevance: 0 }, { scope: "punctuation", begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/, relevance: 0 }, { scope: "variable", begin: /\$/, end: /\W/, excludeEnd: true, relevance: 0 }, { scope: "meta", match: /@\w+/, excludeEnd: true }, { scope: "symbol", begin: regex.concat(GQL_NAME, regex.lookahead(/\s*:/)), relevance: 0 }], illegal: [/[;<']/, /BEGIN/] };
}
function ini(hljs) {
  var regex = hljs.regex;
  var NUMBERS = { className: "number", relevance: 0, variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, { begin: hljs.NUMBER_RE }] };
  var COMMENTS = hljs.COMMENT();
  COMMENTS.variants = [{ begin: /;/, end: /$/ }, { begin: /#/, end: /$/ }];
  var VARIABLES = { className: "variable", variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }] };
  var LITERALS2 = { className: "literal", begin: /\bon|off|true|false|yes|no\b/ };
  var STRINGS = { className: "string", contains: [hljs.BACKSLASH_ESCAPE], variants: [{ begin: "'''", end: "'''", relevance: 10 }, { begin: '"""', end: '"""', relevance: 10 }, { begin: '"', end: '"' }, { begin: "'", end: "'" }] };
  var ARRAY = { begin: /\[/, end: /\]/, contains: [COMMENTS, LITERALS2, VARIABLES, STRINGS, NUMBERS, "self"], relevance: 0 };
  var BARE_KEY = /[A-Za-z0-9_-]+/;
  var QUOTED_KEY_DOUBLE_QUOTE = /"(\\"|[^"])*"/;
  var QUOTED_KEY_SINGLE_QUOTE = /'[^']*'/;
  var ANY_KEY = regex.either(BARE_KEY, QUOTED_KEY_DOUBLE_QUOTE, QUOTED_KEY_SINGLE_QUOTE);
  var DOTTED_KEY = regex.concat(ANY_KEY, "(\\s*\\.\\s*", ANY_KEY, ")*", regex.lookahead(/\s*=\s*[^#\s]/));
  return { name: "TOML, also INI", aliases: ["toml"], case_insensitive: true, illegal: /\S/, contains: [COMMENTS, { className: "section", begin: /\[+/, end: /\]+/ }, { begin: DOTTED_KEY, className: "attr", starts: { end: /$/, contains: [COMMENTS, ARRAY, LITERALS2, VARIABLES, STRINGS, NUMBERS] } }] };
}
var decimalDigits$1 = "[0-9](_*[0-9])*";
var frac$1 = "\\.(" + decimalDigits$1 + ")";
var hexDigits$1 = "[0-9a-fA-F](_*[0-9a-fA-F])*";
var NUMERIC$1 = { className: "number", variants: [
  // DecimalFloatingPointLiteral
  // including ExponentPart
  { begin: "(\\b(" + decimalDigits$1 + ")((" + frac$1 + ")|\\.)?|(" + frac$1 + "))" + ("[eE][+-]?(" + decimalDigits$1 + ")[fFdD]?\\b") },
  // excluding ExponentPart
  { begin: "\\b(" + decimalDigits$1 + ")((" + frac$1 + ")[fFdD]?\\b|\\.([fFdD]\\b)?)" },
  { begin: "(" + frac$1 + ")[fFdD]?\\b" },
  { begin: "\\b(" + decimalDigits$1 + ")[fFdD]\\b" },
  // HexadecimalFloatingPointLiteral
  { begin: "\\b0[xX]((" + hexDigits$1 + ")\\.?|(" + hexDigits$1 + ")?\\.(" + hexDigits$1 + "))" + ("[pP][+-]?(" + decimalDigits$1 + ")[fFdD]?\\b") },
  // DecimalIntegerLiteral
  { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
  // HexIntegerLiteral
  { begin: "\\b0[xX](" + hexDigits$1 + ")[lL]?\\b" },
  // OctalIntegerLiteral
  { begin: "\\b0(_*[0-7])*[lL]?\\b" },
  // BinaryIntegerLiteral
  { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
], relevance: 0 };
function recurRegex(re, substitution, depth) {
  if (depth === -1)
    return "";
  return re.replace(substitution, function(_) {
    return recurRegex(re, substitution, depth - 1);
  });
}
function java(hljs) {
  var regex = hljs.regex;
  var JAVA_IDENT_RE = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*";
  var GENERIC_IDENT_RE = JAVA_IDENT_RE + recurRegex("(?:<" + JAVA_IDENT_RE + "~~~(?:\\s*,\\s*" + JAVA_IDENT_RE + "~~~)*>)?", /~~~/g, 2);
  var MAIN_KEYWORDS = ["synchronized", "abstract", "private", "var", "static", "if", "const ", "for", "while", "strictfp", "finally", "protected", "import", "native", "final", "void", "enum", "else", "break", "transient", "catch", "instanceof", "volatile", "case", "assert", "package", "default", "public", "try", "switch", "continue", "throws", "protected", "public", "private", "module", "requires", "exports", "do", "sealed", "yield", "permits"];
  var BUILT_INS2 = ["super", "this"];
  var LITERALS2 = ["false", "true", "null"];
  var TYPES2 = ["char", "boolean", "long", "float", "int", "byte", "short", "double"];
  var KEYWORDS2 = { keyword: MAIN_KEYWORDS, literal: LITERALS2, type: TYPES2, built_in: BUILT_INS2 };
  var ANNOTATION = { className: "meta", begin: "@" + JAVA_IDENT_RE, contains: [{
    begin: /\(/,
    end: /\)/,
    contains: ["self"]
    // allow nested () inside our annotation
  }] };
  var PARAMS = { className: "params", begin: /\(/, end: /\)/, keywords: KEYWORDS2, relevance: 0, contains: [hljs.C_BLOCK_COMMENT_MODE], endsParent: true };
  return { name: "Java", aliases: ["jsp"], keywords: KEYWORDS2, illegal: /<\/|#/, contains: [
    hljs.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{
      // eat up @'s in emails to prevent them to be recognized as doctags
      begin: /\w+@/,
      relevance: 0
    }, { className: "doctag", begin: "@[A-Za-z]+" }] }),
    // relevance boost
    { begin: /import java\.[a-z]+\./, keywords: "import", relevance: 2 },
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    { begin: /"""/, end: /"""/, className: "string", contains: [hljs.BACKSLASH_ESCAPE] },
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    { match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, JAVA_IDENT_RE], className: { 1: "keyword", 3: "title.class" } },
    {
      // Exceptions for hyphenated keywords
      match: /non-sealed/,
      scope: "keyword"
    },
    { begin: [regex.concat(/(?!else)/, JAVA_IDENT_RE), /\s+/, JAVA_IDENT_RE, /\s+/, /=(?!=)/], className: { 1: "type", 3: "variable", 5: "operator" } },
    { begin: [/record/, /\s+/, JAVA_IDENT_RE], className: { 1: "keyword", 3: "title.class" }, contains: [PARAMS, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE] },
    {
      // Expression keywords prevent 'keyword Name(...)' from being
      // recognized as a function definition
      beginKeywords: "new throw return else",
      relevance: 0
    },
    { begin: ["(?:" + GENERIC_IDENT_RE + "\\s+)", hljs.UNDERSCORE_IDENT_RE, /\s*(?=\()/], className: { 2: "title.function" }, keywords: KEYWORDS2, contains: [{ className: "params", begin: /\(/, end: /\)/, keywords: KEYWORDS2, relevance: 0, contains: [ANNOTATION, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, NUMERIC$1, hljs.C_BLOCK_COMMENT_MODE] }, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE] },
    NUMERIC$1,
    ANNOTATION
  ] };
}
var IDENT_RE$2 = "[A-Za-z$_][0-9A-Za-z$_]*";
var KEYWORDS$1 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
var LITERALS$1 = ["true", "false", "null", "undefined", "NaN", "Infinity"];
var TYPES$1 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
var ERROR_TYPES$1 = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"];
var BUILT_IN_GLOBALS$1 = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"];
var BUILT_IN_VARIABLES$1 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
var BUILT_INS$1 = [].concat(BUILT_IN_GLOBALS$1, TYPES$1, ERROR_TYPES$1);
function javascript$1(hljs) {
  var regex = hljs.regex;
  var hasClosingTag = function hasClosingTag2(match, _ref248) {
    var after = _ref248.after;
    var tag = "</" + match[0].slice(1);
    var pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  var IDENT_RE$12 = IDENT_RE$2;
  var FRAGMENT = { begin: "<>", end: "</>" };
  var XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  var XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
    * @param {RegExpMatchArray} match
    * @param {CallbackResponse} response
    */
    isTrulyOpeningTag: function isTrulyOpeningTag(match, response) {
      var afterMatchIndex = match[0].length + match.index;
      var nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      var m;
      var afterMatch = match.input.substring(afterMatchIndex);
      if (m = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m = afterMatch.match(/^\s+extends\s+/)) {
        if (m.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  var KEYWORDS$1$1 = { $pattern: IDENT_RE$2, keyword: KEYWORDS$1, literal: LITERALS$1, built_in: BUILT_INS$1, "variable.language": BUILT_IN_VARIABLES$1 };
  var decimalDigits2 = "[0-9](_?[0-9])*";
  var frac2 = "\\.(" + decimalDigits2 + ")";
  var decimalInteger = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*";
  var NUMBER = { className: "number", variants: [
    // DecimalLiteral
    { begin: "(\\b(" + decimalInteger + ")((" + frac2 + ")|\\.)?|(" + frac2 + "))" + ("[eE][+-]?(" + decimalDigits2 + ")\\b") },
    { begin: "\\b(" + decimalInteger + ")\\b((" + frac2 + ")\\b|\\.)?|(" + frac2 + ")\\b" },
    // DecimalBigIntegerLiteral
    { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
    // NonDecimalIntegerLiteral
    { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
    { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
    { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
    // LegacyOctalIntegerLiteral (does not include underscore separators)
    // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
    { begin: "\\b0[0-7]+n?\\b" }
  ], relevance: 0 };
  var SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1$1,
    contains: []
    // defined later
  };
  var HTML_TEMPLATE = { begin: "html`", end: "", starts: { end: "`", returnEnd: false, contains: [hljs.BACKSLASH_ESCAPE, SUBST], subLanguage: "xml" } };
  var CSS_TEMPLATE = { begin: "css`", end: "", starts: { end: "`", returnEnd: false, contains: [hljs.BACKSLASH_ESCAPE, SUBST], subLanguage: "css" } };
  var GRAPHQL_TEMPLATE = { begin: "gql`", end: "", starts: { end: "`", returnEnd: false, contains: [hljs.BACKSLASH_ESCAPE, SUBST], subLanguage: "graphql" } };
  var TEMPLATE_STRING = { className: "string", begin: "`", end: "`", contains: [hljs.BACKSLASH_ESCAPE, SUBST] };
  var JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", { relevance: 0, contains: [{ begin: "(?=@[A-Za-z]+)", relevance: 0, contains: [
    { className: "doctag", begin: "@[A-Za-z]+" },
    { className: "type", begin: "\\{", end: "\\}", excludeEnd: true, excludeBegin: true, relevance: 0 },
    { className: "variable", begin: IDENT_RE$12 + "(?=\\s*(-)|$)", endsParent: true, relevance: 0 },
    // eat spaces (not newlines) so we can find
    // types or variables
    { begin: /(?=[^\n])\s/, relevance: 0 }
  ] }] });
  var COMMENT3 = { className: "comment", variants: [JSDOC_COMMENT, hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE] };
  var SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1$1,
    contains: ["self"].concat(SUBST_INTERNALS)
  });
  var SUBST_AND_COMMENTS = [].concat(COMMENT3, SUBST.contains);
  var PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    { begin: /\(/, end: /\)/, keywords: KEYWORDS$1$1, contains: ["self"].concat(SUBST_AND_COMMENTS) }
  ]);
  var PARAMS = { className: "params", begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: KEYWORDS$1$1, contains: PARAMS_CONTAINS };
  var CLASS_OR_EXTENDS = { variants: [
    // class Car extends vehicle
    { match: [/class/, /\s+/, IDENT_RE$12, /\s+/, /extends/, /\s+/, regex.concat(IDENT_RE$12, "(", regex.concat(/\./, IDENT_RE$12), ")*")], scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" } },
    // class Car
    { match: [/class/, /\s+/, IDENT_RE$12], scope: { 1: "keyword", 3: "title.class" } }
  ] };
  var CLASS_REFERENCE = { relevance: 0, match: regex.either(
    // Hard coded exceptions
    /\bJSON/,
    // Float32Array, OutT
    /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
    // CSSFactory, CSSFactoryT
    /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
    // FPs, FPsT
    /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
    // P
    // single letters are not highlighted
    // BLAH
    // this will be flagged as a UPPER_CASE_CONSTANT instead
  ), className: "title.class", keywords: { _: [].concat(TYPES$1, ERROR_TYPES$1) } };
  var USE_STRICT = { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ };
  var FUNCTION_DEFINITION = { variants: [
    { match: [/function/, /\s+/, IDENT_RE$12, /(?=\s*\()/] },
    // anonymous function
    { match: [/function/, /\s*(?=\()/] }
  ], className: { 1: "keyword", 3: "title.function" }, label: "func.def", contains: [PARAMS], illegal: /%/ };
  var UPPER_CASE_CONSTANT = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  var FUNCTION_CALL = { match: regex.concat(/\b/, noneOf([].concat(BUILT_IN_GLOBALS$1, ["super", "import"])), IDENT_RE$12, regex.lookahead(/\(/)), className: "title.function", relevance: 0 };
  var PROPERTY_ACCESS = { begin: regex.concat(/\./, regex.lookahead(regex.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/))), end: IDENT_RE$12, excludeBegin: true, keywords: "prototype", className: "property", relevance: 0 };
  var GETTER_OR_SETTER = { match: [/get|set/, /\s+/, IDENT_RE$12, /(?=\()/], className: { 1: "keyword", 3: "title.function" }, contains: [{
    // eat to avoid empty params
    begin: /\(\)/
  }, PARAMS] };
  var FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  var FUNCTION_VARIABLE = { match: [
    /const|var|let/,
    /\s+/,
    IDENT_RE$12,
    /\s*/,
    /=\s*/,
    /(async\s*)?/,
    // async is optional
    regex.lookahead(FUNC_LEAD_IN_RE)
  ], keywords: "async", className: { 1: "keyword", 3: "title.function" }, contains: [PARAMS] };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT3,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      { className: "attr", begin: IDENT_RE$12 + regex.lookahead(":"), relevance: 0 },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [COMMENT3, hljs.REGEXP_MODE, {
          className: "function",
          // we have to count the parens to make sure we actually have the
          // correct bounding ( ) before the =>.  There could be any number of
          // sub-expressions inside also surrounded by parens.
          begin: FUNC_LEAD_IN_RE,
          returnBegin: true,
          end: "\\s*=>",
          contains: [{ className: "params", variants: [{ begin: hljs.UNDERSCORE_IDENT_RE, relevance: 0 }, { className: null, begin: /\(\s*\)/, skip: true }, { begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: KEYWORDS$1$1, contains: PARAMS_CONTAINS }] }]
        }, {
          // could be a comma delimited list of params to a function call
          begin: /,/,
          relevance: 0
        }, { match: /\s+/, relevance: 0 }, {
          // JSX
          variants: [{ begin: FRAGMENT.begin, end: FRAGMENT.end }, { match: XML_SELF_CLOSING }, {
            begin: XML_TAG.begin,
            // we carefully check the opening tag to see if it truly
            // is a tag and not a false positive
            "on:begin": XML_TAG.isTrulyOpeningTag,
            end: XML_TAG.end
          }],
          subLanguage: "xml",
          contains: [{ begin: XML_TAG.begin, end: XML_TAG.end, skip: true, contains: ["self"] }]
        }]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [PARAMS, hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: "title.function" })]
      },
      // catch ... so it won't trigger the property rule below
      { match: /\.\.\./, relevance: 0 },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      { match: "\\$" + IDENT_RE$12, relevance: 0 },
      { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [PARAMS] },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function json(hljs) {
  var ATTRIBUTE = { className: "attr", begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/, relevance: 1.01 };
  var PUNCTUATION = { match: /[{}[\],:]/, className: "punctuation", relevance: 0 };
  var LITERALS2 = ["true", "false", "null"];
  var LITERALS_MODE = { scope: "literal", beginKeywords: LITERALS2.join(" ") };
  return { name: "JSON", keywords: { literal: LITERALS2 }, contains: [ATTRIBUTE, PUNCTUATION, hljs.QUOTE_STRING_MODE, LITERALS_MODE, hljs.C_NUMBER_MODE, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE], illegal: "\\S" };
}
var decimalDigits = "[0-9](_*[0-9])*";
var frac = "\\.(" + decimalDigits + ")";
var hexDigits = "[0-9a-fA-F](_*[0-9a-fA-F])*";
var NUMERIC = { className: "number", variants: [
  // DecimalFloatingPointLiteral
  // including ExponentPart
  { begin: "(\\b(" + decimalDigits + ")((" + frac + ")|\\.)?|(" + frac + "))" + ("[eE][+-]?(" + decimalDigits + ")[fFdD]?\\b") },
  // excluding ExponentPart
  { begin: "\\b(" + decimalDigits + ")((" + frac + ")[fFdD]?\\b|\\.([fFdD]\\b)?)" },
  { begin: "(" + frac + ")[fFdD]?\\b" },
  { begin: "\\b(" + decimalDigits + ")[fFdD]\\b" },
  // HexadecimalFloatingPointLiteral
  { begin: "\\b0[xX]((" + hexDigits + ")\\.?|(" + hexDigits + ")?\\.(" + hexDigits + "))" + ("[pP][+-]?(" + decimalDigits + ")[fFdD]?\\b") },
  // DecimalIntegerLiteral
  { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
  // HexIntegerLiteral
  { begin: "\\b0[xX](" + hexDigits + ")[lL]?\\b" },
  // OctalIntegerLiteral
  { begin: "\\b0(_*[0-7])*[lL]?\\b" },
  // BinaryIntegerLiteral
  { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
], relevance: 0 };
function kotlin(hljs) {
  var KEYWORDS2 = { keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual", built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing", literal: "true false null" };
  var KEYWORDS_WITH_LABEL = { className: "keyword", begin: /\b(break|continue|return|this)\b/, starts: { contains: [{ className: "symbol", begin: /@\w+/ }] } };
  var LABEL = { className: "symbol", begin: hljs.UNDERSCORE_IDENT_RE + "@" };
  var SUBST = { className: "subst", begin: /\$\{/, end: /\}/, contains: [hljs.C_NUMBER_MODE] };
  var VARIABLE = { className: "variable", begin: "\\$" + hljs.UNDERSCORE_IDENT_RE };
  var STRING = { className: "string", variants: [
    { begin: '"""', end: '"""(?=[^"])', contains: [VARIABLE, SUBST] },
    // Can't use built-in modes easily, as we want to use STRING in the meta
    // context as 'meta-string' and there's no syntax to remove explicitly set
    // classNames in built-in modes.
    { begin: "'", end: "'", illegal: /\n/, contains: [hljs.BACKSLASH_ESCAPE] },
    { begin: '"', end: '"', illegal: /\n/, contains: [hljs.BACKSLASH_ESCAPE, VARIABLE, SUBST] }
  ] };
  SUBST.contains.push(STRING);
  var ANNOTATION_USE_SITE = { className: "meta", begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + hljs.UNDERSCORE_IDENT_RE + ")?" };
  var ANNOTATION = { className: "meta", begin: "@" + hljs.UNDERSCORE_IDENT_RE, contains: [{ begin: /\(/, end: /\)/, contains: [hljs.inherit(STRING, { className: "string" }), "self"] }] };
  var KOTLIN_NUMBER_MODE = NUMERIC;
  var KOTLIN_NESTED_COMMENT = hljs.COMMENT("/\\*", "\\*/", { contains: [hljs.C_BLOCK_COMMENT_MODE] });
  var KOTLIN_PAREN_TYPE = { variants: [{ className: "type", begin: hljs.UNDERSCORE_IDENT_RE }, {
    begin: /\(/,
    end: /\)/,
    contains: []
    // defined later
  }] };
  var KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
  KOTLIN_PAREN_TYPE2.variants[1].contains = [KOTLIN_PAREN_TYPE];
  KOTLIN_PAREN_TYPE.variants[1].contains = [KOTLIN_PAREN_TYPE2];
  return { name: "Kotlin", aliases: ["kt", "kts"], keywords: KEYWORDS2, contains: [hljs.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{ className: "doctag", begin: "@[A-Za-z]+" }] }), hljs.C_LINE_COMMENT_MODE, KOTLIN_NESTED_COMMENT, KEYWORDS_WITH_LABEL, LABEL, ANNOTATION_USE_SITE, ANNOTATION, { className: "function", beginKeywords: "fun", end: "[(]|$", returnBegin: true, excludeEnd: true, keywords: KEYWORDS2, relevance: 5, contains: [{ begin: hljs.UNDERSCORE_IDENT_RE + "\\s*\\(", returnBegin: true, relevance: 0, contains: [hljs.UNDERSCORE_TITLE_MODE] }, { className: "type", begin: /</, end: />/, keywords: "reified", relevance: 0 }, { className: "params", begin: /\(/, end: /\)/, endsParent: true, keywords: KEYWORDS2, relevance: 0, contains: [{ begin: /:/, end: /[=,\/]/, endsWithParent: true, contains: [KOTLIN_PAREN_TYPE, hljs.C_LINE_COMMENT_MODE, KOTLIN_NESTED_COMMENT], relevance: 0 }, hljs.C_LINE_COMMENT_MODE, KOTLIN_NESTED_COMMENT, ANNOTATION_USE_SITE, ANNOTATION, STRING, hljs.C_NUMBER_MODE] }, KOTLIN_NESTED_COMMENT] }, { begin: [/class|interface|trait/, /\s+/, hljs.UNDERSCORE_IDENT_RE], beginScope: { 3: "title.class" }, keywords: "class interface trait", end: /[:\{(]|$/, excludeEnd: true, illegal: "extends implements", contains: [{ beginKeywords: "public protected internal private constructor" }, hljs.UNDERSCORE_TITLE_MODE, { className: "type", begin: /</, end: />/, excludeBegin: true, excludeEnd: true, relevance: 0 }, { className: "type", begin: /[,:]\s*/, end: /[<\(,){\s]|$/, excludeBegin: true, returnEnd: true }, ANNOTATION_USE_SITE, ANNOTATION] }, STRING, { className: "meta", begin: "^#!/usr/bin/env", end: "$", illegal: "\n" }, KOTLIN_NUMBER_MODE] };
}
var MODES$2 = function MODES$22(hljs) {
  return { IMPORTANT: { scope: "meta", begin: "!important" }, BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE, HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ }, FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ }, ATTRIBUTE_SELECTOR_MODE: { scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$", contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE] }, CSS_NUMBER_MODE: { scope: "number", begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", relevance: 0 }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z][A-Za-z0-9_-]*/ } };
};
var TAGS$1 = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"];
var MEDIA_FEATURES$1 = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
var PSEUDO_CLASSES$1 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
];
var PSEUDO_ELEMENTS$1 = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"];
var ATTRIBUTES$1 = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
var PSEUDO_SELECTORS = PSEUDO_CLASSES$1.concat(PSEUDO_ELEMENTS$1);
function less(hljs) {
  var modes = MODES$2(hljs);
  var PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS;
  var AT_MODIFIERS = "and or not only";
  var IDENT_RE2 = "[\\w-]+";
  var INTERP_IDENT_RE = "(" + IDENT_RE2 + "|@\\{" + IDENT_RE2 + "\\})";
  var RULES = [];
  var VALUE_MODES = [];
  var STRING_MODE = function STRING_MODE2(c2) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + c2 + ".*?" + c2
    };
  };
  var IDENT_MODE = function IDENT_MODE2(name, begin, relevance) {
    return { className: name, begin, relevance };
  };
  var AT_KEYWORDS = { $pattern: /[a-z-]+/, keyword: AT_MODIFIERS, attribute: MEDIA_FEATURES$1.join(" ") };
  var PARENS_MODE = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: VALUE_MODES,
    keywords: AT_KEYWORDS,
    relevance: 0
  };
  VALUE_MODES.push(
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    STRING_MODE("'"),
    STRING_MODE('"'),
    modes.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    { begin: "(url|data-uri)\\(", starts: { className: "string", end: "[\\)\\n]", excludeEnd: true } },
    modes.HEXCOLOR,
    PARENS_MODE,
    IDENT_MODE("variable", "@@?" + IDENT_RE2, 10),
    IDENT_MODE("variable", "@\\{" + IDENT_RE2 + "\\}"),
    IDENT_MODE("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: IDENT_RE2 + "\\s*:",
      end: ":",
      returnBegin: true,
      excludeEnd: true
    },
    modes.IMPORTANT,
    { beginKeywords: "and not" },
    modes.FUNCTION_DISPATCH
  );
  var VALUE_WITH_RULESETS = VALUE_MODES.concat({ begin: /\{/, end: /\}/, contains: RULES });
  var MIXIN_GUARD_MODE = {
    beginKeywords: "when",
    endsWithParent: true,
    contains: [{ beginKeywords: "and not" }].concat(VALUE_MODES)
    // using this form to override VALUE’s 'function' match
  };
  var RULE_MODE = { begin: INTERP_IDENT_RE + "\\s*:", returnBegin: true, end: /[;}]/, relevance: 0, contains: [{ begin: /-(webkit|moz|ms|o)-/ }, modes.CSS_VARIABLE, { className: "attribute", begin: "\\b(" + ATTRIBUTES$1.join("|") + ")\\b", end: /(?=:)/, starts: { endsWithParent: true, illegal: "[<=$]", relevance: 0, contains: VALUE_MODES } }] };
  var AT_RULE_MODE = { className: "keyword", begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b", starts: { end: "[;{}]", keywords: AT_KEYWORDS, returnEnd: true, contains: VALUE_MODES, relevance: 0 } };
  var VAR_RULE_MODE = { className: "variable", variants: [
    // using more strict pattern for higher relevance to increase chances of Less detection.
    // this is *the only* Less specific statement used in most of the sources, so...
    // (we’ll still often loose to the css-parser unless there's '//' comment,
    // simply because 1 variable just can't beat 99 properties :)
    { begin: "@" + IDENT_RE2 + "\\s*:", relevance: 15 },
    { begin: "@" + IDENT_RE2 }
  ], starts: { end: "[;}]", returnEnd: true, contains: VALUE_WITH_RULESETS } };
  var SELECTOR_MODE = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [{
      begin: "[\\.#:&\\[>]",
      end: "[;{}]"
      // mixin calls end with ';'
    }, { begin: INTERP_IDENT_RE, end: /\{/ }],
    returnBegin: true,
    returnEnd: true,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      MIXIN_GUARD_MODE,
      IDENT_MODE("keyword", "all\\b"),
      IDENT_MODE("variable", "@\\{" + IDENT_RE2 + "\\}"),
      // otherwise it’s identified as tag
      { begin: "\\b(" + TAGS$1.join("|") + ")\\b", className: "selector-tag" },
      modes.CSS_NUMBER_MODE,
      IDENT_MODE("selector-tag", INTERP_IDENT_RE, 0),
      IDENT_MODE("selector-id", "#" + INTERP_IDENT_RE),
      IDENT_MODE("selector-class", "\\." + INTERP_IDENT_RE, 0),
      IDENT_MODE("selector-tag", "&", 0),
      modes.ATTRIBUTE_SELECTOR_MODE,
      { className: "selector-pseudo", begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")" },
      { className: "selector-pseudo", begin: ":(:)?(" + PSEUDO_ELEMENTS$1.join("|") + ")" },
      { begin: /\(/, end: /\)/, relevance: 0, contains: VALUE_WITH_RULESETS },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      modes.FUNCTION_DISPATCH
    ]
  };
  var PSEUDO_SELECTOR_MODE = { begin: IDENT_RE2 + ":(:)?" + ("(" + PSEUDO_SELECTORS$1.join("|") + ")"), returnBegin: true, contains: [SELECTOR_MODE] };
  RULES.push(hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, AT_RULE_MODE, VAR_RULE_MODE, PSEUDO_SELECTOR_MODE, RULE_MODE, SELECTOR_MODE, MIXIN_GUARD_MODE, modes.FUNCTION_DISPATCH);
  return { name: "Less", case_insensitive: true, illegal: `[=>'/<($"]`, contains: RULES };
}
function lua(hljs) {
  var OPENING_LONG_BRACKET = "\\[=*\\[";
  var CLOSING_LONG_BRACKET = "\\]=*\\]";
  var LONG_BRACKETS = { begin: OPENING_LONG_BRACKET, end: CLOSING_LONG_BRACKET, contains: ["self"] };
  var COMMENTS = [hljs.COMMENT("--(?!" + OPENING_LONG_BRACKET + ")", "$"), hljs.COMMENT("--" + OPENING_LONG_BRACKET, CLOSING_LONG_BRACKET, { contains: [LONG_BRACKETS], relevance: 10 })];
  return { name: "Lua", keywords: { $pattern: hljs.UNDERSCORE_IDENT_RE, literal: "true false nil", keyword: "and break do else elseif end for goto if in local not or repeat return then until while", built_in: (
    // Metatags and globals:
    "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
  ) }, contains: COMMENTS.concat([{ className: "function", beginKeywords: "function", end: "\\)", contains: [hljs.inherit(hljs.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }), { className: "params", begin: "\\(", endsWithParent: true, contains: COMMENTS }].concat(COMMENTS) }, hljs.C_NUMBER_MODE, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, { className: "string", begin: OPENING_LONG_BRACKET, end: CLOSING_LONG_BRACKET, contains: [LONG_BRACKETS], relevance: 5 }]) };
}
function makefile(hljs) {
  var VARIABLE = { className: "variable", variants: [{ begin: "\\$\\(" + hljs.UNDERSCORE_IDENT_RE + "\\)", contains: [hljs.BACKSLASH_ESCAPE] }, { begin: /\$[@%<?\^\+\*]/ }] };
  var QUOTE_STRING = { className: "string", begin: /"/, end: /"/, contains: [hljs.BACKSLASH_ESCAPE, VARIABLE] };
  var FUNC = { className: "variable", begin: /\$\([\w-]+\s/, end: /\)/, keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" }, contains: [VARIABLE] };
  var ASSIGNMENT = { begin: "^" + hljs.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" };
  var META = { className: "meta", begin: /^\.PHONY:/, end: /$/, keywords: { $pattern: /[\.\w]+/, keyword: ".PHONY" } };
  var TARGET = { className: "section", begin: /^[^\s]+:/, end: /$/, contains: [VARIABLE] };
  return { name: "Makefile", aliases: ["mk", "mak", "make"], keywords: { $pattern: /[\w-]+/, keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath" }, contains: [hljs.HASH_COMMENT_MODE, VARIABLE, QUOTE_STRING, FUNC, ASSIGNMENT, META, TARGET] };
}
function markdown(hljs) {
  var regex = hljs.regex;
  var INLINE_HTML = { begin: /<\/?[A-Za-z_]/, end: ">", subLanguage: "xml", relevance: 0 };
  var HORIZONTAL_RULE = { begin: "^[-\\*]{3,}", end: "$" };
  var CODE = { className: "code", variants: [
    // TODO: fix to allow these to work with sublanguage also
    { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
    { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
    // needed to allow markdown as a sublanguage to work
    { begin: "```", end: "```+[ ]*$" },
    { begin: "~~~", end: "~~~+[ ]*$" },
    { begin: "`.+?`" },
    {
      begin: "(?=^( {4}|\\t))",
      // use contains to gobble up multiple lines to allow the block to be whatever size
      // but only have a single open/close tag vs one per line
      contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }],
      relevance: 0
    }
  ] };
  var LIST = { className: "bullet", begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)", end: "\\s+", excludeEnd: true };
  var LINK_REFERENCE = { begin: /^\[[^\n]+\]:/, returnBegin: true, contains: [{ className: "symbol", begin: /\[/, end: /\]/, excludeBegin: true, excludeEnd: true }, { className: "link", begin: /:\s*/, end: /$/, excludeBegin: true }] };
  var URL_SCHEME = /[A-Za-z][A-Za-z0-9+.-]*/;
  var LINK = { variants: [
    // too much like nested array access in so many languages
    // to have any real relevance
    { begin: /\[.+?\]\[.*?\]/, relevance: 0 },
    // popular internet URLs
    { begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/, relevance: 2 },
    { begin: regex.concat(/\[.+?\]\(/, URL_SCHEME, /:\/\/.*?\)/), relevance: 2 },
    // relative urls
    { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
    // whatever else, lower relevance (might not be a link at all)
    { begin: /\[.*?\]\(.*?\)/, relevance: 0 }
  ], returnBegin: true, contains: [{
    // empty strings for alt or link text
    match: /\[(?=\])/
  }, { className: "string", relevance: 0, begin: "\\[", end: "\\]", excludeBegin: true, returnEnd: true }, { className: "link", relevance: 0, begin: "\\]\\(", end: "\\)", excludeBegin: true, excludeEnd: true }, { className: "symbol", relevance: 0, begin: "\\]\\[", end: "\\]", excludeBegin: true, excludeEnd: true }] };
  var BOLD = {
    className: "strong",
    contains: [],
    // defined later
    variants: [{ begin: /_{2}(?!\s)/, end: /_{2}/ }, { begin: /\*{2}(?!\s)/, end: /\*{2}/ }]
  };
  var ITALIC = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [{ begin: /\*(?![*\s])/, end: /\*/ }, { begin: /_(?![_\s])/, end: /_/, relevance: 0 }]
  };
  var BOLD_WITHOUT_ITALIC = hljs.inherit(BOLD, { contains: [] });
  var ITALIC_WITHOUT_BOLD = hljs.inherit(ITALIC, { contains: [] });
  BOLD.contains.push(ITALIC_WITHOUT_BOLD);
  ITALIC.contains.push(BOLD_WITHOUT_ITALIC);
  var CONTAINABLE = [INLINE_HTML, LINK];
  [BOLD, ITALIC, BOLD_WITHOUT_ITALIC, ITALIC_WITHOUT_BOLD].forEach(function(m) {
    m.contains = m.contains.concat(CONTAINABLE);
  });
  CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC);
  var HEADER = { className: "section", variants: [{ begin: "^#{1,6}", end: "$", contains: CONTAINABLE }, { begin: "(?=^.+?\\n[=-]{2,}$)", contains: [{ begin: "^[=-]*$" }, { begin: "^", end: "\\n", contains: CONTAINABLE }] }] };
  var BLOCKQUOTE = { className: "quote", begin: "^>\\s+", contains: CONTAINABLE, end: "$" };
  return { name: "Markdown", aliases: ["md", "mkdown", "mkd"], contains: [HEADER, INLINE_HTML, LIST, BOLD, ITALIC, BLOCKQUOTE, CODE, HORIZONTAL_RULE, LINK, LINK_REFERENCE] };
}
function objectivec(hljs) {
  var API_CLASS = { className: "built_in", begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+" };
  var IDENTIFIER_RE = /[a-zA-Z@][a-zA-Z0-9_]*/;
  var TYPES2 = ["int", "float", "char", "unsigned", "signed", "short", "long", "double", "wchar_t", "unichar", "void", "bool", "BOOL", "id|0", "_Bool"];
  var KWS = ["while", "export", "sizeof", "typedef", "const", "struct", "for", "union", "volatile", "static", "mutable", "if", "do", "return", "goto", "enum", "else", "break", "extern", "asm", "case", "default", "register", "explicit", "typename", "switch", "continue", "inline", "readonly", "assign", "readwrite", "self", "@synchronized", "id", "typeof", "nonatomic", "IBOutlet", "IBAction", "strong", "weak", "copy", "in", "out", "inout", "bycopy", "byref", "oneway", "__strong", "__weak", "__block", "__autoreleasing", "@private", "@protected", "@public", "@try", "@property", "@end", "@throw", "@catch", "@finally", "@autoreleasepool", "@synthesize", "@dynamic", "@selector", "@optional", "@required", "@encode", "@package", "@import", "@defs", "@compatibility_alias", "__bridge", "__bridge_transfer", "__bridge_retained", "__bridge_retain", "__covariant", "__contravariant", "__kindof", "_Nonnull", "_Nullable", "_Null_unspecified", "__FUNCTION__", "__PRETTY_FUNCTION__", "__attribute__", "getter", "setter", "retain", "unsafe_unretained", "nonnull", "nullable", "null_unspecified", "null_resettable", "class", "instancetype", "NS_DESIGNATED_INITIALIZER", "NS_UNAVAILABLE", "NS_REQUIRES_SUPER", "NS_RETURNS_INNER_POINTER", "NS_INLINE", "NS_AVAILABLE", "NS_DEPRECATED", "NS_ENUM", "NS_OPTIONS", "NS_SWIFT_UNAVAILABLE", "NS_ASSUME_NONNULL_BEGIN", "NS_ASSUME_NONNULL_END", "NS_REFINED_FOR_SWIFT", "NS_SWIFT_NAME", "NS_SWIFT_NOTHROW", "NS_DURING", "NS_HANDLER", "NS_ENDHANDLER", "NS_VALUERETURN", "NS_VOIDRETURN"];
  var LITERALS2 = ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"];
  var BUILT_INS2 = ["dispatch_once_t", "dispatch_queue_t", "dispatch_sync", "dispatch_async", "dispatch_once"];
  var KEYWORDS2 = { "variable.language": ["this", "super"], $pattern: IDENTIFIER_RE, keyword: KWS, literal: LITERALS2, built_in: BUILT_INS2, type: TYPES2 };
  var CLASS_KEYWORDS = { $pattern: IDENTIFIER_RE, keyword: ["@interface", "@class", "@protocol", "@implementation"] };
  return { name: "Objective-C", aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"], keywords: KEYWORDS2, illegal: "</", contains: [API_CLASS, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.C_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, { className: "string", variants: [{ begin: '@"', end: '"', illegal: "\\n", contains: [hljs.BACKSLASH_ESCAPE] }] }, { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" }), { className: "string", begin: /<.*?>/, end: /$/, illegal: "\\n" }, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE] }, { className: "class", begin: "(" + CLASS_KEYWORDS.keyword.join("|") + ")\\b", end: /(\{|$)/, excludeEnd: true, keywords: CLASS_KEYWORDS, contains: [hljs.UNDERSCORE_TITLE_MODE] }, { begin: "\\." + hljs.UNDERSCORE_IDENT_RE, relevance: 0 }] };
}
function perl(hljs) {
  var regex = hljs.regex;
  var KEYWORDS2 = ["abs", "accept", "alarm", "and", "atan2", "bind", "binmode", "bless", "break", "caller", "chdir", "chmod", "chomp", "chop", "chown", "chr", "chroot", "close", "closedir", "connect", "continue", "cos", "crypt", "dbmclose", "dbmopen", "defined", "delete", "die", "do", "dump", "each", "else", "elsif", "endgrent", "endhostent", "endnetent", "endprotoent", "endpwent", "endservent", "eof", "eval", "exec", "exists", "exit", "exp", "fcntl", "fileno", "flock", "for", "foreach", "fork", "format", "formline", "getc", "getgrent", "getgrgid", "getgrnam", "gethostbyaddr", "gethostbyname", "gethostent", "getlogin", "getnetbyaddr", "getnetbyname", "getnetent", "getpeername", "getpgrp", "getpriority", "getprotobyname", "getprotobynumber", "getprotoent", "getpwent", "getpwnam", "getpwuid", "getservbyname", "getservbyport", "getservent", "getsockname", "getsockopt", "given", "glob", "gmtime", "goto", "grep", "gt", "hex", "if", "index", "int", "ioctl", "join", "keys", "kill", "last", "lc", "lcfirst", "length", "link", "listen", "local", "localtime", "log", "lstat", "lt", "ma", "map", "mkdir", "msgctl", "msgget", "msgrcv", "msgsnd", "my", "ne", "next", "no", "not", "oct", "open", "opendir", "or", "ord", "our", "pack", "package", "pipe", "pop", "pos", "print", "printf", "prototype", "push", "q|0", "qq", "quotemeta", "qw", "qx", "rand", "read", "readdir", "readline", "readlink", "readpipe", "recv", "redo", "ref", "rename", "require", "reset", "return", "reverse", "rewinddir", "rindex", "rmdir", "say", "scalar", "seek", "seekdir", "select", "semctl", "semget", "semop", "send", "setgrent", "sethostent", "setnetent", "setpgrp", "setpriority", "setprotoent", "setpwent", "setservent", "setsockopt", "shift", "shmctl", "shmget", "shmread", "shmwrite", "shutdown", "sin", "sleep", "socket", "socketpair", "sort", "splice", "split", "sprintf", "sqrt", "srand", "stat", "state", "study", "sub", "substr", "symlink", "syscall", "sysopen", "sysread", "sysseek", "system", "syswrite", "tell", "telldir", "tie", "tied", "time", "times", "tr", "truncate", "uc", "ucfirst", "umask", "undef", "unless", "unlink", "unpack", "unshift", "untie", "until", "use", "utime", "values", "vec", "wait", "waitpid", "wantarray", "warn", "when", "while", "write", "x|0", "xor", "y|0"];
  var REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/;
  var PERL_KEYWORDS = { $pattern: /[\w.]+/, keyword: KEYWORDS2.join(" ") };
  var SUBST = { className: "subst", begin: "[$@]\\{", end: "\\}", keywords: PERL_KEYWORDS };
  var METHOD = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  };
  var VAR = { variants: [{ begin: /\$\d/ }, { begin: regex.concat(
    /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
    // negative look-ahead tries to avoid matching patterns that are not
    // Perl at all like $ident$, @ident@, etc.
    "(?![A-Za-z])(?![@$%])"
  ) }, { begin: /[$%@][^\s\w{]/, relevance: 0 }] };
  var STRING_CONTAINS = [hljs.BACKSLASH_ESCAPE, SUBST, VAR];
  var REGEX_DELIMS = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ];
  var PAIRED_DOUBLE_RE = function PAIRED_DOUBLE_RE2(prefix, open, close2) {
    if (close2 === void 0) {
      close2 = "\\1";
    }
    var middle = close2 === "\\1" ? close2 : regex.concat(close2, open);
    return regex.concat(regex.concat("(?:", prefix, ")"), open, /(?:\\.|[^\\\/])*?/, middle, /(?:\\.|[^\\\/])*?/, close2, REGEX_MODIFIERS);
  };
  var PAIRED_RE = function PAIRED_RE2(prefix, open, close2) {
    return regex.concat(regex.concat("(?:", prefix, ")"), open, /(?:\\.|[^\\\/])*?/, close2, REGEX_MODIFIERS);
  };
  var PERL_DEFAULT_CONTAINS = [VAR, hljs.HASH_COMMENT_MODE, hljs.COMMENT(/^=\w/, /=cut/, { endsWithParent: true }), METHOD, { className: "string", contains: STRING_CONTAINS, variants: [{ begin: "q[qwxr]?\\s*\\(", end: "\\)", relevance: 5 }, { begin: "q[qwxr]?\\s*\\[", end: "\\]", relevance: 5 }, { begin: "q[qwxr]?\\s*\\{", end: "\\}", relevance: 5 }, { begin: "q[qwxr]?\\s*\\|", end: "\\|", relevance: 5 }, { begin: "q[qwxr]?\\s*<", end: ">", relevance: 5 }, { begin: "qw\\s+q", end: "q", relevance: 5 }, { begin: "'", end: "'", contains: [hljs.BACKSLASH_ESCAPE] }, { begin: '"', end: '"' }, { begin: "`", end: "`", contains: [hljs.BACKSLASH_ESCAPE] }, { begin: /\{\w+\}/, relevance: 0 }, { begin: "-?\\w+\\s*=>", relevance: 0 }] }, { className: "number", begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b", relevance: 0 }, {
    // regexp container
    begin: "(\\/\\/|" + hljs.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
    keywords: "split return print reverse grep",
    relevance: 0,
    contains: [hljs.HASH_COMMENT_MODE, { className: "regexp", variants: [
      // allow matching common delimiters
      { begin: PAIRED_DOUBLE_RE("s|tr|y", regex.either.apply(regex, REGEX_DELIMS.concat([{ capture: true }]))) },
      // and then paired delmis
      { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
      { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
      { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
    ], relevance: 2 }, { className: "regexp", variants: [
      {
        // could be a comment in many languages so do not count
        // as relevant
        begin: /(m|qr)\/\//,
        relevance: 0
      },
      // prefix is optional with /regex/
      { begin: PAIRED_RE("(?:m|qr)?", /\//, /\//) },
      // allow matching common delimiters
      { begin: PAIRED_RE("m|qr", regex.either.apply(regex, REGEX_DELIMS.concat([{ capture: true }])), /\1/) },
      // allow common paired delmins
      { begin: PAIRED_RE("m|qr", /\(/, /\)/) },
      { begin: PAIRED_RE("m|qr", /\[/, /\]/) },
      { begin: PAIRED_RE("m|qr", /\{/, /\}/) }
    ] }]
  }, { className: "function", beginKeywords: "sub", end: "(\\s*\\(.*?\\))?[;{]", excludeEnd: true, relevance: 5, contains: [hljs.TITLE_MODE] }, { begin: "-\\w\\b", relevance: 0 }, { begin: "^__DATA__$", end: "^__END__$", subLanguage: "mojolicious", contains: [{ begin: "^@@.*", end: "$", className: "comment" }] }];
  SUBST.contains = PERL_DEFAULT_CONTAINS;
  METHOD.contains = PERL_DEFAULT_CONTAINS;
  return { name: "Perl", aliases: ["pl", "pm"], keywords: PERL_KEYWORDS, contains: PERL_DEFAULT_CONTAINS };
}
function php(hljs) {
  var regex = hljs.regex;
  var NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
  var IDENT_RE2 = regex.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, NOT_PERL_ETC);
  var PASCAL_CASE_CLASS_NAME_RE = regex.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, NOT_PERL_ETC);
  var VARIABLE = { scope: "variable", match: "\\$+" + IDENT_RE2 };
  var PREPROCESSOR = { scope: "meta", variants: [
    { begin: /<\?php/, relevance: 10 },
    // boost for obvious PHP
    { begin: /<\?=/ },
    // less relevant per PSR-1 which says not to use short-tags
    { begin: /<\?/, relevance: 0.1 },
    { begin: /\?>/ }
    // end php tag
  ] };
  var SUBST = { scope: "subst", variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }] };
  var SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });
  var DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, { illegal: null, contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST) });
  var HEREDOC = { begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/, end: /[ \t]*(\w+)\b/, contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST), "on:begin": function onBegin(m, resp) {
    resp.data._beginMatch = m[1] || m[2];
  }, "on:end": function onEnd(m, resp) {
    if (resp.data._beginMatch !== m[1])
      resp.ignoreMatch();
  } };
  var NOWDOC = hljs.END_SAME_AS_BEGIN({ begin: /<<<[ \t]*'(\w+)'\n/, end: /[ \t]*(\w+)\b/ });
  var WHITESPACE = "[ 	\n]";
  var STRING = { scope: "string", variants: [DOUBLE_QUOTED, SINGLE_QUOTED, HEREDOC, NOWDOC] };
  var NUMBER = { scope: "number", variants: [
    { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
    // Binary w/ underscore support
    { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
    // Octals w/ underscore support
    { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
    // Hex w/ underscore support
    // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
    { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
  ], relevance: 0 };
  var LITERALS2 = ["false", "null", "true"];
  var KWS = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ];
  var BUILT_INS2 = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ];
  var dualCase = function dualCase2(items) {
    var result = [];
    items.forEach(function(item) {
      result.push(item);
      if (item.toLowerCase() === item) {
        result.push(item.toUpperCase());
      } else {
        result.push(item.toLowerCase());
      }
    });
    return result;
  };
  var KEYWORDS2 = { keyword: KWS, literal: dualCase(LITERALS2), built_in: BUILT_INS2 };
  var normalizeKeywords = function normalizeKeywords2(items) {
    return items.map(function(item) {
      return item.replace(/\|\d+$/, "");
    });
  };
  var CONSTRUCTOR_CALL = { variants: [{ match: [
    /new/,
    regex.concat(WHITESPACE, "+"),
    // to prevent built ins from being confused as the class constructor call
    regex.concat("(?!", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
    PASCAL_CASE_CLASS_NAME_RE
  ], scope: { 1: "keyword", 4: "title.class" } }] };
  var CONSTANT_REFERENCE = regex.concat(IDENT_RE2, "\\b(?!\\()");
  var LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [{ match: [regex.concat(/::/, regex.lookahead(/(?!class\b)/)), CONSTANT_REFERENCE], scope: { 2: "variable.constant" } }, { match: [/::/, /class/], scope: { 2: "variable.language" } }, { match: [PASCAL_CASE_CLASS_NAME_RE, regex.concat(/::/, regex.lookahead(/(?!class\b)/)), CONSTANT_REFERENCE], scope: { 1: "title.class", 3: "variable.constant" } }, { match: [PASCAL_CASE_CLASS_NAME_RE, regex.concat("::", regex.lookahead(/(?!class\b)/))], scope: { 1: "title.class" } }, { match: [PASCAL_CASE_CLASS_NAME_RE, /::/, /class/], scope: { 1: "title.class", 3: "variable.language" } }] };
  var NAMED_ARGUMENT = { scope: "attr", match: regex.concat(IDENT_RE2, regex.lookahead(":"), regex.lookahead(/(?!::)/)) };
  var PARAMS_MODE = { relevance: 0, begin: /\(/, end: /\)/, keywords: KEYWORDS2, contains: [NAMED_ARGUMENT, VARIABLE, LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON, hljs.C_BLOCK_COMMENT_MODE, STRING, NUMBER, CONSTRUCTOR_CALL] };
  var FUNCTION_INVOKE = { relevance: 0, match: [
    /\b/,
    // to prevent keywords from being confused as the function title
    regex.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
    IDENT_RE2,
    regex.concat(WHITESPACE, "*"),
    regex.lookahead(/(?=\()/)
  ], scope: { 3: "title.function.invoke" }, contains: [PARAMS_MODE] };
  PARAMS_MODE.contains.push(FUNCTION_INVOKE);
  var ATTRIBUTE_CONTAINS = [NAMED_ARGUMENT, LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON, hljs.C_BLOCK_COMMENT_MODE, STRING, NUMBER, CONSTRUCTOR_CALL];
  var ATTRIBUTES2 = { begin: regex.concat(/#\[\s*/, PASCAL_CASE_CLASS_NAME_RE), beginScope: "meta", end: /]/, endScope: "meta", keywords: { literal: LITERALS2, keyword: ["new", "array"] }, contains: [{ begin: /\[/, end: /]/, keywords: { literal: LITERALS2, keyword: ["new", "array"] }, contains: ["self"].concat(ATTRIBUTE_CONTAINS) }].concat(ATTRIBUTE_CONTAINS, [{ scope: "meta", match: PASCAL_CASE_CLASS_NAME_RE }]) };
  return { case_insensitive: false, keywords: KEYWORDS2, contains: [
    ATTRIBUTES2,
    hljs.HASH_COMMENT_MODE,
    hljs.COMMENT("//", "$"),
    hljs.COMMENT("/\\*", "\\*/", { contains: [{ scope: "doctag", match: "@[A-Za-z]+" }] }),
    { match: /__halt_compiler\(\);/, keywords: "__halt_compiler", starts: { scope: "comment", end: hljs.MATCH_NOTHING_RE, contains: [{ match: /\?>/, scope: "meta", endsParent: true }] } },
    PREPROCESSOR,
    { scope: "variable.language", match: /\$this\b/ },
    VARIABLE,
    FUNCTION_INVOKE,
    LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
    { match: [/const/, /\s/, IDENT_RE2], scope: { 1: "keyword", 3: "variable.constant" } },
    CONSTRUCTOR_CALL,
    { scope: "function", relevance: 0, beginKeywords: "fn function", end: /[;{]/, excludeEnd: true, illegal: "[$%\\[]", contains: [{ beginKeywords: "use" }, hljs.UNDERSCORE_TITLE_MODE, {
      begin: "=>",
      // No markup, just a relevance booster
      endsParent: true
    }, { scope: "params", begin: "\\(", end: "\\)", excludeBegin: true, excludeEnd: true, keywords: KEYWORDS2, contains: ["self", VARIABLE, LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON, hljs.C_BLOCK_COMMENT_MODE, STRING, NUMBER] }] },
    { scope: "class", variants: [{ beginKeywords: "enum", illegal: /[($"]/ }, { beginKeywords: "class interface trait", illegal: /[:($"]/ }], relevance: 0, end: /\{/, excludeEnd: true, contains: [{ beginKeywords: "extends implements" }, hljs.UNDERSCORE_TITLE_MODE] },
    // both use and namespace still use "old style" rules (vs multi-match)
    // because the namespace name can include `\` and we still want each
    // element to be treated as its own *individual* title
    { beginKeywords: "namespace", relevance: 0, end: ";", illegal: /[.']/, contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })] },
    { beginKeywords: "use", relevance: 0, end: ";", contains: [
      // TODO: title.function vs title.class
      { match: /\b(as|const|function)\b/, scope: "keyword" },
      // TODO: could be title.class or title.function
      hljs.UNDERSCORE_TITLE_MODE
    ] },
    STRING,
    NUMBER
  ] };
}
function phpTemplate(hljs) {
  return { name: "PHP template", subLanguage: "xml", contains: [{ begin: /<\?(php|=)?/, end: /\?>/, subLanguage: "php", contains: [
    // We don't want the php closing tag ?> to close the PHP block when
    // inside any of the following blocks:
    { begin: "/\\*", end: "\\*/", skip: true },
    { begin: 'b"', end: '"', skip: true },
    { begin: "b'", end: "'", skip: true },
    hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null, className: null, contains: null, skip: true }),
    hljs.inherit(hljs.QUOTE_STRING_MODE, { illegal: null, className: null, contains: null, skip: true })
  ] }] };
}
function plaintext(hljs) {
  return { name: "Plain text", aliases: ["text", "txt"], disableAutodetect: true };
}
function python(hljs) {
  var regex = hljs.regex;
  var IDENT_RE2 = /(?:[A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037B-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFC5D\uFC64-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDF9\uFE71\uFE73\uFE77\uFE79\uFE7B\uFE7D\uFE7F-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037B-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0898-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1715\u171F-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B4C\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA827\uA82C\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFC5D\uFC64-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDF9\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE71\uFE73\uFE77\uFE79\uFE7B\uFE7D\uFE7F-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF65-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDEFD-\uDF1C\uDF27\uDF30-\uDF50\uDF70-\uDF85\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC75\uDC7F-\uDCBA\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E-\uDE41\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39\uDF40-\uDF46]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDF00-\uDF10\uDF12-\uDF3A\uDF3E-\uDF42\uDF50-\uDF59\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC40-\uDC55]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC30-\uDC6D\uDC8F\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAE\uDEC0-\uDEF9]|\uD839[\uDCD0-\uDCF9\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]|\uDB40[\uDD00-\uDDEF])*/;
  var RESERVED_WORDS = ["and", "as", "assert", "async", "await", "break", "case", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "match", "nonlocal|10", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"];
  var BUILT_INS2 = ["__import__", "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"];
  var LITERALS2 = ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"];
  var TYPES2 = ["Any", "Callable", "Coroutine", "Dict", "List", "Literal", "Generic", "Optional", "Sequence", "Set", "Tuple", "Type", "Union"];
  var KEYWORDS2 = { $pattern: /[A-Za-z]\w+|__\w+__/, keyword: RESERVED_WORDS, built_in: BUILT_INS2, literal: LITERALS2, type: TYPES2 };
  var PROMPT = { className: "meta", begin: /^(>>>|\.\.\.) / };
  var SUBST = { className: "subst", begin: /\{/, end: /\}/, keywords: KEYWORDS2, illegal: /#/ };
  var LITERAL_BRACKET = { begin: /\{\{/, relevance: 0 };
  var STRING = { className: "string", contains: [hljs.BACKSLASH_ESCAPE], variants: [{ begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/, end: /'''/, contains: [hljs.BACKSLASH_ESCAPE, PROMPT], relevance: 10 }, { begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/, end: /"""/, contains: [hljs.BACKSLASH_ESCAPE, PROMPT], relevance: 10 }, { begin: /([fF][rR]|[rR][fF]|[fF])'''/, end: /'''/, contains: [hljs.BACKSLASH_ESCAPE, PROMPT, LITERAL_BRACKET, SUBST] }, { begin: /([fF][rR]|[rR][fF]|[fF])"""/, end: /"""/, contains: [hljs.BACKSLASH_ESCAPE, PROMPT, LITERAL_BRACKET, SUBST] }, { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 }, { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 }, { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ }, { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ }, { begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [hljs.BACKSLASH_ESCAPE, LITERAL_BRACKET, SUBST] }, { begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [hljs.BACKSLASH_ESCAPE, LITERAL_BRACKET, SUBST] }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE] };
  var digitpart = "[0-9](_?[0-9])*";
  var pointfloat = "(\\b(" + digitpart + "))?\\.(" + digitpart + ")|\\b(" + digitpart + ")\\.";
  var lookahead2 = "\\b|" + RESERVED_WORDS.join("|");
  var NUMBER = { className: "number", relevance: 0, variants: [
    // exponentfloat, pointfloat
    // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
    // optionally imaginary
    // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
    // Note: no leading \b because floats can start with a decimal point
    // and we don't want to mishandle e.g. `fn(.5)`,
    // no trailing \b for pointfloat because it can end with a decimal point
    // and we don't want to mishandle e.g. `0..hex()`; this should be safe
    // because both MUST contain a decimal point and so cannot be confused with
    // the interior part of an identifier
    { begin: "(\\b(" + digitpart + ")|(" + pointfloat + "))[eE][+-]?(" + digitpart + ")[jJ]?(?=" + lookahead2 + ")" },
    { begin: "(" + pointfloat + ")[jJ]?" },
    // decinteger, bininteger, octinteger, hexinteger
    // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
    // optionally "long" in Python 2
    // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
    // decinteger is optionally imaginary
    // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
    { begin: "\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=" + lookahead2 + ")" },
    { begin: "\\b0[bB](_?[01])+[lL]?(?=" + lookahead2 + ")" },
    { begin: "\\b0[oO](_?[0-7])+[lL]?(?=" + lookahead2 + ")" },
    { begin: "\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=" + lookahead2 + ")" },
    // imagnumber (digitpart-based)
    // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
    { begin: "\\b(" + digitpart + ")[jJ](?=" + lookahead2 + ")" }
  ] };
  var COMMENT_TYPE = { className: "comment", begin: regex.lookahead(/# type:/), end: /$/, keywords: KEYWORDS2, contains: [
    {
      // prevent keywords from coloring `type`
      begin: /# type:/
    },
    // comment within a datatype comment includes no keywords
    { begin: /#/, end: /\b\B/, endsWithParent: true }
  ] };
  var PARAMS = { className: "params", variants: [
    // Exclude params in functions without params
    { className: "", begin: /\(\s*\)/, skip: true },
    { begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: KEYWORDS2, contains: ["self", PROMPT, NUMBER, STRING, hljs.HASH_COMMENT_MODE] }
  ] };
  SUBST.contains = [STRING, NUMBER, PROMPT];
  return { name: "Python", aliases: ["py", "gyp", "ipython"], unicodeRegex: true, keywords: KEYWORDS2, illegal: /(<\/|\?)|=>/, contains: [PROMPT, NUMBER, {
    // very common convention
    begin: /\bself\b/
  }, {
    // eat "if" prior to string so that it won't accidentally be
    // labeled as an f-string
    beginKeywords: "if",
    relevance: 0
  }, STRING, COMMENT_TYPE, hljs.HASH_COMMENT_MODE, { match: [/\bdef/, /\s+/, IDENT_RE2], scope: { 1: "keyword", 3: "title.function" }, contains: [PARAMS] }, { variants: [{ match: [/\bclass/, /\s+/, IDENT_RE2, /\s*/, /\(\s*/, IDENT_RE2, /\s*\)/] }, { match: [/\bclass/, /\s+/, IDENT_RE2] }], scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" } }, { className: "meta", begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [NUMBER, PARAMS, STRING] }] };
}
function pythonRepl(hljs) {
  return { aliases: ["pycon"], contains: [{ className: "meta.prompt", starts: {
    // a space separates the REPL prefix from the actual code
    // this is purely for cleaner HTML output
    end: / |$/,
    starts: { end: "$", subLanguage: "python" }
  }, variants: [{ begin: /^>>>(?=[ ]|$)/ }, { begin: /^\.\.\.(?=[ ]|$)/ }] }] };
}
function r(hljs) {
  var regex = hljs.regex;
  var IDENT_RE2 = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/;
  var NUMBER_TYPES_RE = regex.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  );
  var OPERATORS_RE = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/;
  var PUNCTUATION_RE = regex.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
  return { name: "R", keywords: { $pattern: IDENT_RE2, keyword: "function if in break next repeat else for while", literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10", built_in: (
    // Builtin constants
    "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
  ) }, contains: [
    // Roxygen comments
    hljs.COMMENT(/#'/, /$/, { contains: [{
      // Handle `@examples` separately to cause all subsequent code
      // until the next `@`-tag on its own line to be kept as-is,
      // preventing highlighting. This code is example R code, so nested
      // doctags shouldn’t be treated as such. See
      // `test/markup/r/roxygen.txt` for an example.
      scope: "doctag",
      match: /@examples/,
      starts: { end: regex.lookahead(regex.either(
        // end if another doc comment
        /\n^#'\s*(?=@[a-zA-Z]+)/,
        // or a line with no comment
        /\n^(?!#')/
      )), endsParent: true }
    }, {
      // Handle `@param` to highlight the parameter name following
      // after.
      scope: "doctag",
      begin: "@param",
      end: /$/,
      contains: [{ scope: "variable", variants: [{ match: IDENT_RE2 }, { match: /`(?:\\.|[^`\\])+`/ }], endsParent: true }]
    }, { scope: "doctag", match: /@[a-zA-Z]+/ }, { scope: "keyword", match: /\\[a-zA-Z]+/ }] }),
    hljs.HASH_COMMENT_MODE,
    { scope: "string", contains: [hljs.BACKSLASH_ESCAPE], variants: [hljs.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }), hljs.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }), hljs.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }), hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }), hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }), hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }), { begin: '"', end: '"', relevance: 0 }, { begin: "'", end: "'", relevance: 0 }] },
    // Matching numbers immediately following punctuation and operators is
    // tricky since we need to look at the character ahead of a number to
    // ensure the number is not part of an identifier, and we cannot use
    // negative look-behind assertions. So instead we explicitly handle all
    // possible combinations of (operator|punctuation), number.
    // TODO: replace with negative look-behind when available
    // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
    // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
    // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
    { relevance: 0, variants: [{ scope: { 1: "operator", 2: "number" }, match: [OPERATORS_RE, NUMBER_TYPES_RE] }, { scope: { 1: "operator", 2: "number" }, match: [/%[^%]*%/, NUMBER_TYPES_RE] }, { scope: { 1: "punctuation", 2: "number" }, match: [PUNCTUATION_RE, NUMBER_TYPES_RE] }, { scope: { 2: "number" }, match: [
      /[^a-zA-Z0-9._]|^/,
      // not part of an identifier, or start of document
      NUMBER_TYPES_RE
    ] }] },
    // Operators/punctuation when they're not directly followed by numbers
    {
      // Relevance boost for the most common assignment form.
      scope: { 3: "operator" },
      match: [IDENT_RE2, /\s+/, /<-/, /\s+/]
    },
    { scope: "operator", relevance: 0, variants: [{ match: OPERATORS_RE }, { match: /%[^%]*%/ }] },
    { scope: "punctuation", relevance: 0, match: PUNCTUATION_RE },
    {
      // Escaped identifier
      begin: "`",
      end: "`",
      contains: [{ begin: /\\./ }]
    }
  ] };
}
function ruby(hljs) {
  var regex = hljs.regex;
  var RUBY_METHOD_RE = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)";
  var CLASS_NAME_RE = regex.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  );
  var CLASS_NAME_WITH_NAMESPACE_RE = regex.concat(CLASS_NAME_RE, /(::\w+)*/);
  var PSEUDO_KWS = ["include", "extend", "prepend", "public", "private", "protected", "raise", "throw"];
  var RUBY_KEYWORDS = { "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"], "variable.language": ["self", "super"], keyword: ["alias", "and", "begin", "BEGIN", "break", "case", "class", "defined", "do", "else", "elsif", "end", "END", "ensure", "for", "if", "in", "module", "next", "not", "or", "redo", "require", "rescue", "retry", "return", "then", "undef", "unless", "until", "when", "while", "yield"].concat(PSEUDO_KWS), built_in: ["proc", "lambda", "attr_accessor", "attr_reader", "attr_writer", "define_method", "private_constant", "module_function"], literal: ["true", "false", "nil"] };
  var YARDOCTAG = { className: "doctag", begin: "@[A-Za-z]+" };
  var IRB_OBJECT = { begin: "#<", end: ">" };
  var COMMENT_MODES = [hljs.COMMENT("#", "$", { contains: [YARDOCTAG] }), hljs.COMMENT("^=begin", "^=end", { contains: [YARDOCTAG], relevance: 10 }), hljs.COMMENT("^__END__", hljs.MATCH_NOTHING_RE)];
  var SUBST = { className: "subst", begin: /#\{/, end: /\}/, keywords: RUBY_KEYWORDS };
  var STRING = { className: "string", contains: [hljs.BACKSLASH_ESCAPE, SUBST], variants: [
    { begin: /'/, end: /'/ },
    { begin: /"/, end: /"/ },
    { begin: /`/, end: /`/ },
    { begin: /%[qQwWx]?\(/, end: /\)/ },
    { begin: /%[qQwWx]?\[/, end: /\]/ },
    { begin: /%[qQwWx]?\{/, end: /\}/ },
    { begin: /%[qQwWx]?</, end: />/ },
    { begin: /%[qQwWx]?\//, end: /\// },
    { begin: /%[qQwWx]?%/, end: /%/ },
    { begin: /%[qQwWx]?-/, end: /-/ },
    { begin: /%[qQwWx]?\|/, end: /\|/ },
    // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
    // where ? is the last character of a preceding identifier, as in: `func?4`
    { begin: /\B\?(\\\d{1,3})/ },
    { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
    { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
    { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
    { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
    { begin: /\B\?\\?\S/ },
    // heredocs
    {
      // this guard makes sure that we have an entire heredoc and not a false
      // positive (auto-detect, etc.)
      begin: regex.concat(/<<[-~]?'?/, regex.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
      contains: [hljs.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, contains: [hljs.BACKSLASH_ESCAPE, SUBST] })]
    }
  ] };
  var decimal = "[1-9](_?[0-9])*|0";
  var digits = "[0-9](_?[0-9])*";
  var NUMBER = { className: "number", relevance: 0, variants: [
    // decimal integer/float, optionally exponential or rational, optionally imaginary
    { begin: "\\b(" + decimal + ")(\\.(" + digits + "))?([eE][+-]?(" + digits + ")|r)?i?\\b" },
    // explicit decimal/binary/octal/hexadecimal integer,
    // optionally rational and/or imaginary
    { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
    { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
    { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
    { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
    // 0-prefixed implicit octal integer, optionally rational and/or imaginary
    { begin: "\\b0(_?[0-7])+r?i?\\b" }
  ] };
  var PARAMS = { variants: [{ match: /\(\)/ }, { className: "params", begin: /\(/, end: /(?=\))/, excludeBegin: true, endsParent: true, keywords: RUBY_KEYWORDS }] };
  var INCLUDE_EXTEND = { match: [/(include|extend)\s+/, CLASS_NAME_WITH_NAMESPACE_RE], scope: { 2: "title.class" }, keywords: RUBY_KEYWORDS };
  var CLASS_DEFINITION = { variants: [{ match: [/class\s+/, CLASS_NAME_WITH_NAMESPACE_RE, /\s+<\s+/, CLASS_NAME_WITH_NAMESPACE_RE] }, { match: [/\b(class|module)\s+/, CLASS_NAME_WITH_NAMESPACE_RE] }], scope: { 2: "title.class", 4: "title.class.inherited" }, keywords: RUBY_KEYWORDS };
  var UPPER_CASE_CONSTANT = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" };
  var METHOD_DEFINITION = { match: [/def/, /\s+/, RUBY_METHOD_RE], scope: { 1: "keyword", 3: "title.function" }, contains: [PARAMS] };
  var OBJECT_CREATION = { relevance: 0, match: [CLASS_NAME_WITH_NAMESPACE_RE, /\.new[. (]/], scope: { 1: "title.class" } };
  var CLASS_REFERENCE = { relevance: 0, match: CLASS_NAME_RE, scope: "title.class" };
  var RUBY_DEFAULT_CONTAINS = [STRING, CLASS_DEFINITION, INCLUDE_EXTEND, OBJECT_CREATION, UPPER_CASE_CONSTANT, CLASS_REFERENCE, METHOD_DEFINITION, {
    // swallow namespace qualifiers before symbols
    begin: hljs.IDENT_RE + "::"
  }, { className: "symbol", begin: hljs.UNDERSCORE_IDENT_RE + "(!|\\?)?:", relevance: 0 }, { className: "symbol", begin: ":(?!\\s)", contains: [STRING, { begin: RUBY_METHOD_RE }], relevance: 0 }, NUMBER, {
    // negative-look forward attempts to prevent false matches like:
    // @ident@ or $ident$ that might indicate this is not ruby at all
    className: "variable",
    begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
  }, {
    className: "params",
    begin: /\|/,
    end: /\|/,
    excludeBegin: true,
    excludeEnd: true,
    relevance: 0,
    // this could be a lot of things (in other languages) other than params
    keywords: RUBY_KEYWORDS
  }, {
    // regexp container
    begin: "(" + hljs.RE_STARTERS_RE + "|unless)\\s*",
    keywords: "unless",
    contains: [{ className: "regexp", contains: [hljs.BACKSLASH_ESCAPE, SUBST], illegal: /\n/, variants: [{ begin: "/", end: "/[a-z]*" }, { begin: /%r\{/, end: /\}[a-z]*/ }, { begin: "%r\\(", end: "\\)[a-z]*" }, { begin: "%r!", end: "![a-z]*" }, { begin: "%r\\[", end: "\\][a-z]*" }] }].concat(IRB_OBJECT, COMMENT_MODES),
    relevance: 0
  }].concat(IRB_OBJECT, COMMENT_MODES);
  SUBST.contains = RUBY_DEFAULT_CONTAINS;
  PARAMS.contains = RUBY_DEFAULT_CONTAINS;
  var SIMPLE_PROMPT = "[>?]>";
  var DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]";
  var RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
  var IRB_DEFAULT = [{ begin: /^\s*=>/, starts: { end: "$", contains: RUBY_DEFAULT_CONTAINS } }, { className: "meta.prompt", begin: "^(" + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + "|" + RVM_PROMPT + ")(?=[ ])", starts: { end: "$", keywords: RUBY_KEYWORDS, contains: RUBY_DEFAULT_CONTAINS } }];
  COMMENT_MODES.unshift(IRB_OBJECT);
  return { name: "Ruby", aliases: ["rb", "gemspec", "podspec", "thor", "irb"], keywords: RUBY_KEYWORDS, illegal: /\/\*/, contains: [hljs.SHEBANG({ binary: "ruby" })].concat(IRB_DEFAULT).concat(COMMENT_MODES).concat(RUBY_DEFAULT_CONTAINS) };
}
function rust(hljs) {
  var regex = hljs.regex;
  var FUNCTION_INVOKE = { className: "title.function.invoke", relevance: 0, begin: regex.concat(/\b/, /(?!let\b)/, hljs.IDENT_RE, regex.lookahead(/\s*\(/)) };
  var NUMBER_SUFFIX = "([ui](8|16|32|64|128|size)|f(32|64))?";
  var KEYWORDS2 = ["abstract", "as", "async", "await", "become", "box", "break", "const", "continue", "crate", "do", "dyn", "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop", "macro", "match", "mod", "move", "mut", "override", "priv", "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait", "true", "try", "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield"];
  var LITERALS2 = ["true", "false", "Some", "None", "Ok", "Err"];
  var BUILTINS = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ];
  var TYPES2 = ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize", "f32", "f64", "str", "char", "bool", "Box", "Option", "Result", "String", "Vec"];
  return { name: "Rust", aliases: ["rs"], keywords: { $pattern: hljs.IDENT_RE + "!?", type: TYPES2, keyword: KEYWORDS2, literal: LITERALS2, built_in: BUILTINS }, illegal: "</", contains: [
    hljs.C_LINE_COMMENT_MODE,
    hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
    hljs.inherit(hljs.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
    { className: "string", variants: [{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ }, { begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/ }] },
    { className: "symbol", begin: /'[a-zA-Z_][a-zA-Z0-9_]*/ },
    { className: "number", variants: [{ begin: "\\b0b([01_]+)" + NUMBER_SUFFIX }, { begin: "\\b0o([0-7_]+)" + NUMBER_SUFFIX }, { begin: "\\b0x([A-Fa-f0-9_]+)" + NUMBER_SUFFIX }, { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + NUMBER_SUFFIX }], relevance: 0 },
    { begin: [/fn/, /\s+/, hljs.UNDERSCORE_IDENT_RE], className: { 1: "keyword", 3: "title.function" } },
    { className: "meta", begin: "#!?\\[", end: "\\]", contains: [{ className: "string", begin: /"/, end: /"/ }] },
    { begin: [/let/, /\s+/, /(?:mut\s+)?/, hljs.UNDERSCORE_IDENT_RE], className: { 1: "keyword", 3: "keyword", 4: "variable" } },
    // must come before impl/for rule later
    { begin: [/for/, /\s+/, hljs.UNDERSCORE_IDENT_RE, /\s+/, /in/], className: { 1: "keyword", 3: "variable", 5: "keyword" } },
    { begin: [/type/, /\s+/, hljs.UNDERSCORE_IDENT_RE], className: { 1: "keyword", 3: "title.class" } },
    { begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, hljs.UNDERSCORE_IDENT_RE], className: { 1: "keyword", 3: "title.class" } },
    { begin: hljs.IDENT_RE + "::", keywords: { keyword: "Self", built_in: BUILTINS, type: TYPES2 } },
    { className: "punctuation", begin: "->" },
    FUNCTION_INVOKE
  ] };
}
var MODES$1 = function MODES$12(hljs) {
  return { IMPORTANT: { scope: "meta", begin: "!important" }, BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE, HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ }, FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ }, ATTRIBUTE_SELECTOR_MODE: { scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$", contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE] }, CSS_NUMBER_MODE: { scope: "number", begin: hljs.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", relevance: 0 }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z][A-Za-z0-9_-]*/ } };
};
var TAGS = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"];
var MEDIA_FEATURES = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
var PSEUDO_CLASSES = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
];
var PSEUDO_ELEMENTS = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"];
var ATTRIBUTES = [
  "align-content",
  "align-items",
  "align-self",
  "all",
  "animation",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-timing-function",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-repeat",
  "background-size",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-decoration-break",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "direction",
  "display",
  "empty-cells",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-size",
  "font-size-adjust",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-variant",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "gap",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "inline-size",
  "isolation",
  "justify-content",
  "left",
  "letter-spacing",
  "line-break",
  "line-height",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "pointer-events",
  "position",
  "quotes",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "row-gap",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-style",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-transform",
  "text-underline-position",
  "top",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "unicode-bidi",
  "vertical-align",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "z-index"
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();
function scss(hljs) {
  var modes = MODES$1(hljs);
  var PSEUDO_ELEMENTS$12 = PSEUDO_ELEMENTS;
  var PSEUDO_CLASSES$12 = PSEUDO_CLASSES;
  var AT_IDENTIFIER = "@[a-z-]+";
  var AT_MODIFIERS = "and or not only";
  var IDENT_RE2 = "[a-zA-Z-][a-zA-Z0-9_-]*";
  var VARIABLE = { className: "variable", begin: "(\\$" + IDENT_RE2 + ")\\b", relevance: 0 };
  return { name: "SCSS", case_insensitive: true, illegal: "[=/|']", contains: [
    hljs.C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    // to recognize keyframe 40% etc which are outside the scope of our
    // attribute value mode
    modes.CSS_NUMBER_MODE,
    { className: "selector-id", begin: "#[A-Za-z0-9_-]+", relevance: 0 },
    { className: "selector-class", begin: "\\.[A-Za-z0-9_-]+", relevance: 0 },
    modes.ATTRIBUTE_SELECTOR_MODE,
    {
      className: "selector-tag",
      begin: "\\b(" + TAGS.join("|") + ")\\b",
      // was there, before, but why?
      relevance: 0
    },
    { className: "selector-pseudo", begin: ":(" + PSEUDO_CLASSES$12.join("|") + ")" },
    { className: "selector-pseudo", begin: ":(:)?(" + PSEUDO_ELEMENTS$12.join("|") + ")" },
    VARIABLE,
    {
      // pseudo-selector params
      begin: /\(/,
      end: /\)/,
      contains: [modes.CSS_NUMBER_MODE]
    },
    modes.CSS_VARIABLE,
    { className: "attribute", begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b" },
    { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
    { begin: /:/, end: /[;}{]/, relevance: 0, contains: [modes.BLOCK_COMMENT, VARIABLE, modes.HEXCOLOR, modes.CSS_NUMBER_MODE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, modes.IMPORTANT, modes.FUNCTION_DISPATCH] },
    // matching these here allows us to treat them more like regular CSS
    // rules so everything between the {} gets regular rule highlighting,
    // which is what we want for page and font-face
    { begin: "@(page|font-face)", keywords: { $pattern: AT_IDENTIFIER, keyword: "@page @font-face" } },
    { begin: "@", end: "[{;]", returnBegin: true, keywords: { $pattern: /[a-z-]+/, keyword: AT_MODIFIERS, attribute: MEDIA_FEATURES.join(" ") }, contains: [{ begin: AT_IDENTIFIER, className: "keyword" }, { begin: /[a-z-]+(?=:)/, className: "attribute" }, VARIABLE, hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE, modes.HEXCOLOR, modes.CSS_NUMBER_MODE] },
    modes.FUNCTION_DISPATCH
  ] };
}
function shell(hljs) {
  return { name: "Shell Session", aliases: ["console", "shellsession"], contains: [{
    className: "meta.prompt",
    // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
    // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
    // echo /path/to/home > t.exe
    begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
    starts: { end: /[^\\](?=\s*$)/, subLanguage: "bash" }
  }] };
}
function sql(hljs) {
  var regex = hljs.regex;
  var COMMENT_MODE = hljs.COMMENT("--", "$");
  var STRING = { className: "string", variants: [{ begin: /'/, end: /'/, contains: [{ begin: /''/ }] }] };
  var QUOTED_IDENTIFIER = { begin: /"/, end: /"/, contains: [{ begin: /""/ }] };
  var LITERALS2 = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ];
  var MULTI_WORD_TYPES = ["double precision", "large object", "with timezone", "without timezone"];
  var TYPES2 = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ];
  var NON_RESERVED_WORDS = ["add", "asc", "collation", "desc", "final", "first", "last", "view"];
  var RESERVED_WORDS = ["abs", "acos", "all", "allocate", "alter", "and", "any", "are", "array", "array_agg", "array_max_cardinality", "as", "asensitive", "asin", "asymmetric", "at", "atan", "atomic", "authorization", "avg", "begin", "begin_frame", "begin_partition", "between", "bigint", "binary", "blob", "boolean", "both", "by", "call", "called", "cardinality", "cascaded", "case", "cast", "ceil", "ceiling", "char", "char_length", "character", "character_length", "check", "classifier", "clob", "close", "coalesce", "collate", "collect", "column", "commit", "condition", "connect", "constraint", "contains", "convert", "copy", "corr", "corresponding", "cos", "cosh", "count", "covar_pop", "covar_samp", "create", "cross", "cube", "cume_dist", "current", "current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_row", "current_schema", "current_time", "current_timestamp", "current_path", "current_role", "current_transform_group_for_type", "current_user", "cursor", "cycle", "date", "day", "deallocate", "dec", "decimal", "decfloat", "declare", "default", "define", "delete", "dense_rank", "deref", "describe", "deterministic", "disconnect", "distinct", "double", "drop", "dynamic", "each", "element", "else", "empty", "end", "end_frame", "end_partition", "end-exec", "equals", "escape", "every", "except", "exec", "execute", "exists", "exp", "external", "extract", "false", "fetch", "filter", "first_value", "float", "floor", "for", "foreign", "frame_row", "free", "from", "full", "function", "fusion", "get", "global", "grant", "group", "grouping", "groups", "having", "hold", "hour", "identity", "in", "indicator", "initial", "inner", "inout", "insensitive", "insert", "int", "integer", "intersect", "intersection", "interval", "into", "is", "join", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "language", "large", "last_value", "lateral", "lead", "leading", "left", "like", "like_regex", "listagg", "ln", "local", "localtime", "localtimestamp", "log", "log10", "lower", "match", "match_number", "match_recognize", "matches", "max", "member", "merge", "method", "min", "minute", "mod", "modifies", "module", "month", "multiset", "national", "natural", "nchar", "nclob", "new", "no", "none", "normalize", "not", "nth_value", "ntile", "null", "nullif", "numeric", "octet_length", "occurrences_regex", "of", "offset", "old", "omit", "on", "one", "only", "open", "or", "order", "out", "outer", "over", "overlaps", "overlay", "parameter", "partition", "pattern", "per", "percent", "percent_rank", "percentile_cont", "percentile_disc", "period", "portion", "position", "position_regex", "power", "precedes", "precision", "prepare", "primary", "procedure", "ptf", "range", "rank", "reads", "real", "recursive", "ref", "references", "referencing", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "release", "result", "return", "returns", "revoke", "right", "rollback", "rollup", "row", "row_number", "rows", "running", "savepoint", "scope", "scroll", "search", "second", "seek", "select", "sensitive", "session_user", "set", "show", "similar", "sin", "sinh", "skip", "smallint", "some", "specific", "specifictype", "sql", "sqlexception", "sqlstate", "sqlwarning", "sqrt", "start", "static", "stddev_pop", "stddev_samp", "submultiset", "subset", "substring", "substring_regex", "succeeds", "sum", "symmetric", "system", "system_time", "system_user", "table", "tablesample", "tan", "tanh", "then", "time", "timestamp", "timezone_hour", "timezone_minute", "to", "trailing", "translate", "translate_regex", "translation", "treat", "trigger", "trim", "trim_array", "true", "truncate", "uescape", "union", "unique", "unknown", "unnest", "update", "upper", "user", "using", "value", "values", "value_of", "var_pop", "var_samp", "varbinary", "varchar", "varying", "versioning", "when", "whenever", "where", "width_bucket", "window", "with", "within", "without", "year"];
  var RESERVED_FUNCTIONS = ["abs", "acos", "array_agg", "asin", "atan", "avg", "cast", "ceil", "ceiling", "coalesce", "corr", "cos", "cosh", "count", "covar_pop", "covar_samp", "cume_dist", "dense_rank", "deref", "element", "exp", "extract", "first_value", "floor", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "last_value", "lead", "listagg", "ln", "log", "log10", "lower", "max", "min", "mod", "nth_value", "ntile", "nullif", "percent_rank", "percentile_cont", "percentile_disc", "position", "position_regex", "power", "rank", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "row_number", "sin", "sinh", "sqrt", "stddev_pop", "stddev_samp", "substring", "substring_regex", "sum", "tan", "tanh", "translate", "translate_regex", "treat", "trim", "trim_array", "unnest", "upper", "value_of", "var_pop", "var_samp", "width_bucket"];
  var POSSIBLE_WITHOUT_PARENS = ["current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_schema", "current_transform_group_for_type", "current_user", "session_user", "system_time", "system_user", "current_time", "localtime", "current_timestamp", "localtimestamp"];
  var COMBOS = ["create table", "insert into", "primary key", "foreign key", "not null", "alter table", "add constraint", "grouping sets", "on overflow", "character set", "respect nulls", "ignore nulls", "nulls first", "nulls last", "depth first", "breadth first"];
  var FUNCTIONS = RESERVED_FUNCTIONS;
  var KEYWORDS2 = [].concat(RESERVED_WORDS, NON_RESERVED_WORDS).filter(function(keyword) {
    return !RESERVED_FUNCTIONS.includes(keyword);
  });
  var VARIABLE = { className: "variable", begin: /@[a-z0-9][a-z0-9_]*/ };
  var OPERATOR = { className: "operator", begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/, relevance: 0 };
  var FUNCTION_CALL = { begin: regex.concat(/\b/, regex.either.apply(regex, FUNCTIONS), /\s*\(/), relevance: 0, keywords: { built_in: FUNCTIONS } };
  function reduceRelevancy(list, _temp5) {
    var _ref249 = _temp5 === void 0 ? {} : _temp5, exceptions = _ref249.exceptions, when = _ref249.when;
    var qualifyFn = when;
    exceptions = exceptions || [];
    return list.map(function(item) {
      if (item.match(/\|\d+$/) || exceptions.includes(item)) {
        return item;
      } else if (qualifyFn(item)) {
        return item + "|0";
      } else {
        return item;
      }
    });
  }
  return {
    name: "SQL",
    case_insensitive: true,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: { $pattern: /\b[\w\.]+/, keyword: reduceRelevancy(KEYWORDS2, { when: function when(x) {
      return x.length < 3;
    } }), literal: LITERALS2, type: TYPES2, built_in: POSSIBLE_WITHOUT_PARENS },
    contains: [{ begin: regex.either.apply(regex, COMBOS), relevance: 0, keywords: { $pattern: /[\w\.]+/, keyword: KEYWORDS2.concat(COMBOS), literal: LITERALS2, type: TYPES2 } }, { className: "type", begin: regex.either.apply(regex, MULTI_WORD_TYPES) }, FUNCTION_CALL, VARIABLE, STRING, QUOTED_IDENTIFIER, hljs.C_NUMBER_MODE, hljs.C_BLOCK_COMMENT_MODE, COMMENT_MODE, OPERATOR]
  };
}
function source$1(re) {
  if (!re)
    return null;
  if (typeof re === "string")
    return re;
  return re.source;
}
function lookahead$1(re) {
  return concat$1("(?=", re, ")");
}
function concat$1() {
  for (var _len9 = arguments.length, args = new Array(_len9), _key10 = 0; _key10 < _len9; _key10++) {
    args[_key10] = arguments[_key10];
  }
  var joined = args.map(function(x) {
    return source$1(x);
  }).join("");
  return joined;
}
function stripOptionsFromArgs$1(args) {
  var opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either$1() {
  for (var _len10 = arguments.length, args = new Array(_len10), _key11 = 0; _key11 < _len10; _key11++) {
    args[_key11] = arguments[_key11];
  }
  var opts = stripOptionsFromArgs$1(args);
  var joined = "(" + (opts.capture ? "" : "?:") + args.map(function(x) {
    return source$1(x);
  }).join("|") + ")";
  return joined;
}
var keywordWrapper = function keywordWrapper2(keyword) {
  return concat$1(/\b/, keyword, /\w$/.test(keyword) ? /\b/ : /\B/);
};
var dotKeywords = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(keywordWrapper);
var optionalDotKeywords = ["init", "self"].map(keywordWrapper);
var keywordTypes = ["Any", "Self"];
var keywords = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "break",
  "case",
  "catch",
  "class",
  "continue",
  "convenience",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
];
var literals = ["false", "nil", "true"];
var precedencegroupKeywords = ["assignment", "associativity", "higherThan", "left", "lowerThan", "none", "right"];
var numberSignKeywords = ["#colorLiteral", "#column", "#dsohandle", "#else", "#elseif", "#endif", "#error", "#file", "#fileID", "#fileLiteral", "#filePath", "#function", "#if", "#imageLiteral", "#keyPath", "#line", "#selector", "#sourceLocation", "#warn_unqualified_access", "#warning"];
var builtIns = ["abs", "all", "any", "assert", "assertionFailure", "debugPrint", "dump", "fatalError", "getVaList", "isKnownUniquelyReferenced", "max", "min", "numericCast", "pointwiseMax", "pointwiseMin", "precondition", "preconditionFailure", "print", "readLine", "repeatElement", "sequence", "stride", "swap", "swift_unboxFromSwiftValueWithType", "transcode", "type", "unsafeBitCast", "unsafeDowncast", "withExtendedLifetime", "withUnsafeMutablePointer", "withUnsafePointer", "withVaList", "withoutActuallyEscaping", "zip"];
var operatorHead = either$1(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/);
var operatorCharacter = either$1(
  operatorHead,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
);
var operator = concat$1(operatorHead, operatorCharacter, "*");
var identifierHead = either$1(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
);
var identifierCharacter = either$1(identifierHead, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/);
var identifier = concat$1(identifierHead, identifierCharacter, "*");
var typeIdentifier = concat$1(/[A-Z]/, identifierCharacter, "*");
var keywordAttributes = ["autoclosure", concat$1(/convention\(/, either$1("swift", "block", "c"), /\)/), "discardableResult", "dynamicCallable", "dynamicMemberLookup", "escaping", "frozen", "GKInspectable", "IBAction", "IBDesignable", "IBInspectable", "IBOutlet", "IBSegueAction", "inlinable", "main", "nonobjc", "NSApplicationMain", "NSCopying", "NSManaged", concat$1(/objc\(/, identifier, /\)/), "objc", "objcMembers", "propertyWrapper", "requires_stored_property_inits", "resultBuilder", "testable", "UIApplicationMain", "unknown", "usableFromInline"];
var availabilityKeywords = ["iOS", "iOSApplicationExtension", "macOS", "macOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "watchOS", "watchOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "swift"];
function swift(hljs) {
  var WHITESPACE = { match: /\s+/, relevance: 0 };
  var BLOCK_COMMENT = hljs.COMMENT("/\\*", "\\*/", { contains: ["self"] });
  var COMMENTS = [hljs.C_LINE_COMMENT_MODE, BLOCK_COMMENT];
  var DOT_KEYWORD = { match: [/\./, either$1.apply(void 0, dotKeywords.concat(optionalDotKeywords))], className: { 2: "keyword" } };
  var KEYWORD_GUARD = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: concat$1(/\./, either$1.apply(void 0, keywords)),
    relevance: 0
  };
  var PLAIN_KEYWORDS = keywords.filter(function(kw) {
    return typeof kw === "string";
  }).concat(["_|0"]);
  var REGEX_KEYWORDS = keywords.filter(function(kw) {
    return typeof kw !== "string";
  }).concat(keywordTypes).map(keywordWrapper);
  var KEYWORD = { variants: [{ className: "keyword", match: either$1.apply(void 0, REGEX_KEYWORDS.concat(optionalDotKeywords)) }] };
  var KEYWORDS2 = { $pattern: either$1(
    /\b\w+/,
    // regular keywords
    /#\w+/
    // number keywords
  ), keyword: PLAIN_KEYWORDS.concat(numberSignKeywords), literal: literals };
  var KEYWORD_MODES = [DOT_KEYWORD, KEYWORD_GUARD, KEYWORD];
  var BUILT_IN_GUARD = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: concat$1(/\./, either$1.apply(void 0, builtIns)),
    relevance: 0
  };
  var BUILT_IN = { className: "built_in", match: concat$1(/\b/, either$1.apply(void 0, builtIns), /(?=\()/) };
  var BUILT_INS2 = [BUILT_IN_GUARD, BUILT_IN];
  var OPERATOR_GUARD = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  };
  var OPERATOR = { className: "operator", relevance: 0, variants: [{ match: operator }, {
    // dot-operator: only operators that start with a dot are allowed to use dots as
    // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
    // characters that may also include dots.
    match: "\\.(\\.|" + operatorCharacter + ")+"
  }] };
  var OPERATORS = [OPERATOR_GUARD, OPERATOR];
  var decimalDigits2 = "([0-9]_*)+";
  var hexDigits2 = "([0-9a-fA-F]_*)+";
  var NUMBER = { className: "number", relevance: 0, variants: [
    // decimal floating-point-literal (subsumes decimal-literal)
    { match: "\\b(" + decimalDigits2 + ")(\\.(" + decimalDigits2 + "))?" + ("([eE][+-]?(" + decimalDigits2 + "))?\\b") },
    // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
    { match: "\\b0x(" + hexDigits2 + ")(\\.(" + hexDigits2 + "))?" + ("([pP][+-]?(" + decimalDigits2 + "))?\\b") },
    // octal-literal
    { match: /\b0o([0-7]_*)+\b/ },
    // binary-literal
    { match: /\b0b([01]_*)+\b/ }
  ] };
  var ESCAPED_CHARACTER = function ESCAPED_CHARACTER2(rawDelimiter) {
    if (rawDelimiter === void 0) {
      rawDelimiter = "";
    }
    return { className: "subst", variants: [{ match: concat$1(/\\/, rawDelimiter, /[0\\tnr"']/) }, { match: concat$1(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/) }] };
  };
  var ESCAPED_NEWLINE = function ESCAPED_NEWLINE2(rawDelimiter) {
    if (rawDelimiter === void 0) {
      rawDelimiter = "";
    }
    return { className: "subst", match: concat$1(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/) };
  };
  var INTERPOLATION = function INTERPOLATION2(rawDelimiter) {
    if (rawDelimiter === void 0) {
      rawDelimiter = "";
    }
    return { className: "subst", label: "interpol", begin: concat$1(/\\/, rawDelimiter, /\(/), end: /\)/ };
  };
  var MULTILINE_STRING = function MULTILINE_STRING2(rawDelimiter) {
    if (rawDelimiter === void 0) {
      rawDelimiter = "";
    }
    return { begin: concat$1(rawDelimiter, /"""/), end: concat$1(/"""/, rawDelimiter), contains: [ESCAPED_CHARACTER(rawDelimiter), ESCAPED_NEWLINE(rawDelimiter), INTERPOLATION(rawDelimiter)] };
  };
  var SINGLE_LINE_STRING = function SINGLE_LINE_STRING2(rawDelimiter) {
    if (rawDelimiter === void 0) {
      rawDelimiter = "";
    }
    return { begin: concat$1(rawDelimiter, /"/), end: concat$1(/"/, rawDelimiter), contains: [ESCAPED_CHARACTER(rawDelimiter), INTERPOLATION(rawDelimiter)] };
  };
  var STRING = { className: "string", variants: [MULTILINE_STRING(), MULTILINE_STRING("#"), MULTILINE_STRING("##"), MULTILINE_STRING("###"), SINGLE_LINE_STRING(), SINGLE_LINE_STRING("#"), SINGLE_LINE_STRING("##"), SINGLE_LINE_STRING("###")] };
  var QUOTED_IDENTIFIER = { match: concat$1(/`/, identifier, /`/) };
  var IMPLICIT_PARAMETER = { className: "variable", match: /\$\d+/ };
  var PROPERTY_WRAPPER_PROJECTION = { className: "variable", match: "\\$" + identifierCharacter + "+" };
  var IDENTIFIERS = [QUOTED_IDENTIFIER, IMPLICIT_PARAMETER, PROPERTY_WRAPPER_PROJECTION];
  var AVAILABLE_ATTRIBUTE = { match: /(@|#(un)?)available/, className: "keyword", starts: { contains: [{ begin: /\(/, end: /\)/, keywords: availabilityKeywords, contains: [].concat(OPERATORS, [NUMBER, STRING]) }] } };
  var KEYWORD_ATTRIBUTE = { className: "keyword", match: concat$1(/@/, either$1.apply(void 0, keywordAttributes)) };
  var USER_DEFINED_ATTRIBUTE = { className: "meta", match: concat$1(/@/, identifier) };
  var ATTRIBUTES2 = [AVAILABLE_ATTRIBUTE, KEYWORD_ATTRIBUTE, USER_DEFINED_ATTRIBUTE];
  var TYPE = { match: lookahead$1(/\b[A-Z]/), relevance: 0, contains: [{
    // Common Apple frameworks, for relevance boost
    className: "type",
    match: concat$1(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, "+")
  }, {
    // Type identifier
    className: "type",
    match: typeIdentifier,
    relevance: 0
  }, {
    // Optional type
    match: /[?!]+/,
    relevance: 0
  }, {
    // Variadic parameter
    match: /\.\.\./,
    relevance: 0
  }, {
    // Protocol composition
    match: concat$1(/\s+&\s+/, lookahead$1(typeIdentifier)),
    relevance: 0
  }] };
  var GENERIC_ARGUMENTS = { begin: /</, end: />/, keywords: KEYWORDS2, contains: [].concat(COMMENTS, KEYWORD_MODES, ATTRIBUTES2, [OPERATOR_GUARD, TYPE]) };
  TYPE.contains.push(GENERIC_ARGUMENTS);
  var TUPLE_ELEMENT_NAME = { match: concat$1(identifier, /\s*:/), keywords: "_|0", relevance: 0 };
  var TUPLE = { begin: /\(/, end: /\)/, relevance: 0, keywords: KEYWORDS2, contains: ["self", TUPLE_ELEMENT_NAME].concat(COMMENTS, KEYWORD_MODES, BUILT_INS2, OPERATORS, [NUMBER, STRING], IDENTIFIERS, ATTRIBUTES2, [TYPE]) };
  var GENERIC_PARAMETERS = { begin: /</, end: />/, contains: [].concat(COMMENTS, [TYPE]) };
  var FUNCTION_PARAMETER_NAME = { begin: either$1(lookahead$1(concat$1(identifier, /\s*:/)), lookahead$1(concat$1(identifier, /\s+/, identifier, /\s*:/))), end: /:/, relevance: 0, contains: [{ className: "keyword", match: /\b_\b/ }, { className: "params", match: identifier }] };
  var FUNCTION_PARAMETERS = { begin: /\(/, end: /\)/, keywords: KEYWORDS2, contains: [FUNCTION_PARAMETER_NAME].concat(COMMENTS, KEYWORD_MODES, OPERATORS, [NUMBER, STRING], ATTRIBUTES2, [TYPE, TUPLE]), endsParent: true, illegal: /["']/ };
  var FUNCTION = { match: [/func/, /\s+/, either$1(QUOTED_IDENTIFIER.match, identifier, operator)], className: { 1: "keyword", 3: "title.function" }, contains: [GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE], illegal: [/\[/, /%/] };
  var INIT_SUBSCRIPT = { match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/], className: { 1: "keyword" }, contains: [GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE], illegal: /\[|%/ };
  var OPERATOR_DECLARATION = { match: [/operator/, /\s+/, operator], className: { 1: "keyword", 3: "title" } };
  var PRECEDENCEGROUP = { begin: [/precedencegroup/, /\s+/, typeIdentifier], className: { 1: "keyword", 3: "title" }, contains: [TYPE], keywords: [].concat(precedencegroupKeywords, literals), end: /}/ };
  for (var _iterator3 = _createForOfIteratorHelperLoose(STRING.variants), _step4; !(_step4 = _iterator3()).done; ) {
    var variant = _step4.value;
    var interpolation = variant.contains.find(function(mode) {
      return mode.label === "interpol";
    });
    interpolation.keywords = KEYWORDS2;
    var submodes = [].concat(KEYWORD_MODES, BUILT_INS2, OPERATORS, [NUMBER, STRING], IDENTIFIERS);
    interpolation.contains = [].concat(submodes, [{ begin: /\(/, end: /\)/, contains: ["self"].concat(submodes) }]);
  }
  return { name: "Swift", keywords: KEYWORDS2, contains: [].concat(COMMENTS, [FUNCTION, INIT_SUBSCRIPT, { beginKeywords: "struct protocol class extension enum actor", end: "\\{", excludeEnd: true, keywords: KEYWORDS2, contains: [hljs.inherit(hljs.TITLE_MODE, { className: "title.class", begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/ })].concat(KEYWORD_MODES) }, OPERATOR_DECLARATION, PRECEDENCEGROUP, { beginKeywords: "import", end: /$/, contains: [].concat(COMMENTS), relevance: 0 }], KEYWORD_MODES, BUILT_INS2, OPERATORS, [NUMBER, STRING], IDENTIFIERS, ATTRIBUTES2, [TYPE, TUPLE]) };
}
var IDENT_RE$1 = "[A-Za-z$_][0-9A-Za-z$_]*";
var KEYWORDS = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
var LITERALS = ["true", "false", "null", "undefined", "NaN", "Infinity"];
var TYPES = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
var ERROR_TYPES = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"];
var BUILT_IN_GLOBALS = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"];
var BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
var BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);
function javascript(hljs) {
  var regex = hljs.regex;
  var hasClosingTag = function hasClosingTag2(match, _ref250) {
    var after = _ref250.after;
    var tag = "</" + match[0].slice(1);
    var pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };
  var IDENT_RE$1$1 = IDENT_RE$1;
  var FRAGMENT = { begin: "<>", end: "</>" };
  var XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  var XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
    * @param {RegExpMatchArray} match
    * @param {CallbackResponse} response
    */
    isTrulyOpeningTag: function isTrulyOpeningTag(match, response) {
      var afterMatchIndex = match[0].length + match.index;
      var nextChar = match.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      var m;
      var afterMatch = match.input.substring(afterMatchIndex);
      if (m = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m = afterMatch.match(/^\s+extends\s+/)) {
        if (m.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  var KEYWORDS$12 = { $pattern: IDENT_RE$1, keyword: KEYWORDS, literal: LITERALS, built_in: BUILT_INS, "variable.language": BUILT_IN_VARIABLES };
  var decimalDigits2 = "[0-9](_?[0-9])*";
  var frac2 = "\\.(" + decimalDigits2 + ")";
  var decimalInteger = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*";
  var NUMBER = { className: "number", variants: [
    // DecimalLiteral
    { begin: "(\\b(" + decimalInteger + ")((" + frac2 + ")|\\.)?|(" + frac2 + "))" + ("[eE][+-]?(" + decimalDigits2 + ")\\b") },
    { begin: "\\b(" + decimalInteger + ")\\b((" + frac2 + ")\\b|\\.)?|(" + frac2 + ")\\b" },
    // DecimalBigIntegerLiteral
    { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
    // NonDecimalIntegerLiteral
    { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
    { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
    { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
    // LegacyOctalIntegerLiteral (does not include underscore separators)
    // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
    { begin: "\\b0[0-7]+n?\\b" }
  ], relevance: 0 };
  var SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$12,
    contains: []
    // defined later
  };
  var HTML_TEMPLATE = { begin: "html`", end: "", starts: { end: "`", returnEnd: false, contains: [hljs.BACKSLASH_ESCAPE, SUBST], subLanguage: "xml" } };
  var CSS_TEMPLATE = { begin: "css`", end: "", starts: { end: "`", returnEnd: false, contains: [hljs.BACKSLASH_ESCAPE, SUBST], subLanguage: "css" } };
  var GRAPHQL_TEMPLATE = { begin: "gql`", end: "", starts: { end: "`", returnEnd: false, contains: [hljs.BACKSLASH_ESCAPE, SUBST], subLanguage: "graphql" } };
  var TEMPLATE_STRING = { className: "string", begin: "`", end: "`", contains: [hljs.BACKSLASH_ESCAPE, SUBST] };
  var JSDOC_COMMENT = hljs.COMMENT(/\/\*\*(?!\/)/, "\\*/", { relevance: 0, contains: [{ begin: "(?=@[A-Za-z]+)", relevance: 0, contains: [
    { className: "doctag", begin: "@[A-Za-z]+" },
    { className: "type", begin: "\\{", end: "\\}", excludeEnd: true, excludeBegin: true, relevance: 0 },
    { className: "variable", begin: IDENT_RE$1$1 + "(?=\\s*(-)|$)", endsParent: true, relevance: 0 },
    // eat spaces (not newlines) so we can find
    // types or variables
    { begin: /(?=[^\n])\s/, relevance: 0 }
  ] }] });
  var COMMENT3 = { className: "comment", variants: [JSDOC_COMMENT, hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE] };
  var SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$12,
    contains: ["self"].concat(SUBST_INTERNALS)
  });
  var SUBST_AND_COMMENTS = [].concat(COMMENT3, SUBST.contains);
  var PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    { begin: /\(/, end: /\)/, keywords: KEYWORDS$12, contains: ["self"].concat(SUBST_AND_COMMENTS) }
  ]);
  var PARAMS = { className: "params", begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: KEYWORDS$12, contains: PARAMS_CONTAINS };
  var CLASS_OR_EXTENDS = { variants: [
    // class Car extends vehicle
    { match: [/class/, /\s+/, IDENT_RE$1$1, /\s+/, /extends/, /\s+/, regex.concat(IDENT_RE$1$1, "(", regex.concat(/\./, IDENT_RE$1$1), ")*")], scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" } },
    // class Car
    { match: [/class/, /\s+/, IDENT_RE$1$1], scope: { 1: "keyword", 3: "title.class" } }
  ] };
  var CLASS_REFERENCE = { relevance: 0, match: regex.either(
    // Hard coded exceptions
    /\bJSON/,
    // Float32Array, OutT
    /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
    // CSSFactory, CSSFactoryT
    /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
    // FPs, FPsT
    /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
    // P
    // single letters are not highlighted
    // BLAH
    // this will be flagged as a UPPER_CASE_CONSTANT instead
  ), className: "title.class", keywords: { _: [].concat(TYPES, ERROR_TYPES) } };
  var USE_STRICT = { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ };
  var FUNCTION_DEFINITION = { variants: [
    { match: [/function/, /\s+/, IDENT_RE$1$1, /(?=\s*\()/] },
    // anonymous function
    { match: [/function/, /\s*(?=\()/] }
  ], className: { 1: "keyword", 3: "title.function" }, label: "func.def", contains: [PARAMS], illegal: /%/ };
  var UPPER_CASE_CONSTANT = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" };
  function noneOf(list) {
    return regex.concat("(?!", list.join("|"), ")");
  }
  var FUNCTION_CALL = { match: regex.concat(/\b/, noneOf([].concat(BUILT_IN_GLOBALS, ["super", "import"])), IDENT_RE$1$1, regex.lookahead(/\(/)), className: "title.function", relevance: 0 };
  var PROPERTY_ACCESS = { begin: regex.concat(/\./, regex.lookahead(regex.concat(IDENT_RE$1$1, /(?![0-9A-Za-z$_(])/))), end: IDENT_RE$1$1, excludeBegin: true, keywords: "prototype", className: "property", relevance: 0 };
  var GETTER_OR_SETTER = { match: [/get|set/, /\s+/, IDENT_RE$1$1, /(?=\()/], className: { 1: "keyword", 3: "title.function" }, contains: [{
    // eat to avoid empty params
    begin: /\(\)/
  }, PARAMS] };
  var FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  var FUNCTION_VARIABLE = { match: [
    /const|var|let/,
    /\s+/,
    IDENT_RE$1$1,
    /\s*/,
    /=\s*/,
    /(async\s*)?/,
    // async is optional
    regex.lookahead(FUNC_LEAD_IN_RE)
  ], keywords: "async", className: { 1: "keyword", 3: "title.function" }, contains: [PARAMS] };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$12,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT3,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      { className: "attr", begin: IDENT_RE$1$1 + regex.lookahead(":"), relevance: 0 },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [COMMENT3, hljs.REGEXP_MODE, {
          className: "function",
          // we have to count the parens to make sure we actually have the
          // correct bounding ( ) before the =>.  There could be any number of
          // sub-expressions inside also surrounded by parens.
          begin: FUNC_LEAD_IN_RE,
          returnBegin: true,
          end: "\\s*=>",
          contains: [{ className: "params", variants: [{ begin: hljs.UNDERSCORE_IDENT_RE, relevance: 0 }, { className: null, begin: /\(\s*\)/, skip: true }, { begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: KEYWORDS$12, contains: PARAMS_CONTAINS }] }]
        }, {
          // could be a comma delimited list of params to a function call
          begin: /,/,
          relevance: 0
        }, { match: /\s+/, relevance: 0 }, {
          // JSX
          variants: [{ begin: FRAGMENT.begin, end: FRAGMENT.end }, { match: XML_SELF_CLOSING }, {
            begin: XML_TAG.begin,
            // we carefully check the opening tag to see if it truly
            // is a tag and not a false positive
            "on:begin": XML_TAG.isTrulyOpeningTag,
            end: XML_TAG.end
          }],
          subLanguage: "xml",
          contains: [{ begin: XML_TAG.begin, end: XML_TAG.end, skip: true, contains: ["self"] }]
        }]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [PARAMS, hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1, className: "title.function" })]
      },
      // catch ... so it won't trigger the property rule below
      { match: /\.\.\./, relevance: 0 },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      { match: "\\$" + IDENT_RE$1$1, relevance: 0 },
      { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [PARAMS] },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function typescript(hljs) {
  var tsLanguage = javascript(hljs);
  var IDENT_RE$1$1 = IDENT_RE$1;
  var TYPES2 = ["any", "void", "number", "boolean", "string", "object", "never", "symbol", "bigint", "unknown"];
  var NAMESPACE = { beginKeywords: "namespace", end: /\{/, excludeEnd: true, contains: [tsLanguage.exports.CLASS_REFERENCE] };
  var INTERFACE = { beginKeywords: "interface", end: /\{/, excludeEnd: true, keywords: { keyword: "interface extends", built_in: TYPES2 }, contains: [tsLanguage.exports.CLASS_REFERENCE] };
  var USE_STRICT = { className: "meta", relevance: 10, begin: /^\s*['"]use strict['"]/ };
  var TS_SPECIFIC_KEYWORDS = ["type", "namespace", "interface", "public", "private", "protected", "implements", "declare", "abstract", "readonly", "enum", "override"];
  var KEYWORDS$12 = { $pattern: IDENT_RE$1, keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS), literal: LITERALS, built_in: BUILT_INS.concat(TYPES2), "variable.language": BUILT_IN_VARIABLES };
  var DECORATOR = { className: "meta", begin: "@" + IDENT_RE$1$1 };
  var swapMode = function swapMode2(mode, label, replacement) {
    var indx = mode.contains.findIndex(function(m) {
      return m.label === label;
    });
    if (indx === -1) {
      throw new Error("can not find mode to replace");
    }
    mode.contains.splice(indx, 1, replacement);
  };
  Object.assign(tsLanguage.keywords, KEYWORDS$12);
  tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
  tsLanguage.contains = tsLanguage.contains.concat([DECORATOR, NAMESPACE, INTERFACE]);
  swapMode(tsLanguage, "shebang", hljs.SHEBANG());
  swapMode(tsLanguage, "use_strict", USE_STRICT);
  var functionDeclaration = tsLanguage.contains.find(function(m) {
    return m.label === "func.def";
  });
  functionDeclaration.relevance = 0;
  Object.assign(tsLanguage, { name: "TypeScript", aliases: ["ts", "tsx", "mts", "cts"] });
  return tsLanguage;
}
function vbnet(hljs) {
  var regex = hljs.regex;
  var CHARACTER = { className: "string", begin: /"(""|[^/n])"C\b/ };
  var STRING = { className: "string", begin: /"/, end: /"/, illegal: /\n/, contains: [{
    // double quote escape
    begin: /""/
  }] };
  var MM_DD_YYYY = /\d{1,2}\/\d{1,2}\/\d{4}/;
  var YYYY_MM_DD = /\d{4}-\d{1,2}-\d{1,2}/;
  var TIME_12H = /(\d|1[012])(:\d+){0,2} *(AM|PM)/;
  var TIME_24H = /\d{1,2}(:\d{1,2}){1,2}/;
  var DATE = { className: "literal", variants: [{
    // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
    begin: regex.concat(/# */, regex.either(YYYY_MM_DD, MM_DD_YYYY), / *#/)
  }, {
    // #H:mm[:ss]# (24h Time)
    begin: regex.concat(/# */, TIME_24H, / *#/)
  }, {
    // #h[:mm[:ss]] A# (12h Time)
    begin: regex.concat(/# */, TIME_12H, / *#/)
  }, {
    // date plus time
    begin: regex.concat(/# */, regex.either(YYYY_MM_DD, MM_DD_YYYY), / +/, regex.either(TIME_12H, TIME_24H), / *#/)
  }] };
  var NUMBER = { className: "number", relevance: 0, variants: [{
    // Float
    begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
  }, {
    // Integer (base 10)
    begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
  }, {
    // Integer (base 16)
    begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
  }, {
    // Integer (base 8)
    begin: /&O[0-7_]+((U?[SIL])|[%&])?/
  }, {
    // Integer (base 2)
    begin: /&B[01_]+((U?[SIL])|[%&])?/
  }] };
  var LABEL = { className: "label", begin: /^\w+:/ };
  var DOC_COMMENT = hljs.COMMENT(/'''/, /$/, { contains: [{ className: "doctag", begin: /<\/?/, end: />/ }] });
  var COMMENT3 = hljs.COMMENT(null, /$/, { variants: [{ begin: /'/ }, {
    // TODO: Use multi-class for leading spaces
    begin: /([\t ]|^)REM(?=\s)/
  }] });
  var DIRECTIVES = {
    className: "meta",
    // TODO: Use multi-class for indentation once available
    begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
    end: /$/,
    keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
    contains: [COMMENT3]
  };
  return { name: "Visual Basic .NET", aliases: ["vb"], case_insensitive: true, classNameAliases: { label: "symbol" }, keywords: { keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield", built_in: (
    // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
    "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
  ), type: (
    // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
    "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
  ), literal: "true false nothing" }, illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ", contains: [CHARACTER, STRING, DATE, NUMBER, LABEL, DOC_COMMENT, COMMENT3, DIRECTIVES] };
}
function wasm(hljs) {
  hljs.regex;
  var BLOCK_COMMENT = hljs.COMMENT(/\(;/, /;\)/);
  BLOCK_COMMENT.contains.push("self");
  var LINE_COMMENT = hljs.COMMENT(/;;/, /$/);
  var KWS = ["anyfunc", "block", "br", "br_if", "br_table", "call", "call_indirect", "data", "drop", "elem", "else", "end", "export", "func", "global.get", "global.set", "local.get", "local.set", "local.tee", "get_global", "get_local", "global", "if", "import", "local", "loop", "memory", "memory.grow", "memory.size", "module", "mut", "nop", "offset", "param", "result", "return", "select", "set_global", "set_local", "start", "table", "tee_local", "then", "type", "unreachable"];
  var FUNCTION_REFERENCE = { begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/], className: { 1: "keyword", 3: "title.function" } };
  var ARGUMENT = { className: "variable", begin: /\$[\w_]+/ };
  var PARENS = { match: /(\((?!;)|\))+/, className: "punctuation", relevance: 0 };
  var NUMBER = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  };
  var TYPE = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  };
  var MATH_OPERATIONS = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  var OFFSET_ALIGN = { match: [/(?:offset|align)/, /\s*/, /=/], className: { 1: "keyword", 3: "operator" } };
  return { name: "WebAssembly", keywords: { $pattern: /[\w.]+/, keyword: KWS }, contains: [LINE_COMMENT, BLOCK_COMMENT, OFFSET_ALIGN, ARGUMENT, PARENS, FUNCTION_REFERENCE, hljs.QUOTE_STRING_MODE, TYPE, MATH_OPERATIONS, NUMBER] };
}
function xml(hljs) {
  var regex = hljs.regex;
  var TAG_NAME_RE = regex.concat(/(?:[A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])/, regex.optional(/(?:[\x2D\.0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*:/), /(?:[\x2D\.0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*/);
  var XML_IDENT_RE = /(?:[\x2D\.0-:A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])+/;
  var XML_ENTITIES = { className: "symbol", begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ };
  var XML_META_KEYWORDS = { begin: /\s/, contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }] };
  var XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, { begin: /\(/, end: /\)/ });
  var APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
  var QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
  var TAG_INTERNALS = { endsWithParent: true, illegal: /</, relevance: 0, contains: [{ className: "attr", begin: XML_IDENT_RE, relevance: 0 }, { begin: /=\s*/, relevance: 0, contains: [{ className: "string", endsParent: true, variants: [{ begin: /"/, end: /"/, contains: [XML_ENTITIES] }, { begin: /'/, end: /'/, contains: [XML_ENTITIES] }, { begin: /[^\s"'=<>`]+/ }] }] }] };
  return { name: "HTML, XML", aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"], case_insensitive: true, unicodeRegex: true, contains: [
    { className: "meta", begin: /<![a-z]/, end: />/, relevance: 10, contains: [XML_META_KEYWORDS, QUOTE_META_STRING_MODE, APOS_META_STRING_MODE, XML_META_PAR_KEYWORDS, { begin: /\[/, end: /\]/, contains: [{ className: "meta", begin: /<![a-z]/, end: />/, contains: [XML_META_KEYWORDS, XML_META_PAR_KEYWORDS, QUOTE_META_STRING_MODE, APOS_META_STRING_MODE] }] }] },
    hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),
    { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
    XML_ENTITIES,
    // xml processing instructions
    { className: "meta", end: /\?>/, variants: [{ begin: /<\?xml/, relevance: 10, contains: [QUOTE_META_STRING_MODE] }, { begin: /<\?[a-z][a-z0-9]+/ }] },
    {
      className: "tag",
      /*
      The lookahead pattern (?=...) ensures that 'begin' only matches
      '<style' as a single word, followed by a whitespace or an
      ending bracket.
      */
      begin: /<style(?=\s|>)/,
      end: />/,
      keywords: { name: "style" },
      contains: [TAG_INTERNALS],
      starts: { end: /<\/style>/, returnEnd: true, subLanguage: ["css", "xml"] }
    },
    {
      className: "tag",
      // See the comment in the <style tag about the lookahead pattern
      begin: /<script(?=\s|>)/,
      end: />/,
      keywords: { name: "script" },
      contains: [TAG_INTERNALS],
      starts: { end: /<\/script>/, returnEnd: true, subLanguage: ["javascript", "handlebars", "xml"] }
    },
    // we need this for now for jSX
    { className: "tag", begin: /<>|<\/>/ },
    // open tag
    { className: "tag", begin: regex.concat(/</, regex.lookahead(regex.concat(
      TAG_NAME_RE,
      // <tag/>
      // <tag>
      // <tag ...
      regex.either(/\/>/, />/, /\s/)
    ))), end: /\/?>/, contains: [{ className: "name", begin: TAG_NAME_RE, relevance: 0, starts: TAG_INTERNALS }] },
    // close tag
    { className: "tag", begin: regex.concat(/<\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))), contains: [{ className: "name", begin: TAG_NAME_RE, relevance: 0 }, { begin: />/, relevance: 0, endsParent: true }] }
  ] };
}
function yaml(hljs) {
  var LITERALS2 = "true false yes no null";
  var URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
  var KEY = { className: "attr", variants: [{ begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" }, {
    // double quoted keys
    begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
  }, {
    // single quoted keys
    begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
  }] };
  var TEMPLATE_VARIABLES = { className: "template-variable", variants: [{
    // jinja templates Ansible
    begin: /\{\{/,
    end: /\}\}/
  }, {
    // Ruby i18n
    begin: /%\{/,
    end: /\}/
  }] };
  var STRING = { className: "string", relevance: 0, variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /\S+/ }], contains: [hljs.BACKSLASH_ESCAPE, TEMPLATE_VARIABLES] };
  var CONTAINER_STRING = hljs.inherit(STRING, { variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /[^\s,{}[\]]+/ }] });
  var DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
  var TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
  var FRACTION_RE = "(\\.[0-9]*)?";
  var ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
  var TIMESTAMP = { className: "number", begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b" };
  var VALUE_CONTAINER = { end: ",", endsWithParent: true, excludeEnd: true, keywords: LITERALS2, relevance: 0 };
  var OBJECT = { begin: /\{/, end: /\}/, contains: [VALUE_CONTAINER], illegal: "\\n", relevance: 0 };
  var ARRAY = { begin: "\\[", end: "\\]", contains: [VALUE_CONTAINER], illegal: "\\n", relevance: 0 };
  var MODES2 = [
    KEY,
    { className: "meta", begin: "^---\\s*$", relevance: 10 },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: true,
      excludeEnd: true,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + URI_CHARACTERS
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + URI_CHARACTERS + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + URI_CHARACTERS
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + URI_CHARACTERS
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    hljs.HASH_COMMENT_MODE,
    { beginKeywords: LITERALS2, keywords: { literal: LITERALS2 } },
    TIMESTAMP,
    // numbers are any valid C-style number that
    // sit isolated from other words
    { className: "number", begin: hljs.C_NUMBER_RE + "\\b", relevance: 0 },
    OBJECT,
    ARRAY,
    STRING
  ];
  var VALUE_MODES = [].concat(MODES2);
  VALUE_MODES.pop();
  VALUE_MODES.push(CONTAINER_STRING);
  VALUE_CONTAINER.contains = VALUE_MODES;
  return { name: "YAML", case_insensitive: true, aliases: ["yml"], contains: MODES2 };
}
function deepFreeze(obj) {
  if (obj instanceof Map) {
    obj.clear = obj.delete = obj.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj instanceof Set) {
    obj.add = obj.clear = obj.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach(function(name) {
    var prop = obj[name];
    var type = typeof prop;
    if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj;
}
var Response = /* @__PURE__ */ function() {
  function Response2(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  var _proto87 = Response2.prototype;
  _proto87.ignoreMatch = function ignoreMatch() {
    this.isMatchIgnored = true;
  };
  return Response2;
}();
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original) {
  var result = /* @__PURE__ */ Object.create(null);
  for (var key in original) {
    result[key] = original[key];
  }
  for (var _len11 = arguments.length, objects = new Array(_len11 > 1 ? _len11 - 1 : 0), _key12 = 1; _key12 < _len11; _key12++) {
    objects[_key12 - 1] = arguments[_key12];
  }
  objects.forEach(function(obj) {
    for (var _key13 in obj) {
      result[_key13] = obj[_key13];
    }
  });
  return (
    /** @type {T} */
    result
  );
}
var SPAN_CLOSE = "</span>";
var emitsWrappingTags = function emitsWrappingTags2(node) {
  return !!node.scope;
};
var scopeToCSSClass = function scopeToCSSClass2(name, _ref251) {
  var prefix = _ref251.prefix;
  if (name.startsWith("language:")) {
    return name.replace("language:", "language-");
  }
  if (name.includes(".")) {
    var pieces = name.split(".");
    return ["" + prefix + pieces.shift()].concat(pieces.map(function(x, i) {
      return "" + x + "_".repeat(i + 1);
    })).join(" ");
  }
  return "" + prefix + name;
};
var HTMLRenderer = /* @__PURE__ */ function() {
  function HTMLRenderer2(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  var _proto88 = HTMLRenderer2.prototype;
  _proto88.addText = function addText(text) {
    this.buffer += escapeHTML(text);
  };
  _proto88.openNode = function openNode(node) {
    if (!emitsWrappingTags(node))
      return;
    var className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
    this.span(className);
  };
  _proto88.closeNode = function closeNode(node) {
    if (!emitsWrappingTags(node))
      return;
    this.buffer += SPAN_CLOSE;
  };
  _proto88.value = function value() {
    return this.buffer;
  };
  _proto88.span = function span(className) {
    this.buffer += '<span class="' + className + '">';
  };
  return HTMLRenderer2;
}();
var newNode = function newNode2(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var result = { children: [] };
  Object.assign(result, opts);
  return result;
};
var TokenTree = /* @__PURE__ */ function() {
  function TokenTree2() {
    this.rootNode = newNode();
    this.stack = [this.rootNode];
  }
  var _proto89 = TokenTree2.prototype;
  _proto89.add = function add(node) {
    this.top.children.push(node);
  };
  _proto89.openNode = function openNode(scope) {
    var node = newNode({ scope });
    this.add(node);
    this.stack.push(node);
  };
  _proto89.closeNode = function closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  };
  _proto89.closeAllNodes = function closeAllNodes() {
    while (this.closeNode())
      ;
  };
  _proto89.toJSON = function toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  };
  _proto89.walk = function walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  };
  TokenTree2._walk = function _walk(builder, node) {
    var _this129 = this;
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach(function(child) {
        return _this129._walk(builder, child);
      });
      builder.closeNode(node);
    }
    return builder;
  };
  TokenTree2._collapse = function _collapse(node) {
    if (typeof node === "string")
      return;
    if (!node.children)
      return;
    if (node.children.every(function(el) {
      return typeof el === "string";
    })) {
      node.children = [node.children.join("")];
    } else {
      node.children.forEach(function(child) {
        TokenTree2._collapse(child);
      });
    }
  };
  _createClass(TokenTree2, [{ key: "top", get: function get5() {
    return this.stack[this.stack.length - 1];
  } }, { key: "root", get: function get5() {
    return this.rootNode;
  } }]);
  return TokenTree2;
}();
var TokenTreeEmitter = /* @__PURE__ */ function(_TokenTree) {
  _inheritsLoose(TokenTreeEmitter2, _TokenTree);
  function TokenTreeEmitter2(options) {
    var _this130;
    _this130 = _TokenTree.call(this) || this;
    _this130.options = options;
    return _this130;
  }
  var _proto90 = TokenTreeEmitter2.prototype;
  _proto90.addText = function addText(text) {
    if (text === "") {
      return;
    }
    this.add(text);
  };
  _proto90.startScope = function startScope(scope) {
    this.openNode(scope);
  };
  _proto90.endScope = function endScope() {
    this.closeNode();
  };
  _proto90.__addSublanguage = function __addSublanguage(emitter, name) {
    var node = emitter.root;
    if (name)
      node.scope = "language:" + name;
    this.add(node);
  };
  _proto90.toHTML = function toHTML() {
    var renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  };
  _proto90.finalize = function finalize() {
    this.closeAllNodes();
    return true;
  };
  return TokenTreeEmitter2;
}(TokenTree);
function source(re) {
  if (!re)
    return null;
  if (typeof re === "string")
    return re;
  return re.source;
}
function lookahead(re) {
  return concat("(?=", re, ")");
}
function anyNumberOfTimes(re) {
  return concat("(?:", re, ")*");
}
function optional(re) {
  return concat("(?:", re, ")?");
}
function concat() {
  for (var _len12 = arguments.length, args = new Array(_len12), _key14 = 0; _key14 < _len12; _key14++) {
    args[_key14] = arguments[_key14];
  }
  var joined = args.map(function(x) {
    return source(x);
  }).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  var opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either() {
  for (var _len13 = arguments.length, args = new Array(_len13), _key15 = 0; _key15 < _len13; _key15++) {
    args[_key15] = arguments[_key15];
  }
  var opts = stripOptionsFromArgs(args);
  var joined = "(" + (opts.capture ? "" : "?:") + args.map(function(x) {
    return source(x);
  }).join("|") + ")";
  return joined;
}
function countMatchGroups(re) {
  return new RegExp(re.toString() + "|").exec("").length - 1;
}
function startsWith(re, lexeme) {
  var match = re && re.exec(lexeme);
  return match && match.index === 0;
}
var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences(regexps, _ref252) {
  var joinWith = _ref252.joinWith;
  var numCaptures = 0;
  return regexps.map(function(regex) {
    numCaptures += 1;
    var offset2 = numCaptures;
    var re = source(regex);
    var out = "";
    while (re.length > 0) {
      var match = BACKREF_RE.exec(re);
      if (!match) {
        out += re;
        break;
      }
      out += re.substring(0, match.index);
      re = re.substring(match.index + match[0].length);
      if (match[0][0] === "\\" && match[1]) {
        out += "\\" + String(Number(match[1]) + offset2);
      } else {
        out += match[0];
        if (match[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map(function(re) {
    return "(" + re + ")";
  }).join(joinWith);
}
var MATCH_NOTHING_RE = /\b\B/;
var IDENT_RE = "[a-zA-Z]\\w*";
var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
var BINARY_NUMBER_RE = "\\b(0b[01]+)";
var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
var SHEBANG = function SHEBANG2(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(beginShebang, /.*\b/, opts.binary, /\b.*/);
  }
  return inherit$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": function onBegin(m, resp) {
      if (m.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
var BACKSLASH_ESCAPE = { begin: "\\\\[\\s\\S]", relevance: 0 };
var APOS_STRING_MODE = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [BACKSLASH_ESCAPE] };
var QUOTE_STRING_MODE = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [BACKSLASH_ESCAPE] };
var PHRASAL_WORDS_MODE = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ };
var COMMENT = function COMMENT2(begin, end2, modeOptions) {
  if (modeOptions === void 0) {
    modeOptions = {};
  }
  var mode = inherit$1({ scope: "comment", begin, end: end2, contains: [] }, modeOptions);
  mode.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  var ENGLISH_WORD = either(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  mode.contains.push({
    // TODO: how to include ", (, ) without breaking grammars that use these for
    // comment delimiters?
    // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
    // ---
    // this tries to find sequences of 3 english words in a row (without any
    // "programming" type syntax) this gives us a strong signal that we've
    // TRULY found a comment - vs perhaps scanning with the wrong language.
    // It's possible to find something that LOOKS like the start of the
    // comment - but then if there is no readable text - good chance it is a
    // false match and not a comment.
    //
    // for a visual example please see:
    // https://github.com/highlightjs/highlight.js/issues/2827
    begin: concat(
      /[ ]+/,
      // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
      "(",
      ENGLISH_WORD,
      /[.]?[:]?([.][ ]|[ ])/,
      "){3}"
    )
    // look for 3 words in a row
  });
  return mode;
};
var C_LINE_COMMENT_MODE = COMMENT("//", "$");
var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
var HASH_COMMENT_MODE = COMMENT("#", "$");
var NUMBER_MODE = { scope: "number", begin: NUMBER_RE, relevance: 0 };
var C_NUMBER_MODE = { scope: "number", begin: C_NUMBER_RE, relevance: 0 };
var BINARY_NUMBER_MODE = { scope: "number", begin: BINARY_NUMBER_RE, relevance: 0 };
var REGEXP_MODE = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{ scope: "regexp", begin: /\//, end: /\/[gimuy]*/, illegal: /\n/, contains: [BACKSLASH_ESCAPE, { begin: /\[/, end: /\]/, relevance: 0, contains: [BACKSLASH_ESCAPE] }] }]
};
var TITLE_MODE = { scope: "title", begin: IDENT_RE, relevance: 0 };
var UNDERSCORE_TITLE_MODE = { scope: "title", begin: UNDERSCORE_IDENT_RE, relevance: 0 };
var METHOD_GUARD = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
  relevance: 0
};
var END_SAME_AS_BEGIN = function END_SAME_AS_BEGIN2(mode) {
  return Object.assign(mode, {
    /** @type {ModeCallback} */
    "on:begin": function onBegin(m, resp) {
      resp.data._beginMatch = m[1];
    },
    /** @type {ModeCallback} */
    "on:end": function onEnd(m, resp) {
      if (resp.data._beginMatch !== m[1])
        resp.ignoreMatch();
    }
  });
};
var MODES = /* @__PURE__ */ Object.freeze({ __proto__: null, MATCH_NOTHING_RE, IDENT_RE, UNDERSCORE_IDENT_RE, NUMBER_RE, C_NUMBER_RE, BINARY_NUMBER_RE, RE_STARTERS_RE, SHEBANG, BACKSLASH_ESCAPE, APOS_STRING_MODE, QUOTE_STRING_MODE, PHRASAL_WORDS_MODE, COMMENT, C_LINE_COMMENT_MODE, C_BLOCK_COMMENT_MODE, HASH_COMMENT_MODE, NUMBER_MODE, C_NUMBER_MODE, BINARY_NUMBER_MODE, REGEXP_MODE, TITLE_MODE, UNDERSCORE_TITLE_MODE, METHOD_GUARD, END_SAME_AS_BEGIN });
function skipIfHasPrecedingDot(match, response) {
  var before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either.apply(void 0, mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
var beforeMatchExt = function beforeMatchExt2(mode, parent) {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  var originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach(function(key) {
    delete mode[key];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
  mode.starts = { relevance: 0, contains: [Object.assign(originalMode, { endsParent: true })] };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
var COMMON_KEYWORDS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
];
var DEFAULT_KEYWORD_SCOPE = "keyword";
function compileKeywords(rawKeywords, caseInsensitive, scopeName) {
  if (scopeName === void 0) {
    scopeName = DEFAULT_KEYWORD_SCOPE;
  }
  var compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2));
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map(function(x) {
        return x.toLowerCase();
      });
    }
    keywordList.forEach(function(keyword) {
      var pair = keyword.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword) ? 0 : 1;
}
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}
var seenDeprecations = {};
var error = function error2(message) {
  console.error(message);
};
var warn = function warn2(message) {
  var _console4;
  for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key16 = 1; _key16 < _len14; _key16++) {
    args[_key16 - 1] = arguments[_key16];
  }
  (_console4 = console).log.apply(_console4, ["WARN: " + message].concat(args));
};
var deprecated = function deprecated2(version2, message) {
  if (seenDeprecations[version2 + "/" + message])
    return;
  console.log("Deprecated as of " + version2 + ". " + message);
  seenDeprecations[version2 + "/" + message] = true;
};
var MultiClassError = new Error();
function remapScopeNames(mode, regexes, _ref253) {
  var key = _ref253.key;
  var offset2 = 0;
  var scopeNames = mode[key];
  var emit = {};
  var positions = {};
  for (var _i268 = 1; _i268 <= regexes.length; _i268++) {
    positions[_i268 + offset2] = scopeNames[_i268];
    emit[_i268 + offset2] = true;
    offset2 += countMatchGroups(regexes[_i268 - 1]);
  }
  mode[key] = positions;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language) {
  function langRe(value, global) {
    return new RegExp(source(value), "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global ? "g" : ""));
  }
  var MultiRegex = /* @__PURE__ */ function() {
    function MultiRegex2() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    var _proto91 = MultiRegex2.prototype;
    _proto91.addRule = function addRule(re, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re]);
      this.matchAt += countMatchGroups(re) + 1;
    };
    _proto91.compile = function compile() {
      if (this.regexes.length === 0) {
        this.exec = function() {
          return null;
        };
      }
      var terminators = this.regexes.map(function(el) {
        return el[1];
      });
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    };
    _proto91.exec = function exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      var match = this.matcherRe.exec(s);
      if (!match) {
        return null;
      }
      var i = match.findIndex(function(el, i2) {
        return i2 > 0 && el !== void 0;
      });
      var matchData = this.matchIndexes[i];
      match.splice(0, i);
      return Object.assign(match, matchData);
    };
    return MultiRegex2;
  }();
  var ResumableMultiRegex = /* @__PURE__ */ function() {
    function ResumableMultiRegex2() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    var _proto92 = ResumableMultiRegex2.prototype;
    _proto92.getMatcher = function getMatcher(index) {
      if (this.multiRegexes[index])
        return this.multiRegexes[index];
      var matcher = new MultiRegex();
      this.rules.slice(index).forEach(function(_ref254) {
        var re = _ref254[0], opts = _ref254[1];
        return matcher.addRule(re, opts);
      });
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    };
    _proto92.resumingScanAtSamePosition = function resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    };
    _proto92.considerAll = function considerAll() {
      this.regexIndex = 0;
    };
    _proto92.addRule = function addRule(re, opts) {
      this.rules.push([re, opts]);
      if (opts.type === "begin")
        this.count++;
    };
    _proto92.exec = function exec(s) {
      var m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      var result = m.exec(s);
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex)
          ;
        else {
          var m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result = m2.exec(s);
        }
      }
      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result;
    };
    return ResumableMultiRegex2;
  }();
  function buildModeRegex(mode) {
    var mm = new ResumableMultiRegex();
    mode.contains.forEach(function(term) {
      return mm.addRule(term.begin, { rule: term, type: "begin" });
    });
    if (mode.terminatorEnd) {
      mm.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm.addRule(mode.illegal, { type: "illegal" });
    }
    return mm;
  }
  function compileMode(mode, parent) {
    var _ref255;
    var cmode = (
      /** @type CompiledMode */
      mode
    );
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach(function(ext) {
      return ext(mode, parent);
    });
    language.compilerExtensions.forEach(function(ext) {
      return ext(mode, parent);
    });
    mode.__beforeBegin = null;
    [
      beginKeywords,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal,
      // default to 1 relevance if not specified
      compileRelevance
    ].forEach(function(ext) {
      return ext(mode, parent);
    });
    mode.isCompiled = true;
    var keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(
        /** @type {RegExp | string} */
        mode.illegal
      );
    if (!mode.contains)
      mode.contains = [];
    mode.contains = (_ref255 = []).concat.apply(_ref255, mode.contains.map(function(c2) {
      return expandOrCloneMode(c2 === "self" ? mode : c2);
    }));
    mode.contains.forEach(function(c2) {
      compileMode(
        /** @type Mode */
        c2,
        cmode
      );
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1(language.classNameAliases || {});
  return compileMode(
    /** @type Mode */
    language
  );
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
var version$1 = "11.8.0";
var HTMLInjectionError = /* @__PURE__ */ function(_Error4) {
  _inheritsLoose(HTMLInjectionError2, _Error4);
  function HTMLInjectionError2(reason, html) {
    var _this131;
    _this131 = _Error4.call(this, reason) || this;
    _this131.name = "HTMLInjectionError";
    _this131.html = html;
    return _this131;
  }
  return HTMLInjectionError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var escape = escapeHTML;
var inherit = inherit$1;
var NO_MATCH = Symbol("nomatch");
var MAX_KEYWORD_HITS = 7;
var HLJS = function HLJS2(hljs) {
  var languages = /* @__PURE__ */ Object.create(null);
  var aliases = /* @__PURE__ */ Object.create(null);
  var plugins = [];
  var SAFE_MODE = true;
  var LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  var PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
  var options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    var classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    var match = options.languageDetectRe.exec(classes);
    if (match) {
      var language = getLanguage(match[1]);
      if (!language) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match[1] : "no-highlight";
    }
    return classes.split(/\s+/).find(function(_class) {
      return shouldNotHighlight(_class) || getLanguage(_class);
    });
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    var code = "";
    var languageName = "";
    if (typeof optionsOrCode === "object") {
      code = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    var context = { code, language: languageName };
    fire("before:highlight", context);
    var result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result.code = context.code;
    fire("after:highlight", result);
    return result;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    var keywordHits = /* @__PURE__ */ Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top2.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      var lastIndex = 0;
      top2.keywordPatternRe.lastIndex = 0;
      var match2 = top2.keywordPatternRe.exec(modeBuffer);
      var buf = "";
      while (match2) {
        buf += modeBuffer.substring(lastIndex, match2.index);
        var word = language.case_insensitive ? match2[0].toLowerCase() : match2[0];
        var data2 = keywordData(top2, word);
        if (data2) {
          var kind = data2[0], keywordRelevance = data2[1];
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match2[0];
          } else {
            var cssClass = language.classNameAliases[kind] || kind;
            emitKeyword(match2[0], cssClass);
          }
        } else {
          buf += match2[0];
        }
        lastIndex = top2.keywordPatternRe.lastIndex;
        match2 = top2.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substring(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      var result2 = null;
      if (typeof top2.subLanguage === "string") {
        if (!languages[top2.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);
        continuations[top2.subLanguage] = /** @type {CompiledMode} */
        result2._top;
      } else {
        result2 = highlightAuto2(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);
      }
      if (top2.relevance > 0) {
        relevance += result2.relevance;
      }
      emitter.__addSublanguage(result2._emitter, result2.language);
    }
    function processBuffer() {
      if (top2.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitKeyword(keyword, scope) {
      if (keyword === "")
        return;
      emitter.startScope(scope);
      emitter.addText(keyword);
      emitter.endScope();
    }
    function emitMultiClass(scope, match2) {
      var i = 1;
      var max2 = match2.length - 1;
      while (i <= max2) {
        if (!scope._emit[i]) {
          i++;
          continue;
        }
        var klass = language.classNameAliases[scope[i]] || scope[i];
        var text = match2[i];
        if (klass) {
          emitKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i++;
      }
    }
    function startNewMode(mode, match2) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match2);
          modeBuffer = "";
        }
      }
      top2 = Object.create(mode, { parent: { value: top2 } });
      return top2;
    }
    function endOfMode(mode, match2, matchPlusRemainder) {
      var matched = startsWith(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          var resp = new Response(mode);
          mode["on:end"](match2, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match2, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top2.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match2) {
      var lexeme = match2[0];
      var newMode = match2.rule;
      var resp = new Response(newMode);
      var beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (var _i269 = 0, _beforeCallbacks2 = beforeCallbacks; _i269 < _beforeCallbacks2.length; _i269++) {
        var cb = _beforeCallbacks2[_i269];
        if (!cb)
          continue;
        cb(match2, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match2);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match2) {
      var lexeme = match2[0];
      var matchPlusRemainder = codeToHighlight.substring(match2.index);
      var endMode = endOfMode(top2, match2, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH;
      }
      var origin = top2;
      if (top2.endScope && top2.endScope._wrap) {
        processBuffer();
        emitKeyword(lexeme, top2.endScope._wrap);
      } else if (top2.endScope && top2.endScope._multi) {
        processBuffer();
        emitMultiClass(top2.endScope, match2);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top2.scope) {
          emitter.closeNode();
        }
        if (!top2.skip && !top2.subLanguage) {
          relevance += top2.relevance;
        }
        top2 = top2.parent;
      } while (top2 !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match2);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      var list = [];
      for (var current = top2; current !== language; current = current.parent) {
        if (current.scope) {
          list.unshift(current.scope);
        }
      }
      list.forEach(function(item) {
        return emitter.openNode(item);
      });
    }
    var lastMatch = {};
    function processLexeme(textBeforeMatch, match2) {
      var lexeme = match2 && match2[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match2.type === "end" && lastMatch.index === match2.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match2.index, match2.index + 1);
        if (!SAFE_MODE) {
          var err = new Error("0 width match regex (" + languageName + ")");
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match2;
      if (match2.type === "begin") {
        return doBeginMatch(match2);
      } else if (match2.type === "illegal" && !ignoreIllegals) {
        var _err3 = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top2.scope || "<unnamed>") + '"');
        _err3.mode = top2;
        throw _err3;
      } else if (match2.type === "end") {
        var processed = doEndMatch(match2);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }
      if (match2.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match2.index * 3) {
        var _err4 = new Error("potential infinite loop, way more iterations than matches");
        throw _err4;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    var language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    var md = compileLanguage(language);
    var result = "";
    var top2 = continuation || md;
    var continuations = {};
    var emitter = new options.__emitter(options);
    processContinuations();
    var modeBuffer = "";
    var relevance = 0;
    var index = 0;
    var iterations = 0;
    var resumeScanAtSamePosition = false;
    try {
      if (!language.__emitTokens) {
        top2.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top2.matcher.considerAll();
          }
          top2.matcher.lastIndex = index;
          var match = top2.matcher.exec(codeToHighlight);
          if (!match)
            break;
          var beforeMatch = codeToHighlight.substring(index, match.index);
          var processedCount = processLexeme(beforeMatch, match);
          index = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substring(index));
      } else {
        language.__emitTokens(codeToHighlight, emitter);
      }
      emitter.finalize();
      result = emitter.toHTML();
      return { language: languageName, value: result, relevance, illegal: false, _emitter: emitter, _top: top2 };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return { language: languageName, value: escape(codeToHighlight), illegal: true, relevance: 0, _illegalBy: { message: err.message, index, context: codeToHighlight.slice(index - 100, index + 100), mode: err.mode, resultSoFar: result }, _emitter: emitter };
      } else if (SAFE_MODE) {
        return { language: languageName, value: escape(codeToHighlight), illegal: false, relevance: 0, errorRaised: err, _emitter: emitter, _top: top2 };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code) {
    var result = { value: escape(code), illegal: false, relevance: 0, _top: PLAINTEXT_LANGUAGE, _emitter: new options.__emitter(options) };
    result._emitter.addText(code);
    return result;
  }
  function highlightAuto2(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    var plaintext2 = justTextHighlightResult(code);
    var results = languageSubset.filter(getLanguage).filter(autoDetection).map(function(name) {
      return _highlight(name, code, false);
    });
    results.unshift(plaintext2);
    var sorted = results.sort(function(a, b) {
      if (a.relevance !== b.relevance)
        return b.relevance - a.relevance;
      if (a.language && b.language) {
        if (getLanguage(a.language).supersetOf === b.language) {
          return 1;
        } else if (getLanguage(b.language).supersetOf === a.language) {
          return -1;
        }
      }
      return 0;
    });
    var best = sorted[0], secondBest = sorted[1];
    var result = best;
    result.secondBest = secondBest;
    return result;
  }
  function updateClassName(element, currentLang, resultLang) {
    var language = currentLang && aliases[currentLang] || resultLang;
    element.classList.add("hljs");
    element.classList.add("language-" + language);
  }
  function highlightElement(element) {
    var node = null;
    var language = blockLanguage(element);
    if (shouldNotHighlight(language))
      return;
    fire("before:highlightElement", { el: element, language });
    if (element.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element);
      }
      if (options.throwUnescapedHTML) {
        var err = new HTMLInjectionError("One of your code blocks includes unescaped HTML.", element.innerHTML);
        throw err;
      }
    }
    node = element;
    var text = node.textContent;
    var result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto2(text);
    element.innerHTML = result.value;
    updateClassName(element, language, result.language);
    element.result = {
      language: result.language,
      // TODO: remove with version 11.0
      re: result.relevance,
      relevance: result.relevance
    };
    if (result.secondBest) {
      element.secondBest = { language: result.secondBest.language, relevance: result.secondBest.relevance };
    }
    fire("after:highlightElement", { el: element, result, text });
  }
  function configure(userOptions) {
    options = inherit(options, userOptions);
  }
  var initHighlighting = function initHighlighting2() {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  var wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    var blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage2(languageName, languageDefinition) {
    var lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$13) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$13;
      } else {
        error(error$13);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (var _i270 = 0, _Object$keys2 = Object.keys(aliases); _i270 < _Object$keys2.length; _i270++) {
      var alias = _Object$keys2[_i270];
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages2() {
    return Object.keys(languages);
  }
  function getLanguage(name) {
    name = (name || "").toLowerCase();
    return languages[name] || languages[aliases[name]];
  }
  function registerAliases(aliasList, _ref256) {
    var languageName = _ref256.languageName;
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach(function(alias) {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name) {
    var lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = function(data2) {
        plugin["before:highlightBlock"](Object.assign({ block: data2.el }, data2));
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = function(data2) {
        plugin["after:highlightBlock"](Object.assign({ block: data2.el }, data2));
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function removePlugin(plugin) {
    var index = plugins.indexOf(plugin);
    if (index !== -1) {
      plugins.splice(index, 1);
    }
  }
  function fire(event, args) {
    var cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }
  function deprecateHighlightBlock(el) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");
    return highlightElement(el);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto: highlightAuto2,
    highlightAll,
    highlightElement,
    // TODO: Remove with v12 API
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage: registerLanguage2,
    unregisterLanguage,
    listLanguages: listLanguages2,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin,
    removePlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version$1;
  hljs.regex = { concat, lookahead, either, optional, anyNumberOfTimes };
  for (var key in MODES) {
    if (typeof MODES[key] === "object") {
      deepFreeze(MODES[key]);
    }
  }
  Object.assign(hljs, MODES);
  return hljs;
};
var highlight$1 = HLJS({});
highlight$1.newInstance = function() {
  return HLJS({});
};
var core = highlight$1;
highlight$1.HighlightJS = highlight$1;
highlight$1.default = highlight$1;
var HighlightJS = /* @__PURE__ */ getDefaultExportFromCjs(core);
var format = { exports: {} };
(function(module) {
  (function() {
    var namespace;
    {
      namespace = module.exports = format2;
    }
    namespace.format = format2;
    namespace.vsprintf = vsprintf;
    if (typeof console !== "undefined" && typeof console.log === "function") {
      namespace.printf = printf;
    }
    function printf() {
      console.log(format2.apply(null, arguments));
    }
    function vsprintf(fmt, replacements) {
      return format2.apply(null, [fmt].concat(replacements));
    }
    function format2(fmt) {
      var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c2, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function nextArg2() {
        return args[argIndex++];
      }, slurpNumber = function slurpNumber2() {
        var digits = "";
        while (/\d/.test(fmt[i])) {
          digits += fmt[i++];
          c2 = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
      };
      for (; i < n; ++i) {
        c2 = fmt[i];
        if (escaped) {
          escaped = false;
          if (c2 == ".") {
            leadingZero = false;
            c2 = fmt[++i];
          } else if (c2 == "0" && fmt[i + 1] == ".") {
            leadingZero = true;
            i += 2;
            c2 = fmt[i];
          } else {
            leadingZero = true;
          }
          precision = slurpNumber();
          switch (c2) {
            case "b":
              result += parseInt(nextArg(), 10).toString(2);
              break;
            case "c":
              arg = nextArg();
              if (typeof arg === "string" || arg instanceof String)
                result += arg;
              else
                result += String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
              result += parseInt(nextArg(), 10);
              break;
            case "f":
              tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
              result += leadingZero ? tmp : tmp.replace(/^0/, "");
              break;
            case "j":
              result += JSON.stringify(nextArg());
              break;
            case "o":
              result += "0" + parseInt(nextArg(), 10).toString(8);
              break;
            case "s":
              result += nextArg();
              break;
            case "x":
              result += "0x" + parseInt(nextArg(), 10).toString(16);
              break;
            case "X":
              result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
              break;
            default:
              result += c2;
              break;
          }
        } else if (c2 === "%") {
          escaped = true;
        } else {
          result += c2;
        }
      }
      return result;
    }
  })();
})(format);
var formatExports = format.exports;
var formatter = /* @__PURE__ */ getDefaultExportFromCjs(formatExports);
var fault = Object.assign(create(Error), { eval: create(EvalError), range: create(RangeError), reference: create(ReferenceError), syntax: create(SyntaxError), type: create(TypeError), uri: create(URIError) });
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format2) {
    for (var _len15 = arguments.length, values = new Array(_len15 > 1 ? _len15 - 1 : 0), _key17 = 1; _key17 < _len15; _key17++) {
      values[_key17 - 1] = arguments[_key17];
    }
    var reason = format2 ? formatter.apply(void 0, [format2].concat(values)) : format2;
    return new Constructor(reason);
  }
}
var own = {}.hasOwnProperty;
var defaultPrefix = "hljs-";
function highlight(language, value, options) {
  if (options === void 0) {
    options = {};
  }
  var prefix = options.prefix;
  if (typeof language !== "string") {
    throw fault("Expected `string` for name, got `%s`", language);
  }
  if (!HighlightJS.getLanguage(language)) {
    throw fault("Unknown language: `%s` is not registered", language);
  }
  if (typeof value !== "string") {
    throw fault("Expected `string` for value, got `%s`", value);
  }
  if (prefix === null || prefix === void 0) {
    prefix = defaultPrefix;
  }
  HighlightJS.configure({ __emitter: HastEmitter, classPrefix: prefix });
  var result = (
    /** @type {HighlightResult & {_emitter: HastEmitter}} */
    HighlightJS.highlight(value, { language, ignoreIllegals: true })
  );
  HighlightJS.configure({});
  if (result.errorRaised) {
    throw result.errorRaised;
  }
  result._emitter.root.data.language = result.language;
  result._emitter.root.data.relevance = result.relevance;
  return result._emitter.root;
}
function highlightAuto(value, options) {
  if (options === void 0) {
    options = {};
  }
  var subset = options.subset || HighlightJS.listLanguages();
  options.prefix;
  var index = -1;
  var result = { type: "root", data: { language: null, relevance: 0 }, children: [] };
  if (typeof value !== "string") {
    throw fault("Expected `string` for value, got `%s`", value);
  }
  while (++index < subset.length) {
    var name = subset[index];
    if (!HighlightJS.getLanguage(name))
      continue;
    var current = highlight(name, value, options);
    if (current.data.relevance > result.data.relevance)
      result = current;
  }
  return result;
}
function registerLanguage(language, syntax) {
  HighlightJS.registerLanguage(language, syntax);
}
var registerAlias = (
  /**
  * @type {(
  *   ((language: string, alias: string|Array<string>) => void) &
  *   ((aliases: Record<string, string|Array<string>>) => void)
  * )}
  */
  /**
  * @param {string|Record<string, string|Array<string>>} language
  * @param {string|Array<string>} [alias]
  * @returns {void}
  */
  function registerAlias2(language, alias) {
    if (typeof language === "string") {
      HighlightJS.registerAliases(alias, { languageName: language });
    } else {
      var key;
      for (key in language) {
        if (own.call(language, key)) {
          HighlightJS.registerAliases(language[key], { languageName: key });
        }
      }
    }
  }
);
function registered(aliasOrLanguage) {
  return Boolean(HighlightJS.getLanguage(aliasOrLanguage));
}
function listLanguages() {
  return HighlightJS.listLanguages();
}
var HastEmitter = /* @__PURE__ */ function() {
  function HastEmitter2(options) {
    this.options = options;
    this.root = { type: "root", data: { language: null, relevance: 0 }, children: [] };
    this.stack = [this.root];
  }
  var _proto93 = HastEmitter2.prototype;
  _proto93.addText = function addText(value) {
    if (value === "")
      return;
    var current = this.stack[this.stack.length - 1];
    var tail = current.children[current.children.length - 1];
    if (tail && tail.type === "text") {
      tail.value += value;
    } else {
      current.children.push({ type: "text", value });
    }
  };
  _proto93.startScope = function startScope(rawName) {
    this.openNode(String(rawName));
  };
  _proto93.endScope = function endScope() {
    this.closeNode();
  };
  _proto93.__addSublanguage = function __addSublanguage(other, name) {
    var current = this.stack[this.stack.length - 1];
    var results = other.root.children;
    if (name) {
      current.children.push({ type: "element", tagName: "span", properties: { className: [name] }, children: results });
    } else {
      var _current$children;
      (_current$children = current.children).push.apply(_current$children, results);
    }
  };
  _proto93.openNode = function openNode(name) {
    var _this132 = this;
    var className = name.split(".").map(function(d, i) {
      return i ? d + "_".repeat(i) : _this132.options.classPrefix + d;
    });
    var current = this.stack[this.stack.length - 1];
    var child = { type: "element", tagName: "span", properties: { className }, children: [] };
    current.children.push(child);
    this.stack.push(child);
  };
  _proto93.closeNode = function closeNode() {
    this.stack.pop();
  };
  _proto93.finalize = function finalize() {
  };
  _proto93.toHTML = function toHTML() {
    return "";
  };
  return HastEmitter2;
}();
var lowlight = { highlight, highlightAuto, registerLanguage, registered, listLanguages, registerAlias };
lowlight.registerLanguage("arduino", arduino);
lowlight.registerLanguage("bash", bash);
lowlight.registerLanguage("c", c);
lowlight.registerLanguage("cpp", cpp);
lowlight.registerLanguage("csharp", csharp);
lowlight.registerLanguage("css", css);
lowlight.registerLanguage("diff", diff);
lowlight.registerLanguage("go", go2);
lowlight.registerLanguage("graphql", graphql);
lowlight.registerLanguage("ini", ini);
lowlight.registerLanguage("java", java);
lowlight.registerLanguage("javascript", javascript$1);
lowlight.registerLanguage("json", json);
lowlight.registerLanguage("kotlin", kotlin);
lowlight.registerLanguage("less", less);
lowlight.registerLanguage("lua", lua);
lowlight.registerLanguage("makefile", makefile);
lowlight.registerLanguage("markdown", markdown);
lowlight.registerLanguage("objectivec", objectivec);
lowlight.registerLanguage("perl", perl);
lowlight.registerLanguage("php", php);
lowlight.registerLanguage("php-template", phpTemplate);
lowlight.registerLanguage("plaintext", plaintext);
lowlight.registerLanguage("python", python);
lowlight.registerLanguage("python-repl", pythonRepl);
lowlight.registerLanguage("r", r);
lowlight.registerLanguage("ruby", ruby);
lowlight.registerLanguage("rust", rust);
lowlight.registerLanguage("scss", scss);
lowlight.registerLanguage("shell", shell);
lowlight.registerLanguage("sql", sql);
lowlight.registerLanguage("swift", swift);
lowlight.registerLanguage("typescript", typescript);
lowlight.registerLanguage("vbnet", vbnet);
lowlight.registerLanguage("wasm", wasm);
lowlight.registerLanguage("xml", xml);
lowlight.registerLanguage("yaml", yaml);
var richTextEditorProps = _extends({}, $props, { modelValue: { type: String, default: "" }, placeholder: { type: String, default: "" }, customToolBar: { type: Array, default: [] }, options: { type: Object, default: {} } });
var _sfc_main = defineComponent$1({ name: $prefix + "RichTextEditor", emits: ["beforeCreate", "create", "update:modelValue", "focus", "blur", "selectionUpdate", "transaction", "destroy", "update"], directives: directive({ Clickoutside }), props: richTextEditorProps, components: { EditorContent, BubbleMenu, TinyIconRichTextAddColumnAfter: iconRichTextAddColumnAfter(), TinyIconRichTextAddColumnBefore: iconRichTextAddColumnBefore(), TinyIconRichTextAddRowAfter: iconRichTextAddRowAfter(), TinyIconRichTextAddRowBefore: iconRichTextAddRowBefore(), TinyIconRichTextAlignCenter: iconRichTextAlignCenter(), TinyIconRichTextAlignLeft: iconRichTextAlignLeft(), TinyIconRichTextAlignRight: iconRichTextAlignRight(), TinyIconRichTextBold: iconRichTextBold(), TinyIconRichTextCodeBlock: iconRichTextCodeBlock(), TinyIconRichTextCodeView: iconRichTextCodeView(), TinyIconRichTextColor: IconEditorTextcolor(), TinyIconRichbackgroundColor: IconEditorBackground(), TinyIconRichTextDeleteColumn: iconRichTextDeleteColumn(), TinyIconRichTextDeleteRow: iconRichTextDeleteRow(), TinyIconRichTextDeleteTable: iconRichTextDeleteTable(), TinyIconRichTextFontSize: iconRichTextFontSize(), TinyIconRichTextFormatClear: iconRichTextFormatClear(), TinyIconRichTextH1: iconRichTextH1(), TinyIconRichTextH2: iconRichTextH2(), TinyIconRichTextH3: iconRichTextH3(), TinyIconRichTextH4: iconRichTextH4(), TinyIconRichTextH5: iconRichTextH5(), TinyIconRichTextH6: iconRichTextH6(), TinyIconRichTextHeading: iconRichTextHeading(), TinyIconRichTextHighLight: iconRichTextHighLight(), TinyIconRichTextItalic: iconRichTextItalic(), TinyIconRichTextImage: IconRichTextImage(), TinyIconRichTextLineHeight: iconRichTextLineHeight(), TinyIconRichTextLink: iconRichTextLink(), TinyIconRichTextLinkUnlink: iconRichTextLinkUnlink(), TinyIconRichTextListOrdered: iconRichTextListOrdered(), TinyIconRichTextListUnordered: iconRichTextListUnordered(), TinyIconRichTextMergeCells: iconRichTextMergeCells(), TinyIconRichTextMergeCellsVertical: iconRichTextMergeCellsVertical(), TinyIconRichTextNodeDelete: iconRichTextNodeDelete(), TinyIconRichTextParagraph: iconRichTextParagraph(), TinyIconRichTextQuoteText: iconRichTextQuoteText(), TinyIconRichTextRedo: iconRichTextRedo(), TinyIconRichTextSplitCellsHorizontal: iconRichTextSplitCellsHorizontal(), TinyIconRichTextSplitCellsVertical: iconRichTextSplitCellsVertical(), TinyIconRichTextStrikeThrough: iconRichTextStrikeThrough(), TinyIconRichTextSubscript: iconRichTextSubscript(), TinyIconRichTextSuperscript: iconRichTextSuperscript(), TinyIconRichTextTable: iconRichTextTable(), TinyIconRichTextTaskList: iconRichTextTaskList(), TinyIconRichTextUnderline: iconRichTextUnderline(), TinyIconRichTextUndo: iconRichTextUndo() }, setup: function setup4(props, context) {
  return _setup({ props, context, renderless, api, mono: true, extendOptions: { Editor, StarterKit, Table, TableCell, TableHeader, TableRow, Color, TextStyle, Image, Highlight, Link, Underline, Subscript, Superscript, TaskItem, TaskList, TextAlign, Paragraph, mergeAttributes, CodeBlockLowlight, lowlight, VueNodeViewRenderer, Placeholder, codeHighlight } });
} });
var _hoisted_1 = { class: "tiny-rich-text-editor" };
var _hoisted_2 = { class: "tiny-rich-text-editor__toolbar" };
var _hoisted_3 = ["title"];
var _hoisted_4 = { class: "font-size-options" };
var _hoisted_5 = ["title"];
var _hoisted_6 = { class: "line-height-icon" };
var _hoisted_7 = { class: "line-height-options" };
var _hoisted_8 = ["title"];
var _hoisted_9 = { class: "h-ico" };
var _hoisted_10 = { class: "h-options" };
var _hoisted_11 = ["title"];
var _hoisted_12 = { class: "img-option" };
var _hoisted_13 = { class: "img-item" };
var _hoisted_14 = /* @__PURE__ */ createElementVNode(
  "label",
  { for: "img-btn" },
  "本地资源",
  -1
  /* HOISTED */
);
var _hoisted_15 = /* @__PURE__ */ createElementVNode(
  "div",
  null,
  "资源链接",
  -1
  /* HOISTED */
);
var _hoisted_16 = [_hoisted_15];
var _hoisted_17 = ["title"];
var _hoisted_18 = { for: "tiny-color" };
var _hoisted_19 = ["title"];
var _hoisted_20 = { for: "tiny--back-color" };
var _hoisted_21 = ["title"];
var _hoisted_22 = { class: "table-icon" };
var _hoisted_23 = { class: "table-row" };
var _hoisted_24 = { class: "table-row" };
var _hoisted_25 = { class: "table-row" };
var _hoisted_26 = { class: "table-row" };
var _hoisted_27 = ["title", "onClick", "disabled"];
var _hoisted_28 = ["src"];
var _hoisted_29 = ["title", "onClick"];
var _hoisted_30 = ["src"];
var _hoisted_31 = ["disabled"];
var _hoisted_32 = ["disabled"];
var _hoisted_33 = ["disabled"];
var _hoisted_34 = ["disabled"];
var _hoisted_35 = ["disabled"];
var _hoisted_36 = ["disabled"];
var _hoisted_37 = ["disabled"];
var _hoisted_38 = ["disabled"];
var _hoisted_39 = ["disabled"];
var _hoisted_40 = { class: "tiny-rich-text-editor__container" };
function _sfc_render(_ctx, _cache, $props2, $setup, $data, $options) {
  var _component_TinyIconRichTextFontSize = resolveComponent("TinyIconRichTextFontSize");
  var _component_TinyIconRichTextLineHeight = resolveComponent("TinyIconRichTextLineHeight");
  var _component_TinyIconRichTextHeading = resolveComponent("TinyIconRichTextHeading");
  var _component_TinyIconRichTextParagraph = resolveComponent("TinyIconRichTextParagraph");
  var _component_TinyIconRichTextH1 = resolveComponent("TinyIconRichTextH1");
  var _component_TinyIconRichTextH2 = resolveComponent("TinyIconRichTextH2");
  var _component_TinyIconRichTextH3 = resolveComponent("TinyIconRichTextH3");
  var _component_TinyIconRichTextH4 = resolveComponent("TinyIconRichTextH4");
  var _component_TinyIconRichTextH5 = resolveComponent("TinyIconRichTextH5");
  var _component_TinyIconRichTextH6 = resolveComponent("TinyIconRichTextH6");
  var _component_TinyIconRichTextImage = resolveComponent("TinyIconRichTextImage");
  var _component_TinyIconRichTextColor = resolveComponent("TinyIconRichTextColor");
  var _component_TinyIconRichbackgroundColor = resolveComponent("TinyIconRichbackgroundColor");
  var _component_TinyIconRichTextTable = resolveComponent("TinyIconRichTextTable");
  var _component_TinyIconRichTextAddColumnBefore = resolveComponent("TinyIconRichTextAddColumnBefore");
  var _component_TinyIconRichTextAddColumnAfter = resolveComponent("TinyIconRichTextAddColumnAfter");
  var _component_TinyIconRichTextDeleteColumn = resolveComponent("TinyIconRichTextDeleteColumn");
  var _component_TinyIconRichTextAddRowBefore = resolveComponent("TinyIconRichTextAddRowBefore");
  var _component_TinyIconRichTextAddRowAfter = resolveComponent("TinyIconRichTextAddRowAfter");
  var _component_TinyIconRichTextDeleteRow = resolveComponent("TinyIconRichTextDeleteRow");
  var _component_TinyIconRichTextDeleteTable = resolveComponent("TinyIconRichTextDeleteTable");
  var _component_TinyIconRichTextMergeCells = resolveComponent("TinyIconRichTextMergeCells");
  var _component_BubbleMenu = resolveComponent("BubbleMenu");
  var _component_EditorContent = resolveComponent("EditorContent");
  var _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createElementBlock("div", _hoisted_1, [createElementVNode("div", _hoisted_2, [(openBlock(true), createElementBlock(
    Fragment$1,
    null,
    renderList(_ctx.state.toolbar, function(item) {
      var _ctx$state$editor, _ctx$state$editor2;
      return openBlock(), createElementBlock(
        Fragment$1,
        null,
        [item === "font-size" ? (openBlock(), createElementBlock("button", { key: 0, title: _ctx.t("ui.richTextEditor.fontSize"), class: "font-size-box" }, [createVNode(_component_TinyIconRichTextFontSize), createElementVNode("div", _hoisted_4, [createElementVNode("button", { onClick: _cache[0] || (_cache[0] = function($event) {
          return _ctx.state.editor.chain().focus().setSize({ size: 12 }).run();
        }) }, "12px"), createElementVNode("button", { onClick: _cache[1] || (_cache[1] = function($event) {
          return _ctx.state.editor.chain().focus().setSize({ size: 14 }).run();
        }) }, "14px"), createElementVNode("button", { onClick: _cache[2] || (_cache[2] = function($event) {
          return _ctx.state.editor.chain().focus().setSize({ size: 16 }).run();
        }) }, "16px"), createElementVNode("button", { onClick: _cache[3] || (_cache[3] = function($event) {
          return _ctx.state.editor.chain().focus().setSize({ size: 18 }).run();
        }) }, "18px"), createElementVNode("button", { onClick: _cache[4] || (_cache[4] = function($event) {
          return _ctx.state.editor.chain().focus().setSize({ size: 20 }).run();
        }) }, "20px"), createElementVNode("button", { onClick: _cache[5] || (_cache[5] = function($event) {
          return _ctx.state.editor.chain().focus().setSize({ size: 24 }).run();
        }) }, "24px"), createElementVNode("button", { onClick: _cache[6] || (_cache[6] = function($event) {
          return _ctx.state.editor.chain().focus().setSize({ size: 30 }).run();
        }) }, "30px")])], 8, _hoisted_3)) : item === "line-height" ? (openBlock(), createElementBlock("button", { key: 1, class: "line-height-button", title: _ctx.t("ui.richTextEditor.lineHeight") }, [createElementVNode("div", _hoisted_6, [createVNode(_component_TinyIconRichTextLineHeight)]), createElementVNode("div", _hoisted_7, [createElementVNode("button", { class: "line-1.0", onClick: _cache[7] || (_cache[7] = withModifiers(function($event) {
          return _ctx.state.editor.chain().focus().setP({ level: 1 }).run();
        }, ["stop"])) }, "1.0"), createElementVNode("button", { class: "line-1.5", onClick: _cache[8] || (_cache[8] = withModifiers(function($event) {
          return _ctx.state.editor.chain().focus().setP({ level: 1.5 }).run();
        }, ["stop"])) }, "1.5"), createElementVNode("button", { class: "line-2.0", onClick: _cache[9] || (_cache[9] = withModifiers(function($event) {
          return _ctx.state.editor.chain().focus().setP({ level: 2 }).run();
        }, ["stop"])) }, "2.0"), createElementVNode("button", { class: "line-2.5", onClick: _cache[10] || (_cache[10] = withModifiers(function($event) {
          return _ctx.state.editor.chain().focus().setP({ level: 2.5 }).run();
        }, ["stop"])) }, "2.5")])], 8, _hoisted_5)) : item === "h-box" ? (openBlock(), createElementBlock("button", { key: 2, title: _ctx.t("ui.richTextEditor.hBox"), class: "h-box" }, [createElementVNode("div", _hoisted_9, [createVNode(_component_TinyIconRichTextHeading)]), createElementVNode("div", _hoisted_10, [createElementVNode("button", { title: "paragraph", onClick: _cache[11] || (_cache[11] = function($event) {
          return _ctx.state.editor.chain().focus().setParagraph().run();
        }) }, [createVNode(_component_TinyIconRichTextParagraph)]), createElementVNode("button", { title: "h1", onClick: _cache[12] || (_cache[12] = function($event) {
          return _ctx.state.editor.chain().focus().toggleHeading({ level: 1 }).run();
        }) }, [createVNode(_component_TinyIconRichTextH1)]), createElementVNode("button", { title: "h2", onClick: _cache[13] || (_cache[13] = function($event) {
          return _ctx.state.editor.chain().focus().toggleHeading({ level: 2 }).run();
        }) }, [createVNode(_component_TinyIconRichTextH2)]), createElementVNode("button", { title: "h3", onClick: _cache[14] || (_cache[14] = function($event) {
          return _ctx.state.editor.chain().focus().toggleHeading({ level: 3 }).run();
        }) }, [createVNode(_component_TinyIconRichTextH3)]), createElementVNode("button", { title: "h4", onClick: _cache[15] || (_cache[15] = function($event) {
          return _ctx.state.editor.chain().focus().toggleHeading({ level: 4 }).run();
        }) }, [createVNode(_component_TinyIconRichTextH4)]), createElementVNode("button", { title: "h5", onClick: _cache[16] || (_cache[16] = function($event) {
          return _ctx.state.editor.chain().focus().toggleHeading({ level: 5 }).run();
        }) }, [createVNode(_component_TinyIconRichTextH5)]), createElementVNode("button", { title: "h6", onClick: _cache[17] || (_cache[17] = function($event) {
          return _ctx.state.editor.chain().focus().toggleHeading({ level: 6 }).run();
        }) }, [createVNode(_component_TinyIconRichTextH6)])])], 8, _hoisted_8)) : item === "img" ? (openBlock(), createElementBlock("button", { key: 3, title: _ctx.t("ui.richTextEditor.img"), class: "image-button" }, [createVNode(_component_TinyIconRichTextImage), createElementVNode("div", _hoisted_12, [createElementVNode("div", _hoisted_13, [createElementVNode(
          "input",
          { onChange: _cache[18] || (_cache[18] = function() {
            return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
          }), id: "img-btn", type: "file", accept: "image/*, video/*" },
          null,
          32
          /* NEED_HYDRATION */
        ), _hoisted_14]), createElementVNode("div", { onClick: _cache[19] || (_cache[19] = withModifiers(function($event) {
          return _ctx.handleChange(null);
        }, ["stop"])), class: "img-item" }, _hoisted_16)])], 8, _hoisted_11)) : item === "color" ? (openBlock(), createElementBlock("button", { key: 4, title: _ctx.t("ui.richTextEditor.color"), class: "color-button" }, [createElementVNode("label", _hoisted_18, [createVNode(_component_TinyIconRichTextColor)]), createElementVNode(
          "input",
          { id: "tiny-color", type: "color", onInput: _cache[20] || (_cache[20] = function($event) {
            return _ctx.state.editor.chain().focus().setColor($event.target.value).run();
          }) },
          null,
          32
          /* NEED_HYDRATION */
        )], 8, _hoisted_17)) : item === "backgroundColor" ? (openBlock(), createElementBlock("button", { key: 5, title: _ctx.t("ui.richTextEditor.backgroundColor"), class: "color-button" }, [createElementVNode("label", _hoisted_20, [createVNode(_component_TinyIconRichbackgroundColor)]), createElementVNode(
          "input",
          { id: "tiny-back-color", type: "color", onInput: _cache[21] || (_cache[21] = function($event) {
            return _ctx.state.editor.chain().focus().setBackColor({ bgColor: $event.target.value }).run();
          }) },
          null,
          32
          /* NEED_HYDRATION */
        )], 8, _hoisted_19)) : item === "table" ? (openBlock(), createElementBlock("button", { key: 6, title: _ctx.t("ui.richTextEditor.table"), class: "table-button" }, [withDirectives((openBlock(), createElementBlock("div", { class: "table-box", onClick: _cache[24] || (_cache[24] = function() {
          return _ctx.toggleTablePanel && _ctx.toggleTablePanel.apply(_ctx, arguments);
        }) }, [createElementVNode("div", _hoisted_22, [createVNode(_component_TinyIconRichTextTable)]), _ctx.state.isShowTable ? (openBlock(), createElementBlock(
          "div",
          { key: 0, class: "table-panel", ref_for: true, ref: "tablePanelRef", onMousemove: _cache[22] || (_cache[22] = function() {
            return _ctx.tableMouseMove && _ctx.tableMouseMove.apply(_ctx, arguments);
          }), onClick: _cache[23] || (_cache[23] = withModifiers(function() {
            return _ctx.tableChoose && _ctx.tableChoose.apply(_ctx, arguments);
          }, ["stop"])) },
          [createElementVNode("div", _hoisted_23, [createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 1 <= _ctx.state.flagX && 1 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 2 <= _ctx.state.flagX && 1 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 3 <= _ctx.state.flagX && 1 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 4 <= _ctx.state.flagX && 1 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          )]), createElementVNode("div", _hoisted_24, [createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 1 <= _ctx.state.flagX && 2 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 2 <= _ctx.state.flagX && 2 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 3 <= _ctx.state.flagX && 2 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 4 <= _ctx.state.flagX && 2 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          )]), createElementVNode("div", _hoisted_25, [createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 1 <= _ctx.state.flagX && 3 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 2 <= _ctx.state.flagX && 3 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 3 <= _ctx.state.flagX && 3 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 4 <= _ctx.state.flagX && 3 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          )]), createElementVNode("div", _hoisted_26, [createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 1 <= _ctx.state.flagX && 4 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 2 <= _ctx.state.flagX && 4 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 3 <= _ctx.state.flagX && 4 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          ), createElementVNode(
            "div",
            { class: normalizeClass(["item", { isActive: 4 <= _ctx.state.flagX && 4 <= _ctx.state.flagY }]) },
            null,
            2
            /* CLASS */
          )])],
          544
          /* NEED_HYDRATION, NEED_PATCH */
        )) : createCommentVNode("v-if", true)])), [[_directive_clickoutside, _ctx.closeTablePanel]])], 8, _hoisted_21)) : item === "unlink" ? (openBlock(), createElementBlock("button", { key: 7, title: _ctx.t("ui.richTextEditor.unlink"), onClick: function onClick($event) {
          return _ctx.eventClick(_ctx.state.editor, item);
        }, disabled: !((_ctx$state$editor = _ctx.state.editor) != null && _ctx$state$editor.isActive(_ctx.Active(item))) }, [item.img ? (openBlock(), createElementBlock("img", { key: 0, src: _ctx.eventImg(item), alt: "", srcset: "" }, null, 8, _hoisted_28)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.eventImg(item)), { key: 1 }))], 8, _hoisted_27)) : (openBlock(), createElementBlock("button", { key: 8, title: _ctx.t("ui.richTextEditor." + item), onClick: function onClick($event) {
          return _ctx.eventClick(_ctx.state.editor, item);
        }, class: normalizeClass({ "is-active": (_ctx$state$editor2 = _ctx.state.editor) == null ? void 0 : _ctx$state$editor2.isActive(_ctx.Active(item)) }) }, [item.img ? (openBlock(), createElementBlock("img", { key: 0, src: _ctx.eventImg(item), alt: "", srcset: "" }, null, 8, _hoisted_30)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.eventImg(item)), { key: 1 }))], 10, _hoisted_29))],
        64
        /* STABLE_FRAGMENT */
      );
    }),
    256
    /* UNKEYED_FRAGMENT */
  )), renderSlot(_ctx.$slots, "toolBar", { option: _ctx.state.editor }), _ctx.state.editor ? (openBlock(), createBlock(_component_BubbleMenu, { key: 0, editor: _ctx.state.editor, "tippy-options": { duration: 100 }, "should-show": _ctx.shouldShow, class: "bubble-menu" }, {
    default: withCtx(function() {
      var _ctx$state$editor3, _ctx$state$editor4, _ctx$state$editor5, _ctx$state$editor6, _ctx$state$editor7, _ctx$state$editor8, _ctx$state$editor9, _ctx$state$editor10, _ctx$state$editor11;
      return [createElementVNode("button", { title: "add column before", onClick: _cache[25] || (_cache[25] = function($event) {
        return _ctx.state.editor.chain().focus().addColumnBefore().run();
      }), disabled: !((_ctx$state$editor3 = _ctx.state.editor) != null && _ctx$state$editor3.can().addColumnBefore()) }, [createVNode(_component_TinyIconRichTextAddColumnBefore)], 8, _hoisted_31), createElementVNode("button", { title: "add column after", onClick: _cache[26] || (_cache[26] = function($event) {
        return _ctx.state.editor.chain().focus().addColumnAfter().run();
      }), disabled: !((_ctx$state$editor4 = _ctx.state.editor) != null && _ctx$state$editor4.can().addColumnAfter()) }, [createVNode(_component_TinyIconRichTextAddColumnAfter)], 8, _hoisted_32), createElementVNode("button", { title: "delete column", onClick: _cache[27] || (_cache[27] = function($event) {
        return _ctx.state.editor.chain().focus().deleteColumn().run();
      }), disabled: !((_ctx$state$editor5 = _ctx.state.editor) != null && _ctx$state$editor5.can().deleteColumn()) }, [createVNode(_component_TinyIconRichTextDeleteColumn)], 8, _hoisted_33), createElementVNode("button", { title: "add row before", onClick: _cache[28] || (_cache[28] = function($event) {
        return _ctx.state.editor.chain().focus().addRowBefore().run();
      }), disabled: !((_ctx$state$editor6 = _ctx.state.editor) != null && _ctx$state$editor6.can().addRowBefore()) }, [createVNode(_component_TinyIconRichTextAddRowBefore)], 8, _hoisted_34), createElementVNode("button", { title: "add row after", onClick: _cache[29] || (_cache[29] = function($event) {
        return _ctx.state.editor.chain().focus().addRowAfter().run();
      }), disabled: !((_ctx$state$editor7 = _ctx.state.editor) != null && _ctx$state$editor7.can().addRowAfter()) }, [createVNode(_component_TinyIconRichTextAddRowAfter)], 8, _hoisted_35), createElementVNode("button", { title: "delete row", onClick: _cache[30] || (_cache[30] = function($event) {
        return _ctx.state.editor.chain().focus().deleteRow().run();
      }), disabled: !((_ctx$state$editor8 = _ctx.state.editor) != null && _ctx$state$editor8.can().deleteRow()) }, [createVNode(_component_TinyIconRichTextDeleteRow)], 8, _hoisted_36), createElementVNode("button", { title: "delete table", onClick: _cache[31] || (_cache[31] = function($event) {
        return _ctx.state.editor.chain().focus().deleteTable().run();
      }), disabled: !((_ctx$state$editor9 = _ctx.state.editor) != null && _ctx$state$editor9.can().deleteTable()) }, [createVNode(_component_TinyIconRichTextDeleteTable)], 8, _hoisted_37), createElementVNode("button", { title: "toggle header cell", onClick: _cache[32] || (_cache[32] = function($event) {
        return _ctx.state.editor.chain().focus().toggleHeaderCell().run();
      }), disabled: !((_ctx$state$editor10 = _ctx.state.editor) != null && _ctx$state$editor10.can().toggleHeaderCell()) }, [createVNode(_component_TinyIconRichTextHeading)], 8, _hoisted_38), createElementVNode("button", { title: "merge Or split", onClick: _cache[33] || (_cache[33] = function($event) {
        return _ctx.state.editor.chain().focus().mergeOrSplit().run();
      }), disabled: !((_ctx$state$editor11 = _ctx.state.editor) != null && _ctx$state$editor11.can().mergeOrSplit()) }, [createVNode(_component_TinyIconRichTextMergeCells)], 8, _hoisted_39)];
    }),
    _: 1
    /* STABLE */
  }, 8, ["editor", "should-show"])) : createCommentVNode("v-if", true)]), createElementVNode("div", _hoisted_40, [createVNode(_component_EditorContent, { editor: _ctx.state.editor }, null, 8, ["editor"])])]);
}
var RichTextEditor = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var version = "3.13.0";
RichTextEditor.install = function(Vue) {
  Vue.component(RichTextEditor.name, RichTextEditor);
};
RichTextEditor.version = version;
export {
  RichTextEditor as default
};
